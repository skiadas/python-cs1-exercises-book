<section xml:id="sec-HW7-PRACTICE-1">
  <title>HW7 PRACTICE</title>
  <introduction>
    <p dir="ltr">  - Ungraded assignment, use it to practice for Quiz 7</p>
  </introduction>
  <exercises>
    <exercise xml:id="exer-swap_list_ends-2" label="exe-sec-HW7-PRACTICE-1-143722">
      <title>Swap List Ends</title>
      <statement>
        <p>The function <c>swap_list_ends</c>, takes one parameter, <c>L</c>, which is a list. The function then swaps the first and last items in <c>L</c> and returns the object <c>None</c>.  Notice that since <c>L</c> is mutable, the changes the function makes to <c>L</c> are <em>visible back in the calling program</em>.</p>
        <p>SPECIAL CASE: If the list 'L' is empty, then the function does nothing to L and returns <c>None</c>.</p>
      </statement>
      <program interactive="activecode" language="python">
        <input>_my_out = ""
_my_in = []

def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise EOFError()
  return _my_in.pop()





^^^^

        </input>
        <tests>



from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = [1, 3, 9, 2]
    if not(swap_list_ends(L) is None):
        print("Error: function should return None")
    print(L)
    
    self.assertEqual('[2, 3, 9, 1]', getMyStdOut())


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = ['two', 'dos', 2]
    if not(swap_list_ends(L) is None):
        print("Error: function should return None")
    print(L)
    
    self.assertEqual("[2, 'dos', 'two']", getMyStdOut())


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = [True, False]
    if not(swap_list_ends(L) is None):
        print("Error: function should return None")
    print(L)
    
    self.assertEqual('[False, True]', getMyStdOut())


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = ["snowy"]
    if not(swap_list_ends(L) is None):
        print("Error: function should return None")
    print(L)
    
    self.assertEqual("['snowy']", getMyStdOut())


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = [0.0, -0.2, -0.4, -0.6, -0.8, -1.0]
    if not(swap_list_ends(L) is None):
        print("Error: function should return None")
    print(L)
    
    self.assertEqual('[-1.0, -0.2, -0.4, -0.6, -0.8, 0.0]', getMyStdOut())


  def test6(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = ['Ziggy', 'Spike', 'Cleo', 'Skye', 'Ruthie']
    if not(swap_list_ends(L) is None):
        print("Error: function should return None")
    print(L)
    
    self.assertEqual("['Ruthie', 'Spike', 'Cleo', 'Skye', 'Ziggy']", getMyStdOut())


  def test7(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = ['C', 'C++', 'C#', 'Java', 'Javascript', 'Python']
    if not(swap_list_ends(L) is None):
        print("Error: function should return None")
    print(L)
    
    self.assertEqual("['Python', 'C++', 'C#', 'Java', 'Javascript', 'C']\n", getMyStdOut())


  def test8(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = []
    if not(swap_list_ends(L) is None):
        print("Error: function should return None")
    print(L)
    
    
    self.assertEqual('[]', getMyStdOut())


  def test9(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = ["happy", "birthday", "to", "Monty"]
    if not(swap_list_ends(L) is None):
        print("Error: function should return None")
    print(L)
    
    
    self.assertEqual("['Monty', 'birthday', 'to', 'happy']", getMyStdOut())



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-make_list_items_upper_2-4" label="exe-sec-HW7-PRACTICE-1-144077">
      <title>Make List Items Uppercase 2</title>
      <statement>
        <p>Define the function <c>make_uppercase(mylist)</c>, which takes a list parameter <c>mylist</c> (a list of strings), mutates the list by uppercasing each string in mylist. The function returns <c>None</c>. </p>
        <p>For example, if <c>mylist</c> is <c>['cat', 'Dog', 'frOG']</c>, then the mutated list should  be <c>['CAT', 'DOG', 'FROG']</c>. </p>
      </statement>
      <program interactive="activecode" language="python">
        <input>_my_out = ""
_my_in = []

def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise EOFError()
  return _my_in.pop()





^^^^

        </input>
        <tests>



from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')
    
    mylist = ['cat', 'Dog', 'frOG']
    result = make_uppercase(mylist)
    print(mylist)
    if result != None:
        print("Error, return value should be None")
    
    self.assertEqual("['CAT', 'DOG', 'FROG']\n", getMyStdOut())


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')
    
    mylist = ['baNanas', 'appLes', 'pEAches', 'PEArs']
    result = make_uppercase(mylist)
    print(mylist)
    if result != None:
        print("Error, return value should be None")
    
    self.assertEqual("['BANANAS', 'APPLES', 'PEACHES', 'PEARS']\n", getMyStdOut())


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')
    
    mylist = ['w', 'x', 'y', 'z', 'yes']
    result = make_uppercase(mylist)
    print(mylist)
    if result != None:
        print("Error, return value should be None")
    
    self.assertEqual("['W', 'X', 'Y', 'Z', 'YES']\n", getMyStdOut())


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')
    
    mylist = []
    result = make_uppercase(mylist)
    print(mylist)
    if result != None:
        print("Error, return value should be None")
    
    self.assertEqual('[]\n', getMyStdOut())


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')
    
    mylist = ['cOw', 'HoRse', 'pig', 'BUNNy']
    result = make_uppercase(mylist)
    print(mylist)
    if result != None:
        print("Error, return value should be None")
    
    self.assertEqual("['COW', 'HORSE', 'PIG', 'BUNNY']\n", getMyStdOut())



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-square_nums_2-2" label="exe-sec-HW7-PRACTICE-1-161273">
      <title>Square Nums 2</title>
      <statement>
        <p>Define the function <c>square_nums_2</c> which takes a list of numbers, <alert>L</alert>, and mutates <alert>L</alert> so that each original item is now squared. For example, if L is <c>[2, -5, 9]</c> then, after calling <c>square_nums_2(L)</c>, <c>L == [4, 25, 81]</c>. </p>
        <p>Nothing is printed and None is returned.</p>
      </statement>
      <program interactive="activecode" language="python">
        <input>_my_out = ""
_my_in = []

def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise EOFError()
  return _my_in.pop()





^^^^

        </input>
        <tests>



from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = [0, 1, 2, 3]
    square_nums_2(L)
    print(L)
    
    self.assertEqual('[0, 1, 4, 9]\n', getMyStdOut())


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = [5]
    square_nums_2(L)
    print(L)
    
    self.assertEqual('[25]\n', getMyStdOut())


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = []
    square_nums_2(L)
    print(L)
    
    self.assertEqual('[]\n', getMyStdOut())


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = [-1, 1, -2, 2, -3, 3]
    square_nums_2(L)
    print(L)
    
    self.assertEqual('[1, 1, 4, 4, 9, 9]\n', getMyStdOut())


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = [9, 94, 39, 60, 99, 83]
    square_nums_2(L)
    print(L)
    
    self.assertEqual('[81, 8836, 1521, 3600, 9801, 6889]\n', getMyStdOut())


  def test6(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L  = [99, 9, 94, 39, 60, 83, 99]
    square_nums_2(L)
    print(L)
    
    self.assertEqual('[9801, 81, 8836, 1521, 3600, 6889, 9801]\n', getMyStdOut())



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-nested_accum_hyphenated_pairs-2" label="exe-sec-HW7-PRACTICE-1-145020">
      <title>Hyphenated Pairs with Nested Loop</title>
      <statement>
        <p>Define the function <c>get_pairs</c>, which takes a list L of strings, such as </p>
        <pre>L = ['r', 'g']</pre>
        <p>and returns a list of all the hyphenated pairs of strings from the list (returns a list of strings, such as <c>['r-r', 'r-g', 'g-r', 'g-g']</c>)</p>
        <p>Use a double for loop to accumulate the result.</p>
      </statement>
      <program interactive="activecode" language="python">
        <input>_my_out = ""
_my_in = []

def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise EOFError()
  return _my_in.pop()





^^^^

        </input>
        <tests>



from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = ['yes', 'no', 'maybe']
    print(get_pairs(L))
    
    self.assertEqual("['yes-yes', 'yes-no', 'yes-maybe', 'no-yes', 'no-no', 'no-maybe', 'maybe-yes', 'maybe-no', 'maybe-maybe']\n", getMyStdOut())


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')
    
    fish = ["angel", "gold", "cat", "puffer", "damsel"]
    print(get_pairs(fish))
    
    self.assertEqual("['angel-angel', 'angel-gold', 'angel-cat', 'angel-puffer', 'angel-damsel', 'gold-angel', 'gold-gold', 'gold-cat', 'gold-puffer', 'gold-damsel', 'cat-angel', 'cat-gold', 'cat-cat', 'cat-puffer', 'cat-damsel', 'puffer-angel', 'puffer-gold', 'puffer-cat', 'puffer-puffer', 'puffer-damsel', 'damsel-angel', 'damsel-gold', 'damsel-cat', 'damsel-puffer', 'damsel-damsel']\n", getMyStdOut())


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')
    
    strlist = ["X", "x"]
    print(get_pairs(strlist))
    
    self.assertEqual("['X-X', 'X-x', 'x-X', 'x-x']\n", getMyStdOut())


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')
    
    empty = []
    print(get_pairs(empty))
    
    self.assertEqual('[]\n', getMyStdOut())


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = ["UNO"]
    print(get_pairs(L))
    
    self.assertEqual("['UNO-UNO']\n", getMyStdOut())


  def test6(self):
    resetMyStdOut()
    setMyStdIn('')
    
    food = ['apple', 'cheese', 'bread']
    print(get_pairs(food))
    
    self.assertEqual("['apple-apple', 'apple-cheese', 'apple-bread', 'cheese-apple', 'cheese-cheese', 'cheese-bread', 'bread-apple', 'bread-cheese', 'bread-bread']\n", getMyStdOut())


  def test7(self):
    resetMyStdOut()
    setMyStdIn('')
    
    instruments = ["Box drum", "Paixiao", "Saxophone", "Txistu", "Xalam", "Xaphoon", "Xun", "Xylophone"]
    print(get_pairs(instruments))
    
    self.assertEqual("['Box drum-Box drum', 'Box drum-Paixiao', 'Box drum-Saxophone', 'Box drum-Txistu', 'Box drum-Xalam', 'Box drum-Xaphoon', 'Box drum-Xun', 'Box drum-Xylophone', 'Paixiao-Box drum', 'Paixiao-Paixiao', 'Paixiao-Saxophone', 'Paixiao-Txistu', 'Paixiao-Xalam', 'Paixiao-Xaphoon', 'Paixiao-Xun', 'Paixiao-Xylophone', 'Saxophone-Box drum', 'Saxophone-Paixiao', 'Saxophone-Saxophone', 'Saxophone-Txistu', 'Saxophone-Xalam', 'Saxophone-Xaphoon', 'Saxophone-Xun', 'Saxophone-Xylophone', 'Txistu-Box drum', 'Txistu-Paixiao', 'Txistu-Saxophone', 'Txistu-Txistu', 'Txistu-Xalam', 'Txistu-Xaphoon', 'Txistu-Xun', 'Txistu-Xylophone', 'Xalam-Box drum', 'Xalam-Paixiao', 'Xalam-Saxophone', 'Xalam-Txistu', 'Xalam-Xalam', 'Xalam-Xaphoon', 'Xalam-Xun', 'Xalam-Xylophone', 'Xaphoon-Box drum', 'Xaphoon-Paixiao', 'Xaphoon-Saxophone', 'Xaphoon-Txistu', 'Xaphoon-Xalam', 'Xaphoon-Xaphoon', 'Xaphoon-Xun', 'Xaphoon-Xylophone', 'Xun-Box drum', 'Xun-Paixiao', 'Xun-Saxophone', 'Xun-Txistu', 'Xun-Xalam', 'Xun-Xaphoon', 'Xun-Xun', 'Xun-Xylophone', 'Xylophone-Box drum', 'Xylophone-Paixiao', 'Xylophone-Saxophone', 'Xylophone-Txistu', 'Xylophone-Xalam', 'Xylophone-Xaphoon', 'Xylophone-Xun', 'Xylophone-Xylophone']\n", getMyStdOut())


  def test8(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = ['hearts', 'diamonds', 'clubs', 'spades']
    print(get_pairs(L))
    
    self.assertEqual("['hearts-hearts', 'hearts-diamonds', 'hearts-clubs', 'hearts-spades', 'diamonds-hearts', 'diamonds-diamonds', 'diamonds-clubs', 'diamonds-spades', 'clubs-hearts', 'clubs-diamonds', 'clubs-clubs', 'clubs-spades', 'spades-hearts', 'spades-diamonds', 'spades-clubs', 'spades-spades']\n", getMyStdOut())



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-print_stars_grid_nested_loop-2" label="exe-sec-HW7-PRACTICE-1-145082">
      <title>Print Grid of Asterisks with a Nested Loop</title>
      <statement>
        <p>Define a function <c>print_star_grid(rows, cols)</c>, which takes two positive integers as parameters and prints a rectangular grid of asterisks in response. <alert>rows</alert> indicates the number of rows to be printed, and <alert>cols</alert> indicates the number of columns (i.e., the length of each row).</p>
        <p>After each <c>"*"</c>, print a space (to match the examples).</p>
        <p>Hints: </p>
        <p>
          <ul>
            <li>For each r in range(rows), for each c in range(cols), print <c>"*  "</c> (a star followed by a space).</li>
            <li>To prevent going to a new line each time, include <alert>keyword argument:  </alert><alert>end =</alert><alert> ""</alert>  in  your print call.</li>
            <li>Make a call to <alert>print() with no arguments</alert> each time the inner loop finishes (to make the end of a row).</li>
          </ul>
        </p>
        <p><alert>Note</alert>: This function does NOT explicitly return a value.</p>
      </statement>
      <program interactive="activecode" language="python">
        <input>_my_out = ""
_my_in = []

def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise EOFError()
  return _my_in.pop()





^^^^

        </input>
        <tests>



from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print_star_grid(2,3)
    
    self.assertEqual('* * *\n* * *\n', getMyStdOut())


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print_star_grid(1,1)
    
    self.assertEqual('*\n', getMyStdOut())


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print_star_grid(5,5)
    
    self.assertEqual('* * * * *\n* * * * *\n* * * * *\n* * * * *\n* * * * *\n', getMyStdOut())


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print_star_grid(3,2)
    
    self.assertEqual('* *\n* *\n* *\n', getMyStdOut())


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print_star_grid(7,3)
    
    self.assertEqual('* * *\n* * *\n* * *\n* * *\n* * *\n* * *\n* * *\n', getMyStdOut())



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-print_X_O_grid_nested_loop-2" label="exe-sec-HW7-PRACTICE-1-145084">
      <title>Print X's and O's in a Grid with a Nested Loop</title>
      <statement>
        <p>Define a function <c>print_XO_grid(rows, cols)</c>, which takes two positive integers as parameters and prints a rectangular grid of X's and O's in response. rows indicates the number of rows to be printed, and cols indicates the number of columns (i.e., the length of each row).</p>
        <p>After each "X" or "O", print a space (to match the examples).</p>
        <p>Hints: </p>
        <p>
          <ul>
            <li>For each r in range(rows), for each c in range(cols), print "X " if r + c is even; otherwise, print "O ". </li>
            <li>To prevent going to a new line each time, include <alert>keyword argument:  </alert><c>end = ""</c>  in  your print call.</li>
            <li>Make a call to <alert>print() with no arguments</alert> each time the inner loop finishes (to make the end of a row).</li>
          </ul>
        </p>
        <p><alert>Note</alert>: This function does NOT explicitly return a value.</p>
      </statement>
      <program interactive="activecode" language="python">
        <input>_my_out = ""
_my_in = []

def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise EOFError()
  return _my_in.pop()





^^^^

        </input>
        <tests>



from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print_XO_grid(2,3)
    
    self.assertEqual('X O X\nO X O\n', getMyStdOut())


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print_XO_grid(3,2)
    
    self.assertEqual('X O\nO X\nX O\n', getMyStdOut())


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print_XO_grid(1, 5)
    
    self.assertEqual('X O X O X\n', getMyStdOut())


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print_XO_grid(3,1)
    
    self.assertEqual('X\nO\nX\n', getMyStdOut())


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print_XO_grid(5, 5)
    
    self.assertEqual('X O X O X\nO X O X O\nX O X O X\nO X O X O\nX O X O X\n', getMyStdOut())


  def test6(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print_XO_grid(8, 3)
    
    self.assertEqual('X O X\nO X O\nX O X\nO X O\nX O X\nO X O\nX O X\nO X O\n', getMyStdOut())



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-nested_list_sum_up_all_items-2" label="exe-sec-HW7-PRACTICE-1-144561">
      <title>Sum of Nested List Items</title>
      <statement>
        <p>Define the function <c>sum_nested(L)</c>, which takes parameter L (a list of lists of integers) and returns the sum of all the elements of all the inner lists of L.  </p>
        <p>For example, if L  = [[1, 2], [3, 3, 2], [7, -6]], then <c>sum_nested(L)</c> would return 1 + 2 + 3 + 3 + 2 + 7 + (-6) = 12.</p>
        <p>TO DO:</p>
        <p>Write a double for loop to accumulate the sum.</p>
      </statement>
      <program interactive="activecode" language="python">
        <input>_my_out = ""
_my_in = []

def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise EOFError()
  return _my_in.pop()





^^^^

        </input>
        <tests>



from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = [[5]]
    print(sum_nested(L))
    
    self.assertEqual('5\n', getMyStdOut())


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L=[[1,2],[8,7,6]]
    print(sum_nested(L))
    
    self.assertEqual('24\n', getMyStdOut())


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L =  []
    print(sum_nested(L))
    
    self.assertEqual('0\n', getMyStdOut())


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = [[5,4],[3,1,1,1,10],[2],[4]]
    print(sum_nested(L))
    
    self.assertEqual('31\n', getMyStdOut())


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = [[1],[2,3],[-3,-2,-1,0]]
    print(sum_nested(L))
    
    self.assertEqual('0\n', getMyStdOut())


  def test6(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = [[1,1,1],[2,3,2],[5,5,5],[10,11,12,13,14]]
    print(sum_nested(L))
    
    self.assertEqual('85\n', getMyStdOut())



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-gen_triples-2" label="exe-sec-HW7-PRACTICE-1-161274">
      <title>Generate Triples</title>
      <statement>
        <p>The function <alert>gen_triples</alert> function takes one parameter, a list `L` of characters. The function then returns a list of all possible 3-character strings that can be made from the characters in `L`.</p>
        <p>For example, if L = ['n', 'o'], <alert>gen_triples(L)</alert> should return the list: </p>
        <p>['nnn', 'nno', 'non',
'noo', 'onn', 'ono', 'oon', 'ooo']</p>
        <p>If `L` is empty, gen_triples should return an empty list.</p>
        <p>Note: If `L` contains <em>n</em> different characters (length-1 strings), then gen_triples(L) will return a list of length <em>n</em>&amp;lt;sup&amp;rt;3&amp;lt;/sup&amp;rt;.</p>
        <p>Hint: Use nested for loops to help you accumulate the list of triples.</p>
      </statement>
      <program interactive="activecode" language="python">
        <input>_my_out = ""
_my_in = []

def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise EOFError()
  return _my_in.pop()





^^^^

        </input>
        <tests>



from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = []
    print(gen_triples(L))
    
    self.assertEqual('[]', getMyStdOut())


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = ['R']
    print(gen_triples(L))
    
    
    self.assertEqual("['RRR']", getMyStdOut())


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = ['n', 'o']
    print(gen_triples(L))
    
    self.assertEqual("['nnn', 'nno', 'non', 'noo', 'onn', 'ono', 'oon', 'ooo']", getMyStdOut())


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = ['A', 'B', 'C']
    print(gen_triples(L))
    
    self.assertEqual("['AAA', 'AAB', 'AAC', 'ABA', 'ABB', 'ABC', 'ACA', 'ACB', 'ACC', 'BAA', 'BAB', 'BAC', 'BBA', 'BBB', 'BBC', 'BCA', 'BCB', 'BCC', 'CAA', 'CAB', 'CAC', 'CBA', 'CBB', 'CBC', 'CCA', 'CCB', 'CCC']", getMyStdOut())



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-add_entry_to_dictionary-2" label="exe-sec-HW7-PRACTICE-1-145104">
      <title>Add Entry</title>
      <statement>
        <p>The function <c>add_entry</c> takes a dictionary <c>D</c>, and two additional parameters, <c>key</c> and <c>val</c>, The function adds <c>key</c> to the dictionary, using <c>val</c> for the value of <c>key</c>.</p>
        <p><alert>Note</alert>: This function does not return anything.</p>
      </statement>
      <program interactive="activecode" language="python">
        <input>_my_out = ""
_my_in = []

def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise EOFError()
  return _my_in.pop()





^^^^

        </input>
        <tests>



from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')
    
    D = {'Hitting Percent': 0.174, 'Blocks': 5.0, 'Digs': 47, 'Aces': 7}
    add_entry(D, 'Spikes', 42)
    if D.get('Spikes') == 42:
        print("new key-value pair was correctly added")
    else:
        print("key-value pair was NOT added correctly")
    
    
    self.assertEqual('new key-value pair was correctly added', getMyStdOut())


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')
    
    D = {'wins': 9, 'losses': 2}
    add_entry(D, 'ties', 1)
    if D.get('ties') == 1:
        print("new key-value pair was correctly added")
    else:
        print("key-value pair was NOT added correctly")
    
    self.assertEqual('new key-value pair was correctly added', getMyStdOut())


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')
    
    D = {'major1 gpa': 3.7, 'major2 gpa': 3.4, 'credits': 17, 'graduation year': 2022}
    add_entry(D, 'minor', 'Counting Sheep')
    if D.get('minor') == 'Counting Sheep':
        print("new key-value pair was correctly added")
    else:
        print("key-value pair was NOT added correctly")
    
    self.assertEqual('new key-value pair was correctly added', getMyStdOut())


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')
    
    D = {}
    for i in range(65,89):
        D[chr(i)] = i
    add_entry(D, 'Z', 90)
    if D.get('Z') == 90:
        print("new key-value pair was correctly added")
    else:
        print("key-value pair was NOT added correctly")
    
    self.assertEqual('new key-value pair was correctly added', getMyStdOut())


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')
    
    student_ages = {('Steph','Martin'): 4, ('Bobby', 'Roo'): 5, ('Tiffany', 'Roo'): 5,
                   ('Alex', 'Oriole'): 6, ('Sandy', 'Singh'): 4, ('Ida', 'North-West'): 6,
                   ('Mihrimah', 'Suleiman'): 5, ('Kat', 'Mouse'): 4}
    student = ('Felix', 'Dumezweni')
    add_entry(student_ages, student, 6)
    if student_ages.get(student) == 6:
        print("new key-value pair was correctly added")
    else:
        print("key-value pair was NOT added correctly")
    
    
    self.assertEqual('new key-value pair was correctly added', getMyStdOut())



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-delete_entry_from_dictionary-2" label="exe-sec-HW7-PRACTICE-1-145152">
      <title>Delete Entry</title>
      <statement>
        <p>The function <c>delete_entry</c> takes a parameter <c>D</c> (a dictionary) and a parameter <c>k</c> (a supposed key in <c>D</c>).  </p>
        <p>
          <ul>
            <li>The function <alert>removes </alert>the entry whose key is <c>k</c> and returns the value that was associated with <c>k</c>.</li>
            <li><em>However</em>, if <c>k</c> is <alert>not </alert>a key in <c>D</c>, the function leaves <c>D</c> unchanged and returns the value <c>None</c>.</li>
          </ul>
        </p>
        <p>Hint: <c>D.pop(k)</c> is helpful here, but first you need to handle the case where k is <alert>not</alert> a key in D. You can search online to learn more, using search string:   <em>python dictionary delete item</em></p>
      </statement>
      <program interactive="activecode" language="python">
        <input>_my_out = ""
_my_in = []

def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise EOFError()
  return _my_in.pop()





^^^^

        </input>
        <tests>



from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')
    
    D = {'Hitting Percent': 0.174, 'Blocks': 5.0, 'Digs': 47, 'Aces': 7}
    ans = delete_entry(D, 'Digs')
    print(ans)
    
    
    
    self.assertEqual('47\n', getMyStdOut())


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')
    
    D = {'wins': 9, 'losses': 2}
    ans = delete_entry(D, 'ties')
    print(ans)
    
    self.assertEqual('None\n', getMyStdOut())


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')
    
    D = {'major1 gpa': 3.7, 'major2 gpa': 3.4, 'credits': 17, 'graduation year': 2022}
    ans = delete_entry(D, 'major2 gpa')
    print(ans)
    
    
    self.assertEqual('3.4\n', getMyStdOut())


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')
    
    D = {}
    for i in range(10): D[i] = i*i - 1
    ans = delete_entry(D, 12)
    print(ans)
    
    
    
    self.assertEqual('None\n', getMyStdOut())


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')
    
    student_ages = {('Steph','Martin'): 4, ('Bobby', 'Roo'): 5, ('Tiffany', 'Roo'): 5,
                   ('Alex', 'Oriole'): 6, ('Sandy', 'Singh'): 4, ('Ida', 'North-West'): 6,
                   ('Mihrimah', 'Suleiman'): 5, ('Kat', 'Mouse'): 4}
    student = ('Steph', 'Martin')
    ans = delete_entry(student_ages, student)
    print(ans)
    
    
    
    self.assertEqual('4\n', getMyStdOut())


  def test6(self):
    resetMyStdOut()
    setMyStdIn('')
    
    student_ages = {('Steph','Martin'): 4, ('Bobby', 'Roo'): 5, ('Tiffany', 'Roo'): 5,
                   ('Alex', 'Oriole'): 6, ('Sandy', 'Singh'): 4, ('Ida', 'North-West'): 6,
                   ('Mihrimah', 'Suleiman'): 5, ('Kat', 'Mouse'): 4}
    student = ('Abe', 'Lincoln')
    ans = delete_entry(student_ages, student)
    print(ans)
    
    
    self.assertEqual('None\n', getMyStdOut())



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-dictionary_has_key-2" label="exe-sec-HW7-PRACTICE-1-145107">
      <title>Has Key</title>
      <statement>
        <p>The function <c>has_key</c> takes two parameters: <c>D</c> and <c>k</c>, where <c>D</c> is a dictionary and <c>k</c> is a possible key in <c>D</c>. The function returns <c>True</c> if <c>k</c> is a <em>key</em> in the dictionary <c>D</c> and <c>False</c> otherwise.</p>
        <p><alert>Hint: </alert>Look up and read about the various operators and methods for dictionaries.</p>
      </statement>
      <program interactive="activecode" language="python">
        <input>_my_out = ""
_my_in = []

def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise EOFError()
  return _my_in.pop()





^^^^

        </input>
        <tests>



from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')
    
    D = {'Hitting Percent': 0.174, 'Blocks': 5.0, 'Digs': 47, 'Aces': 7}
    print(has_key(D, 'Blocks') == True)
    
    
    self.assertEqual('True', getMyStdOut())


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')
    
    D = {'Hitting Percent': 0.174, 'Blocks': 5.0, 'Digs': 47, 'Aces': 7}
    print(has_key(D, 'Spikes'))
    
    
    self.assertEqual('False', getMyStdOut())


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')
    
    D = {'major1 gpa': 3.7, 'major2 gpa': 3.4, 'credits': 17, 'graduation year': 2022}
    print(has_key(D, 'credits'))
    
    self.assertEqual('True', getMyStdOut())


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')
    
    D = {'major1 gpa': 3.7, 'major2 gpa': 3.4, 'credits': 17, 'graduation year': 2022}
    print(has_key(D, 'gpa'))
    
    self.assertEqual('False', getMyStdOut())


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')
    
    student_ages = {('Steph','Martin'): 4, ('Bobby', 'Roo'): 5, ('Tiffany', 'Roo'): 5,
                   ('Alex', 'Oriole'): 6, ('Sandy', 'Singh'): 4, ('Ida', 'North-West'): 6,
                   ('Mihrimah', 'Suleiman'): 5, ('Kat', 'Mouse'): 4, ('Felix', 'Dumezweni'): 6}
    student = ('Bobby', 'Roo')
    print(has_key(student_ages, student))
    
    
    self.assertEqual('True', getMyStdOut())


  def test6(self):
    resetMyStdOut()
    setMyStdIn('')
    
    student_ages = {('Steph','Martin'): 4, ('Bobby', 'Roo'): 5, ('Tiffany', 'Roo'): 5,
                   ('Alex', 'Oriole'): 6, ('Sandy', 'Singh'): 4, ('Ida', 'North-West'): 6,
                   ('Mihrimah', 'Suleiman'): 5, ('Kat', 'Mouse'): 4, ('Felix', 'Dumezweni'): 6}
    student = ('Bobby', 'Nguyen')
    print(has_key(student_ages, student))
    
    self.assertEqual('False', getMyStdOut())



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-dictionary_has_value-2" label="exe-sec-HW7-PRACTICE-1-145140">
      <title>Has Value</title>
      <statement>
        <p>The function <c>has_value</c> takes two parameters: a dictionary <c>D</c> and a number <c>num</c>. The function returns <c>True</c> if <c>num</c> is a <em>value</em> in dictionary <c>D</c>; otherwise, it returns <c>False</c>.</p>
        <p><alert>Hint: </alert>Reminder yourself about the various operators and methods for dictionaries.</p>
      </statement>
      <program interactive="activecode" language="python">
        <input>_my_out = ""
_my_in = []

def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise EOFError()
  return _my_in.pop()





^^^^

        </input>
        <tests>



from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')
    
    D = {'Hitting Percent': 0.174, 'Blocks': 5.0, 'Digs': 47, 'Aces': 7}
    print(has_value(D, 47) == True)
    
    
    self.assertEqual('True', getMyStdOut())


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')
    
    D = {'Hitting Percent': 0.174, 'Blocks': 5.0, 'Digs': 47, 'Aces': 7}
    print(has_value(D, 3047) == True)
    
    
    self.assertEqual('False', getMyStdOut())


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')
    
    D = {'major1 gpa': 3.7, 'major2 gpa': 3.4, 'credits': 17, 'graduation year': 2022}
    print(has_value(D, 2022) == True)
    
    self.assertEqual('True', getMyStdOut())


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')
    
    D = {'major1 gpa': 3.7, 'major2 gpa': 3.4, 'credits': 17, 'graduation year': 2022}
    print(has_value(D, 2020) == True)
    
    self.assertEqual('False', getMyStdOut())


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')
    
    D = {'major1 gpa': 3.7, 'major2 gpa': 3.4, 'credits': 17, 'graduation year': 2022}
    print(has_value(D, 3.7) == True)
    
    self.assertEqual('True', getMyStdOut())



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-dictionary_num_pairs-2" label="exe-sec-HW7-PRACTICE-1-145129">
      <title>Get Num Entries</title>
      <statement>
        <p>The function <c>get_num_pairs</c> takes one parameter, <c>D</c>, which is a dictionary. The function returns the <alert>number </alert>of key-value pairs in <c>D</c>.</p>
      </statement>
      <program interactive="activecode" language="python">
        <input>_my_out = ""
_my_in = []

def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise EOFError()
  return _my_in.pop()





^^^^

        </input>
        <tests>



from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')
    
    D = {'Hitting Percent': 0.174, 'Blocks': 5.0, 'Digs': 47, 'Aces': 7}
    print(get_num_pairs(D))
    
    
    self.assertEqual('4', getMyStdOut())


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')
    
    D = {'wins': 9, 'losses': 2}
    print(get_num_pairs(D))
    
    
    
    self.assertEqual('2', getMyStdOut())


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')
    
    D = {'gpa': 3.7, 'credits': 17, 'graduation year': 2022}
    print(get_num_pairs(D))
    
    self.assertEqual('3', getMyStdOut())


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')
    
    D = {}
    for i in range(50,101):
        D[chr(i)] = i
    print(get_num_pairs(D))
    
    self.assertEqual('51', getMyStdOut())


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')
    
    student_ages = {('Steph','Martin'): 4, ('Bobby', 'Roo'): 5, ('Tiffany', 'Roo'): 5,
                   ('Alex', 'Oriole'): 6, ('Sandy', 'Singh'): 4, ('Ida', 'North-West'): 6,
                   ('Mihrimah', 'Suleiman'): 5, ('Kat', 'Mouse'): 4, ('Felix', 'Dumezweni'): 6}
    print(get_num_pairs(student_ages))
    
    
    self.assertEqual('9', getMyStdOut())


  def test6(self):
    resetMyStdOut()
    setMyStdIn('')
    
    D = {}
    print(get_num_pairs(D))
    
    self.assertEqual('0', getMyStdOut())



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-build_dictionary-2" label="exe-sec-HW7-PRACTICE-1-161275">
      <title>Build Dictionary</title>
      <statement>
        <p>The function <alert>build_dictionary</alert> takes two parameters, `key_list` and `value_list`.  Both lists have the same length. The two lists are organized such that each item in `key_list` can be matched up with the item at the corresponding index in `value_list` to form a key-value pair for a dictionary. Write the function so that it creates a new dictionary using `key_list` and `value_list`. The new dictionary should be returned by the function.</p>
      </statement>
      <program interactive="activecode" language="python">
        <input>_my_out = ""
_my_in = []

def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise EOFError()
  return _my_in.pop()





^^^^

        </input>
        <tests>



from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')
    
    key_list = ['Hitting Percent', 'Blocks', 'Digs', 'Aces']
    value_list = [0.174, 5.0, 47, 7]
    new_D = build_dictionary(key_list, value_list)
    if (new_D == {'Hitting Percent': 0.174, 'Blocks': 5.0, 'Digs': 47, 'Aces': 7}):
        print("new_D created correctly")
    else:
        print("new_D NOT correct; here's what it currently looks like")
        print(new_D)
    
    
    self.assertEqual('new_D created correctly', getMyStdOut())


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')
    
    key_list = ['wins', 'losses']
    value_list = [9, 2]
    new_D = build_dictionary(key_list, value_list)
    if (new_D == {'wins': 9, 'losses': 2}):
        print("new_D created correctly")
    else:
        print("new_D NOT correct; here's what it currently looks like")
        print(new_D)
    
    self.assertEqual('new_D created correctly', getMyStdOut())


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')
    
    key_list = ['major1 gpa', 'major2 gpa', 'credits', 'graduation year']
    value_list = [3.7, 3.4, 17, 2022]
    new_D = build_dictionary(key_list, value_list)
    if (new_D == {'major1 gpa': 3.7, 'major2 gpa': 3.4, 'credits': 17, 'graduation year': 2022}):
        print("new_D created correctly")
    else:
        print("new_D NOT correct; here's what it currently looks like")
        print(new_D)
    
    self.assertEqual('new_D created correctly', getMyStdOut())


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')
    
    key_list = ['First Years', 'Sophomores', 'Juniors', 'Seniors']
    value_list = [135, 114, 109, 105]
    new_D = build_dictionary(key_list, value_list)
    if (new_D == {'First Years': 135, 'Sophomores': 114, 'Juniors': 109, 'Seniors': 105}):
        print("new_D created correctly")
    else:
        print("new_D NOT correct; here's what it currently looks like")
        print(new_D)
    
    self.assertEqual('new_D created correctly', getMyStdOut())


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')
    
    key_list = [('Steph','Martin'), ('Bobby', 'Roo'), ('Alex', 'Oriole'), ('Mihrimah', 'Suleiman'), ('Felix', 'Dumezweni')]
    value_list = [4, 5, 6, 5, 6]
    new_D = build_dictionary(key_list, value_list)
    if (new_D == {('Steph','Martin'): 4, ('Bobby', 'Roo'): 5, ('Alex', 'Oriole'): 6, ('Mihrimah', 'Suleiman'): 5, ('Felix', 'Dumezweni'): 6}):
        print("new_D created correctly")
    else:
        print("new_D NOT correct; here's what it currently looks like")
        print(new_D)
    
    
    self.assertEqual('new_D created correctly', getMyStdOut())



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-find_frequencies_dictionary_of_list-2" label="exe-sec-HW7-PRACTICE-1-144954">
      <title>Accumulate Frequencies Dictionary</title>
      <statement>
        <p>The function <c>get_freq_dict(L)</c> takes a list of integers and <alert>returns </alert>a dictionary D such that for each number x in L, D[x] is the frequency of x in L.</p>
        <p>TO DO: Accumulate D as explained in your textbook. Read up on how to generate a frequency table using a dictionary if the following hint leaves you puzzled.</p>
        <p>Hint: Use the accumulator pattern.</p>
        <p>
          <ol>
            <li>Initialize D to be an empty dictionary:    <c>D  = {}</c></li>
            <li>
              <p>
                For each x in L:
                <ul>
                  <li>if x is already a key in D, update the frequency  of x:   <c>D[x] = D[x] + 1</c></li>
                  <li>else, make x:1 a new pair in D</li>
                </ul>
              </p>
            </li>
            <li>When the loop has finished, return D.</li>
          </ol>
        </p>
      </statement>
      <program interactive="activecode" language="python">
        <input>_my_out = ""
_my_in = []

def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise EOFError()
  return _my_in.pop()





^^^^

        </input>
        <tests>



from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = [1, 5, 25, 5, 1]
    print(get_freq_dict(L))
    
    self.assertEqual('{1: 2, 5: 2, 25: 1}\n', getMyStdOut())


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = [5, 5, 5, 5, 5, 3]
    print(get_freq_dict(L))
    
    self.assertEqual('{5: 5, 3: 1}\n', getMyStdOut())


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = [17]
    print(get_freq_dict(L))
    
    self.assertEqual('{17: 1}\n', getMyStdOut())


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = list(range(5))
    print(get_freq_dict(L))
    
    self.assertEqual('{0: 1, 1: 1, 2: 1, 3: 1, 4: 1}\n', getMyStdOut())


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = list(range(3))*2 + [3, 4]
    print(get_freq_dict(L))
    
    self.assertEqual('{0: 2, 1: 2, 2: 2, 3: 1, 4: 1}\n', getMyStdOut())


  def test6(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = [1, 1, 1, 1, 2, 2, 2, 3, 3, 4]
    print(get_freq_dict(L))
    
    self.assertEqual('{1: 4, 2: 3, 3: 2, 4: 1}\n', getMyStdOut())


  def test7(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(get_freq_dict([]))
    
    self.assertEqual('{}\n', getMyStdOut())


  def test8(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = list(range(3))*3 + [1, 2] + [7, 8, 8]
    print(get_freq_dict(L))
    
    self.assertEqual('{0: 3, 1: 4, 2: 4, 7: 1, 8: 2}\n', getMyStdOut())



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-dict_find_mode_of_list-2" label="exe-sec-HW7-PRACTICE-1-145015">
      <title>Calculate Mode of List (using a dictionary)</title>
      <statement>
        <p>The function <c>get_</c><c>mode(L)</c> takes one parameter, <alert>L</alert>, a list of integers. <c>get_mode</c> builds a dictionary of frequencies to determine how often each number in the list occurs. Then it returns the <em>mode</em> of the list, that is, the number in L which occurs with the highest frequency.</p>
        <p>For example, <c>get_mode([3, 8, 5, 5, 8, 8])</c> would determine that</p>
        <p>
          <ul>
            <li>3 has frequency 1</li>
            <li>8 has frequency 3</li>
            <li>5 has frequency 2</li>
          </ul>
        </p>
        <p>Because  8 has the highest frequency, <alert>get_mode</alert> would return 8  for this example.</p>
        <p>Note: You may assume that L will not be empty and there will be a single mode in L (no ties for most frequent).</p>
        <p>Tip: Suppose D is a dictionary with integer values. The following code will determine the maximum value in D: <c>max_value = max(D.values())</c></p>
      </statement>
      <program interactive="activecode" language="python">
        <input>_my_out = ""
_my_in = []

def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise EOFError()
  return _my_in.pop()





^^^^

        </input>
        <tests>



from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = [3, 8, 5, 5, 8, 8]
    print(get_mode(L))
    
    self.assertEqual('8\n', getMyStdOut())


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = [3, 8, 5, 5, 8, 8, 3, 3, 5, 3, 3]
    print(get_mode(L))
    
    self.assertEqual('3\n', getMyStdOut())


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = [-5, 10, -4, 10, -3]
    print(get_mode(L))
    
    self.assertEqual('10', getMyStdOut())


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = [-5]
    print(get_mode(L))
    
    self.assertEqual('-5\n', getMyStdOut())


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = [4, 3, 4]
    print(get_mode(L))
    
    self.assertEqual('4\n', getMyStdOut())


  def test6(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = list(range(20))+[17,17]+list(range(20))
    print(get_mode(L))
    
    self.assertEqual('17\n', getMyStdOut())



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-Counting-by-k-2" label="exe-sec-HW7-PRACTICE-1-160712">
      <title>Counting by k</title>
      <statement>
        <p>Write a 6-line Python script (not a function definition). The purpose of the program is to read a positive integer n from standard input and then show how to "count by k" for k = 0, 1, 2, ..., n. </p>
        <p>Hint: Use a nested for loop.</p>
      </statement>
      <program interactive="activecode" language="python">
        <input>_my_out = ""
_my_in = []

def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise EOFError()
  return _my_in.pop()




_program = """


^^^^

        </input>
        <tests>

"""



from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('3\n')
    
    exec(_program)
    
    self.assertEqual('Counting by: 0\n0 0 0 0 0 0 0 \nCounting by: 1\n0 1 2 3 4 5 6 \nCounting by: 2\n0 2 4 6 8 10 12 \nCounting by: 3\n0 3 6 9 12 15 18 \n', getMyStdOut())


  def test2(self):
    resetMyStdOut()
    setMyStdIn('4')
    
    exec(_program)
    
    self.assertEqual('Counting by: 0\n0 0 0 0 0 0 0 \nCounting by: 1\n0 1 2 3 4 5 6 \nCounting by: 2\n0 2 4 6 8 10 12 \nCounting by: 3\n0 3 6 9 12 15 18 \nCounting by: 4\n0 4 8 12 16 20 24 ', getMyStdOut())


  def test3(self):
    resetMyStdOut()
    setMyStdIn('5\n')
    
    exec(_program)
    
    self.assertEqual('Counting by: 0\n0 0 0 0 0 0 0 \nCounting by: 1\n0 1 2 3 4 5 6 \nCounting by: 2\n0 2 4 6 8 10 12 \nCounting by: 3\n0 3 6 9 12 15 18 \nCounting by: 4\n0 4 8 12 16 20 24 \nCounting by: 5\n0 5 10 15 20 25 30 \n', getMyStdOut())



myTests().main()        </tests>
      </program>
    </exercise>
  </exercises>
</section>