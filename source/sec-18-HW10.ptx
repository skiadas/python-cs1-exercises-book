<section xml:id="sec-HW10-1">
  <title>HW10</title>
  <introduction>
    <p dir="ltr">Creating classes</p>
  </introduction>
  <exercises>
    <exercise xml:id="exer-defining_classes_intro-1" label="exe-sec-HW10-1-271604">
      <title>Defining Classes</title>
      <statement correct="yes">
        <p>Previously, you have used built-in types in Python like <c>dict</c>, <c>str</c>, and <c>list</c>. Each of these types comes with its own methods, such as <c>keys</c>, <c>lower</c>, and <c>append</c>.</p>
        <p>Every object has a <alert>type</alert>that indicates which class the object belongs to. The purpose of the class definition is to specify the instance variables (aka data, attributes) and methods (aka functions) that each object belonging to the class will have.</p>
        <p>For example, in real life, every <alert>car</alert>has attributes such as make, model, and current odometer. And every reasonable car has available methods such as start engine, shift transmission, and honk horn.</p>
        <p>Our goal in this assignment is to learn how to <em>create new data types</em> by defining our own classes.</p>
      </statement>
    </exercise>
    <exercise xml:id="exer-pogil_1a_classname-1" label="exe-sec-HW10-1-271605">
      <statement>
        <p>What is the <alert>name</alert>of the class being defined here:</p>
        <pre>
# sentenceclass.py

class Sentence:
    def __init__(self, chars):
        # store the chars in an instance variable
        self.chars = chars

    def getChars(self):
        return self.chars

    def setChars(self, newChars):
        self.chars = newChars
        </pre>
        <fillin answer="Sentence" width="16" />
      </statement>
      <evaluation>
        <evaluate>
          <test correct="yes">
            <strcmp>Sentence</strcmp>
            <feedback />
          </test>
          <test>
            <strcmp>sentence</strcmp>
            <feedback>
              <p>Spell it exactly right, including capitalization.</p>
            </feedback>
          </test>
        </evaluate>
      </evaluation>
    </exercise>
    <exercise xml:id="exer-pogil_1b_methods-1" label="exe-sec-HW10-1-271606">
      <statement>
        <p>How many <alert>methods</alert>are in the class being defined here:</p>
        <pre>
# sentenceclass.py

class Sentence:
    def __init__(self, chars):
        # store the chars in an instance variable
        self.chars = chars

    def getChars(self):
        return self.chars

    def setChars(self, newChars):
        self.chars = newChars
        </pre>
        <fillin answer="3.0" width="16" />
      </statement>
      <evaluation>
        <evaluate>
          <test correct="yes">
            <numcmp tolerance="0.0" value="3.0" />
            <feedback>
              <p>Correct! The three methods are <alert>__init__, getChars, setChars</alert>.</p>
            </feedback>
          </test>
        </evaluate>
      </evaluation>
    </exercise>
    <exercise xml:id="exer-pogil_1c_self-1" label="exe-sec-HW10-1-271608">
      <statement>
        <p>Here is a <c>Length</c> class definition. What is the <alert>name of the first parameter</alert> in all the instance method definitions for a Python class?</p>
        <pre>
class Length:
    def __init__(self, quantity, unit):
        # A Length object has a quantity (numerical) and a unit label (string).
        # The unit will be one of these: 'inches', 'yards'
        self.quantity = quantity
        self.unit = unit

    def has_unit(self, some_unit):
        # return True if the Length object's unit label is
        # the same as some_unit, otherwise False
        return self.unit == some_unit

    def convert_to(self, new_unit):
        # convert this Length object to the new unit
        if self.has_unit('inches') and new_unit == 'yards':
            self.quantity = self.quantity / 36
            self.unit = new_unit
        elif self.has_unit('yards') and new_unit == 'inches':
            self.quantity = self.quantity * 36
            self.unit = new_unit

    def __str__(self):
        # return a string for printing the Length object information
        rounded_quantity = round(self.quantity, 3)
        return f'{rounded_quantity} {self.unit}'
        </pre>
        <fillin answer="self" width="16" />
      </statement>
      <evaluation>
        <evaluate>
          <test correct="yes">
            <strcmp>self</strcmp>
            <feedback>
              <p>Correct. The first parameter, <c>self</c>, refers to the Length object which activated the method.</p>
            </feedback>
          </test>
          <test>
            <strcmp>Self</strcmp>
            <feedback>
              <p>Spell it exactly right, including capitalization.</p>
            </feedback>
          </test>
        </evaluate>
      </evaluation>
    </exercise>
    <exercise xml:id="exer-pogil_2a_main_num_objects-1" label="exe-sec-HW10-1-271610">
      <statement>
        <p>In the code block below, how many different <c>Sentence</c>objects are created by activating the class constructor?</p>
        <pre>
if __name__ == "__main__":
    greeting = Sentence("Hi")
    question = Sentence("How are you doing today?")
    mystr = question.getChars()
    name = Sentence("My name is Tina")
    name.setChars("My name is Tony")
    another = Sentence("Did you see 'Turning Red'?")
        </pre>
        <fillin answer="4.0" width="16" />
      </statement>
      <evaluation>
        <evaluate>
          <test correct="yes">
            <numcmp tolerance="0.0" value="4.0" />
            <feedback>
              <p>Correct! The four Sentence objects are<alert>greeting, question, name, and another.</alert></p>
            </feedback>
          </test>
        </evaluate>
      </evaluation>
    </exercise>
    <exercise xml:id="exer-pogil_2d_method_parameters-1" label="exe-sec-HW10-1-271611">
      <statement>
        <p><alert>How many parameters</alert> does the <c>convert_to</c> method have?</p>
        <pre>
def convert_to(self, new_unit):
    # convert this Length object to the new unit
    if self.has_unit('inches') and new_unit == 'yards':
        self.quantity = self.quantity / 36
        self.unit = new_unit
    elif self.has_unit('yards') and new_unit == 'inches':
        self.quantity = self.quantity * 36
        self.unit = new_unit
        </pre>
        <fillin answer="2.0" width="16" />
      </statement>
      <evaluation>
        <evaluate>
          <test correct="yes">
            <numcmp tolerance="0.0" value="2.0" />
            <feedback>
              <p>Correct! The two parameters are <c>self</c>and <c>new_unit</c>.</p>
            </feedback>
          </test>
        </evaluate>
      </evaluation>
    </exercise>
    <exercise xml:id="exer-pogil_2e_method_call_arguments-1" label="exe-sec-HW10-1-271612">
      <statement>
        <p>Notice that the <c>convert_to</c> method is called twice in the code block below. What is the number of <alert>arguments</alert> for a <c>convert_to</c> method call?
        <cd>if __name__ == "__main__":
    football_field = Length(100, 'yards')
    print("Length of a football field:", football_field)
    football_field.convert_to("inches")
    print("Length of a football field:", football_field)

    rattler = Length(38, "inches")
    print("Length of a female black-tailed rattler:", rattler)
    rattler.convert_to("yards")
    print("Length of a female black-tailed rattler:", rattler)
    </cd></p>
    <p><fillin answer="1.0" width="16" />
    </p>
      </statement>
      <evaluation>
        <evaluate>
          <test correct="yes">
            <numcmp tolerance="0.0" value="1.0" />
            <feedback>
              <p>Correct! When we call convert_to on a Length object, we provide one argument, the new_unit.</p>
            </feedback>
          </test>
        </evaluate>
      </evaluation>
    </exercise>
    <exercise xml:id="exer-pogil_2f_arguments_vs_parameters-1" label="exe-sec-HW10-1-32326">
      <statement>
        <p>Based on your previous answers, how does the number of arguments for each method <em>call</em><alert>differ from</alert> the number of parameters specified in the method's <em>definition</em>?</p>
      </statement>
      <choices multiple-correct="no" randomize="yes">
        <choice correct="yes">
          <statement>
            <p>
              <p>There is one less argument.</p>
            </p>
          </statement>
          <feedback>
            <p>Yes! We do not provide an argument for the "self" parameter.</p>
          </feedback>
        </choice>
        <choice correct="no">
          <statement>
            <p>
              <p>There is no difference.</p>
            </p>
          </statement>
          <feedback>
            <p>Review your answers to the previous two questions.</p>
          </feedback>
        </choice>
        <choice correct="no">
          <statement>
            <p>
              <p>There is one less parameter.</p>
            </p>
          </statement>
          <feedback>
            <p>Review your answers to the previous two questions.</p>
          </feedback>
        </choice>
      </choices>
    </exercise>
    <exercise xml:id="exer-timer_class-multi1-1" label="exe-sec-HW10-1-271613">
      <title>Initializing New Instances of the Class</title>
      <statement>
        <p>Consider the following class definition.</p>
        <pre>  class Timer:
      """ A class that represents a timer. """
      def __init__(self):
          self.hours = 0
          self.minutes = 0
          self.seconds = 0

      def print_with_labels(self):
          print('Hours:', self.hours, end=' ')
          print('Minutes:', self.minutes, end=' ')
          print('Seconds:', self.seconds)

      def __str__(self):
          return f'{self.hours}:{self.minutes}:{self.seconds}'
        </pre>
        <p>Which of these methods is responsible for initializing the instance variables (attributes) of a new instance?</p>
      </statement>
      <choices multiple-correct="no" randomize="yes">
        <choice correct="yes">
          <statement>
            <p>
              <p><c>__init__</c></p>
            </p>
          </statement>
          <feedback />
        </choice>
        <choice correct="no">
          <statement>
            <p>
              <p><c>__str__</c></p>
            </p>
          </statement>
          <feedback />
        </choice>
        <choice correct="no">
          <statement>
            <p>
              <p><c>print_with_labels</c></p>
            </p>
          </statement>
          <feedback />
        </choice>
      </choices>
    </exercise>
    <exercise xml:id="exer-timer_class-multi2-1" label="exe-sec-HW10-1-271614">
      <title>Creating Objects</title>
      <statement>
        <p>Consider the following class definition.</p>
        <pre>  class Timer:
      """ A class that represents a timer. """
      def __init__(self):
          self.hours = 0
          self.minutes = 0
          self.seconds = 0

      def print_with_labels(self):
          print('Hours:', self.hours, end=' ')
          print('Minutes:', self.minutes, end=' ')
          print('Seconds:', self.seconds)

      def __str__(self):
          return f'{self.hours}:{self.minutes}:{self.seconds}'
        </pre>
        <p>Which of the following lines of code will create a new Timer object set to 0 seconds, 0 minutes, and 0 hours, and assign it to the variable <c>timer1</c>?</p>
      </statement>
      <choices multiple-correct="no" randomize="yes">
        <choice correct="yes">
          <statement>
            <p>
              <p><c>timer1 = Timer()</c></p>
            </p>
          </statement>
          <feedback />
        </choice>
        <choice correct="no">
          <statement>
            <p>
              <p><c>timer1 = Timer(0, 0, 0)</c></p>
            </p>
          </statement>
          <feedback />
        </choice>
        <choice correct="no">
          <statement>
            <p>
              <p><c>timer1.__init__(self)</c></p>
            </p>
          </statement>
          <feedback />
        </choice>
        <choice correct="no">
          <statement>
            <p>
              <p><c>timer1.Timer()</c></p>
            </p>
          </statement>
          <feedback />
        </choice>
        <choice correct="no">
          <statement>
            <p>
              <p><c>timer1.Timer(0, 0, 0)</c></p>
            </p>
          </statement>
          <feedback />
        </choice>
        <choice correct="no">
          <statement>
            <p>
              <p><c>timer1.__init__()</c></p>
            </p>
          </statement>
          <feedback />
        </choice>
      </choices>
    </exercise>
    <exercise xml:id="exer-timer_class-multi4-1" label="exe-sec-HW10-1-271615">
      <title>Calling Methods 1</title>
      <statement>
        <p>Consider the following class definition.</p>
        <pre>  class Timer:
      """ A class that represents a timer. """
      def __init__(self):
          self.hours = 0
          self.minutes = 0
          self.seconds = 0

      def print_with_labels(self):
          print('Hours:', self.hours, end=' ')
          print('Minutes:', self.minutes, end=' ')
          print('Seconds:', self.seconds)

      def __str__(self):
          return f'{self.hours}:{self.minutes}:{self.seconds}'
        </pre>
        <p><alert>Recall:</alert> The <c>__str__</c>method returns the string representation of the object. This method is activated (automatically!) whenever <c>print()</c> or <alert><c>str()</c></alert> is invoked on an object. (Like all the other methods whose names are surrounded by double underscores (<c>__</c>), we never call <c>__str__</c> directly.  It is there, waiting to "answer the call" when we ask to <c>print</c> an object or use <c>str()</c>to convert an object to a string.)</p>
        <p><alert>Question:</alert> What output will be produced when the following lines of code are executed?</p>
        <pre>    t2 = Timer()
    t2.minutes = 7
    t2.seconds = 15
    print(t2)
        </pre>
      </statement>
      <choices multiple-correct="no" randomize="yes">
        <choice correct="yes">
          <statement>
            <p>
              <p><c>0:7:15</c></p>
            </p>
          </statement>
          <feedback />
        </choice>
        <choice correct="no">
          <statement>
            <p>
              <p><c>0 7 15</c></p>
            </p>
          </statement>
          <feedback />
        </choice>
        <choice correct="no">
          <statement>
            <p>
              <p><c>Hours: 0 Minutes: 7 Seconds: 15</c></p>
            </p>
          </statement>
          <feedback />
        </choice>
        <choice correct="no">
          <statement>
            <p>
              <p><alert><c>Hours: 15 Minutes: 7 Seconds: 0</c></alert></p>
            </p>
          </statement>
          <feedback />
        </choice>
        <choice correct="no">
          <statement>
            <p>
              <p><c>15:7:0</c></p>
            </p>
          </statement>
          <feedback />
        </choice>
        <choice correct="no">
          <statement>
            <p>
              <p><c>15  7  0</c></p>
            </p>
          </statement>
          <feedback />
        </choice>
      </choices>
    </exercise>
    <exercise xml:id="exer-timer_class-multi3-1" label="exe-sec-HW10-1-271616">
      <title>Setting Attributes</title>
      <statement>
        <p>Consider the following class definition.</p>
        <pre>  class Timer:
      """ A class that represents a timer. """
      def __init__(self):
          self.hours = 0
          self.minutes = 0
          self.seconds = 0

      def set_hours(self, h):
          self.hours = h

      def set_minutes(self, m):
          self.minutes = m

      def set_seconds(self, s):
          self.seconds = s

      def print_with_labels(self):
          print('Hours:', self.hours, end=' ')
          print('Minutes:', self.minutes, end=' ')
          print('Seconds:', self.seconds)

      def __str__(self):
          return f'{self.hours}:{self.minutes}:{self.seconds}'        </pre>
        <p>What output will be produced when the following lines of code are executed?</p>
        <pre>      t1 = Timer()
      t1.set_hours(7)
      print(t1)
        </pre>
      </statement>
      <choices multiple-correct="no" randomize="yes">
        <choice correct="yes">
          <statement>
            <p>
              <p><c>7:0:0</c></p>
            </p>
          </statement>
          <feedback />
        </choice>
        <choice correct="no">
          <statement>
            <p>
              <p><c>7  0 0</c></p>
            </p>
          </statement>
          <feedback />
        </choice>
        <choice correct="no">
          <statement>
            <p>
              <p><c>0:0:7</c></p>
            </p>
          </statement>
          <feedback />
        </choice>
        <choice correct="no">
          <statement>
            <p><c>0 0 7</c></p>
          </statement>
          <feedback />
        </choice>
      </choices>
    </exercise>
    <exercise xml:id="exer-timer_class-multi5-1" label="exe-sec-HW10-1-271617">
      <title>Calling Methods 2</title>
      <statement>
        <p>Consider the following class definition.</p>
        <pre>  class Timer:
      """ A class that represents a timer. """
      def __init__(self):
          self.hours = 0
          self.minutes = 0
          self.seconds = 0

      def set_hours(self, h):
          self.hours = h

      def set_minutes(self, m):
          self.minutes = m

      def set_seconds(self, s):
          self.seconds = s

      def print_with_labels(self):
          print('Hours:', self.hours, end=' ')
          print('Minutes:', self.minutes, end=' ')
          print('Seconds:', self.seconds)

      def __str__(self):
          return f'{self.hours}:{self.minutes}:{self.seconds}'        </pre>
        <p>What output will be produced when the following lines of code are executed?</p>
        <pre>    t2 = Timer()
    t2.set_hours(14)
    t2.set_minutes(55)
    t2.set_minutes(27)
    t2.print_with_labels()
        </pre>
      </statement>
      <choices multiple-correct="no" randomize="yes">
        <choice correct="no">
          <statement>
            <p>
              <p><c>14:27:0</c></p>
            </p>
          </statement>
          <feedback />
        </choice>
        <choice correct="no">
          <statement>
            <p>
              <p><c>14:55:27</c></p>
            </p>
          </statement>
          <feedback />
        </choice>
        <choice correct="yes">
          <statement>
            <p>
              <p><c>Hours: 14 Minutes: 27 Seconds: 0</c></p>
            </p>
          </statement>
          <feedback />
        </choice>
        <choice correct="no">
          <statement>
            <p>
              <p><c>Hours: 14 Minutes: 55 Seconds: 27</c></p>
            </p>
          </statement>
          <feedback />
        </choice>
        <choice correct="no">
          <statement>
            <p>
              <p><c>Hours: 15 Minutes: 22 Seconds: 0</c></p>
            </p>
          </statement>
          <feedback />
        </choice>
        <choice correct="no">
          <statement>
            <p>
              <p><c>15:22:0</c></p>
            </p>
          </statement>
          <feedback />
        </choice>
      </choices>
    </exercise>
    <exercise xml:id="exer-timer_class-multi6-1" label="exe-sec-HW10-1-271619">
      <title>Writing Methods</title>
      <statement>
        <p>Consider the following class definition.</p>
        <pre>  class Timer:
      """ A class that represents a timer. """
      def __init__(self):
          self.hours = 0
          self.minutes = 0
          self.seconds = 0

      def print_with_labels(self):
          print('Hours:', self.hours, end=' ')
          print('Minutes:', self.minutes, end=' ')
          print('Seconds:', self.seconds)

      def __str__(self):
          return f'{self.hours}:{self.minutes}:{self.seconds}'        </pre>
        <p>Which of the following is the correct definition for a new <c>Timer</c> class method called <c>set</c> that will take three integer values representing hours, minutes, and seconds and set the object's instance variables (attributes) appropriately?</p>
      </statement>
      <choices multiple-correct="no" randomize="yes">
        <choice correct="yes">
          <statement>
            <p>
              <pre>def set(self, h, m, s):
    self.hours = h
    self.minutes = m
    self.seconds = s              </pre>
            </p>
          </statement>
          <feedback />
        </choice>
        <choice correct="no">
          <statement>
            <p>
              <pre>def set(h, m, s):
    self.hours = h
    self.minutes = m
    self.seconds = s              </pre>
            </p>
          </statement>
          <feedback>
            <p>Remember, when writing a method for a class, you always need to include <c>self</c> as the first parameter.</p>
          </feedback>
        </choice>
        <choice correct="no">
          <statement>
            <p>
              <pre>def set(self):
    self.hours = h
    self.minutes = m
    self.seconds = s              </pre>
            </p>
          </statement>
          <feedback>
            <p>To be able give new values to the object's <c>hours</c> and <c>minutes</c>, you give the method parameters to hold those values.</p>
          </feedback>
        </choice>
        <choice correct="no">
          <statement>
            <p>
              <pre>def set(self, h, m, s):
    hours = h
    minutes = m
    seconds = s              </pre>
            </p>
          </statement>
          <feedback>
            <p>You need to assign the new values to the object's attributes.</p>
          </feedback>
        </choice>
      </choices>
    </exercise>
    <exercise xml:id="exer-timer_class-call_set_short-1" label="exe-sec-HW10-1-271620">
      <title>Calling the Set Method</title>
      <statement>
        <p>Consider the following class definition.</p>
        <pre>  class Timer:
      """ A class that represents a timer. """
      def __init__(self):
          self.hours = 0
          self.minutes = 0
          self.seconds = 0

      def print_with_labels(self):
          print('Hours:', self.hours, end=' ')
          print('Minutes:', self.minutes, end=' ')
          print('Seconds:', self.seconds)

      def __str__(self):
          return f'{self.hours}:{self.minutes}:{self.seconds}'        </pre>
        <p>Suppose <c>t1</c> is a newly created instance of the the <c>Timer</c> class (i.e., a <c>Timer</c> object). Give the line of code that will call the <c>set</c> method, as described in the previous question, to set <c>t1</c> to 5 hours, 17 minutes, 51 seconds.</p>
        <fillin mode="string" answer="t1.set(5, 17, 51)" width="16" />
      </statement>
      <evaluation>
        <evaluate>
          <test correct="yes">
            <strcmp>t1.set\( *5 *, *17 *, *51 *\)</strcmp>
            <feedback />
          </test>
          <test>
            <strcmp>t1\.set\(5,17,51\)</strcmp>
            <feedback />
          </test>
          <test>
            <strcmp>t1\.set\(5, 17,51\)</strcmp>
            <feedback />
          </test>
          <test>
            <strcmp>t1\.set\(5,17, 51\)</strcmp>
            <feedback />
          </test>
        </evaluate>
      </evaluation>
    </exercise>
    <exercise xml:id="exer-timer_class-convert_to_seconds_method-1" label="exe-sec-HW10-1-271622">
      <title>Convert to Seconds</title>
      <statement>
        <p>Implement a method for the Timer class, <c>convert_to_seconds</c>. For a given Timer, the method returns the equivalent number of seconds. For example, if Timer <c>t1</c> is currently set to 0:1:15 (0 hours, 1 minute, 15 seconds), then the call <c>t1.convert_to_seconds()</c> will return 75.</p>
        <p>Hint: Remember that inside the body of the convert_to_seconds method definition, we use the parameter <c>self</c>to refer to the <c>Timer</c>object which activated the method.</p>
        <p>The <c>Timer</c> class definition is given below for reference.</p>
        <pre>    class Timer:
        """ A class that represents a timer. """
        def __init__(self, h, m, s):
            self.hours = h
            self.minutes = m
            self.seconds = s

        def print_with_labels(self):
            print('Hours:', self.hours, end=' ')
            print('Minutes:', self.minutes, end=' ')
            print('Seconds:', self.seconds)

        def __str__(self):
            return f'{self.hours}:{self.minutes}:{self.seconds}'        </pre>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="40%" />
          <col top="minor" width="60%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Test</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>timer1 = Timer(0, 5, 30)
timer1.convert_to_seconds()</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>330</cd>
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">
class Timer:
    """ A class that represents a timer. """
    def __init__(self, h, m, s):
        self.hours = h
        self.minutes = m
        self.seconds= s

    def print_with_labels(self):
        print('Hours:', self.hours, end=' ')
        print('Minutes:', self.minutes, end=' ')
        print('Seconds:', self.seconds)

    def __str__(self):
        return f'{self.hours}:{self.minutes}:{self.seconds}'

        </preamble>
        <code>
# NOTE: Do not change the indentation! It is required because the
# code will be pasted into the Timer class definition body.
    def convert_to_seconds(self):
        </code>
<tests>
from unittest.gui import TestCaseGui
import StringIO
import sys

class myTests(TestCaseGui):


  def test1(self):
    res = Timer(0, 5, 30).convert_to_seconds()
    self.assertEqual(res, 330, "&lt;pre&gt;timer1 = Timer(0, 5, 30)\ntimer1.convert_to_seconds()&lt;/pre&gt;")

  def test2(self):
    res = Timer(0, 55, 30).convert_to_seconds()
    self.assertEqual(res, 3330, "&lt;pre&gt;timer1 = Timer(0, 55, 30)\ntimer1.convert_to_seconds()&lt;/pre&gt;")

  def test3(self):
    res = Timer(14, 40, 30).convert_to_seconds()
    self.assertEqual(res, 52830, "&lt;pre&gt;timer1 = Timer(14, 40, 30)\ntimer1.convert_to_seconds()&lt;/pre&gt;")

  def test4(self):
    res = Timer(1, 2, 3).convert_to_seconds()
    self.assertEqual(res, 3723, "&lt;pre&gt;timer1 = Timer(1, 2, 3)\ntimer1.convert_to_seconds()&lt;/pre&gt;")

  def test5(self):
    res = Timer(10, 45, 59).convert_to_seconds()
    self.assertEqual(res, 38759, "&lt;pre&gt;timer1 = Timer(10, 45, 59)\ntimer1.convert_to_seconds()&lt;/pre&gt;")

myTests().main()
</tests>
      </program>
    </exercise>
    <exercise xml:id="exer-timer_class-add_timers-1" label="exe-sec-HW10-1-271624">
      <title>Add Two Timers</title>
      <statement>
        <p>Write a function, add_timers, that takes two <c>Timer</c> objects, <c>t1</c> and <c>t2</c>, and returns a new <c>Timer</c> object that is the sum of <c>t1</c> and <c>t2</c>. Neither of the original <c>Timer</c> objects should be changed.</p>
        <p>The minutes and seconds attributes for the new <c>Timer</c> object must be valid (i.e., in the range 0 through 59). This means you may need to do some conversion from seconds to minutes and from minutes to hours. You may assume that the attributes for the provided <c>Timer</c> objects <c>t1</c> and <c>t2</c> are valid.</p>
        <p>Note that the function you are writing is <alert>NOT</alert> a <c>Timer</c> class method. It is just a regular function.</p>
        <p><alert>HINT</alert>: Use floor division (//) and remainder (%) to implement this function.</p>
        <p>The <c>Timer</c> class is given below for reference.</p>
        <pre>class Timer:
        """ A class that represents a timer. """
        def __init__(self, h, m, s):
            self.hours = h
            self.minutes = m
            self.seconds = s

        def print_with_labels(self):
            print('Hours:', self.hours, end=' ')
            print('Minutes:', self.minutes, end=' ')
            print('Seconds:', self.seconds)

        def get_seconds(self):
            return self.seconds

        def get_minutes(self):
            return self.minutes

        def get_hours(self):
            return self.hours

        def __str__(self):
            return f'{self.hours}:{self.minutes}:{self.seconds}'        </pre>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="40%" />
          <col top="minor" width="60%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Test</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>timer1 = Timer(0, 5, 30)
timer2 = Timer(2, 19, 0)
add_timers(timer1, timer2)</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>2:24:30</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>timer1 = Timer(1, 51, 41)
timer2 = Timer(4, 48, 59)
add_timers(timer1, timer2)</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>6:40:40</cd>
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">
class Timer:
    """ A class that represents a timer. """
    def __init__(self, h, m, s):
        self.hours = h
        self.minutes = m
        self.seconds= s

    def print_with_labels(self):
        print('Hours:', self.hours, end=' ')
        print('Minutes:', self.minutes, end=' ')
        print('Seconds:', self.seconds)

    def get_seconds(self):
        return self.seconds

    def get_minutes(self):
        return self.minutes

    def get_hours(self):
        return self.hours

    def __str__(self):
        return f'{self.hours}:{self.minutes}:{self.seconds}'

        </preamble>
        <code>
def add_timers(t1, t2):
        </code>
        <postamble visible="no">
        </postamble>
<tests>
from unittest.gui import TestCaseGui
import StringIO
import sys

class myTests(TestCaseGui):


  def test1(self):
    timer1 = Timer(0, 5, 30)
    timer2 = Timer(2, 19, 0)
    res = add_timers(timer1, timer2)
    self.assertEqual(str(res), '2:24:30', "&lt;pre&gt;timer1 = Timer(0, 5, 30)\ntimer2 = Timer(2, 19, 0)\nadd_timers(timer1, timer2)&lt;/pre&gt;")

  def test2(self):
    timer1 = Timer(0, 5, 30)
    timer2 = Timer(2, 19, 35)
    res = add_timers(timer1, timer2)
    self.assertEqual(str(res), '2:25:5', "&lt;pre&gt;timer1 = Timer(0, 5, 30)\ntimer2 = Timer(2, 19, 35)\nadd_timers(timer1, timer2)&lt;/pre&gt;")

  def test3(self):
    timer1 = Timer(0, 55, 30)
    timer2 = Timer(2, 10, 0)
    res = add_timers(timer1, timer2)
    self.assertEqual(str(res), '3:5:30', "&lt;pre&gt;timer1 = Timer(0, 55, 30)\ntimer2 = Timer(2, 10, 0)\nadd_timers(timer1, timer2)&lt;/pre&gt;")

  def test4(self):
    timer1 = Timer(14, 40, 30)
    timer2 = Timer(6, 10, 45)
    res = add_timers(timer1, timer2)
    self.assertEqual(str(res), '20:51:15', "&lt;pre&gt;timer1 = Timer(14, 40, 30)\ntimer2 = Timer(6, 10, 45)\nadd_timers(timer1, timer2)&lt;/pre&gt;")

  def test5(self):
    timer1 = Timer(1, 51, 41)
    timer2 = Timer(4, 48, 59)
    res = add_timers(timer1, timer2)
    self.assertEqual(str(res), '6:40:40', "&lt;pre&gt;timer1 = Timer(1, 51, 41)\ntimer2 = Timer(4, 48, 59)\nadd_timers(timer1, timer2)&lt;/pre&gt;")

  def test6(self):
    timer1 = Timer(10, 49, 59)
    timer2 = Timer(30, 54, 50)
    res = add_timers(timer1, timer2)
    self.assertEqual(str(res), '41:44:49', "&lt;pre&gt;timer1 = Timer(10, 49, 59)\ntimer2 = Timer(30, 54, 50)\nadd_timers(timer1, timer2)&lt;/pre&gt;")

myTests().main()
</tests>
      </program>
    </exercise>
    <exercise xml:id="exer-implement_comp_oper_info-1" label="exe-sec-HW10-1-271625">
      <title>Implementing the Comparison Operators</title>
      <statement correct="yes">
        <p>Python has "magic" methods to make the comparison operators work with objects. The six comparison operators (&lt;, &lt;=, &gt;, &gt;=, == and !=) are enabled simply by implementing the following special methods: <c>__lt__, __le__, __gt__, __ge__, __eq__ and __ne__</c></p>
        <p>See: <em><url href="https://www.tutorialspoint.com/How-to-overload-Python-comparison-operators">https://www.tutorialspoint.com/How-to-overload-Python-comparison-operators</url></em></p>
        <p>For example, here is the code to implement <c>__lt__</c> (i.e., &lt;, the "less than" operator) for the <c>Timer</c>class. Notice we start by converting both Timers to an integer number of seconds, then simply compare those numbers of seconds. Comparing two Timers reduces to the problem of comparing two integers.</p>
        <pre>
    def __lt__(self, other):
        sec_self = self.convert_to_seconds()
        sec_other = other.convert_to_seconds()
        return sec_self &lt; sec_other
        </pre>
        <p>Did you follow the link to read about comparison operators?</p>
      </statement>
    </exercise>
    <exercise xml:id="exer-timer_class-equivalence_operator_overload-1" label="exe-sec-HW10-1-271627">
      <title>Equivalence and Inequivalence Operators: ==, !=</title>
      <statement>
        <p>Two Timer objects are <alert>equivalent</alert>exactly when they represent the same amount of time. Implement the <c>__eq__</c>method (i.e., == ) for the <c>Timer</c>class.</p>
        <p><alert>Hint</alert>: You should assume that the <c>convert_to_seconds</c> method has already been implemented.</p>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="60%" />
          <col top="minor" width="40%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Test</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>Timer(0, 5, 30) == Timer(0, 5, 30)</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>True</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>Timer(0, 5, 30) != Timer(0, 5, 30)</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>False</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>Timer(1, 5, 30) == Timer(0, 5, 30)</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>False</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>Timer(1, 5, 30) != Timer(0, 5, 30)</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>True</cd>
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">
class Timer:
    """ A class that represents a timer. """
    def __init__(self, h, m, s):
        self.hours = h
        self.minutes = m
        self.seconds= s

    def print_with_labels(self):
        print('Hours:', self.hours, end=' ')
        print('Minutes:', self.minutes, end=' ')
        print('Seconds:', self.seconds)

    def get_seconds(self):
        return self.seconds

    def get_minutes(self):
        return self.minutes

    def get_hours(self):
        return self.hours

    def convert_to_seconds(self):
        return self.hours*60*60 + self.minutes*60 + self.seconds

    def __str__(self):
        return f'{self.hours}:{self.minutes}:{self.seconds}'

        </preamble>
        <code>
# NOTE: Do not change the indentation! It is required because the
# code will be pasted into the Timer class definition body.
    def __eq__(self, other):


        </code>
        <postamble visible="no">
        </postamble>
<tests>
from unittest.gui import TestCaseGui
import StringIO
import sys

class myTests(TestCaseGui):


  def test1(self):
    timer1 = Timer(0, 5, 30)
    timer2 = Timer(2, 19, 0)
    b1 = timer1 == timer2
    b2 = timer1 != timer2
    self.assertEqual(b1, False, "Timer(0, 5, 30) == Timer(2, 19, 0)")
    self.assertEqual(b2, True, "Timer(0, 5, 30) != Timer(2, 19, 0)")

  def test2(self):
    timer1 = Timer(0, 5, 30)
    timer2 = Timer(2, 19, 35)
    b1 = timer1 == timer2
    b2 = timer1 != timer2
    self.assertEqual(b1, False, "Timer(0, 5, 30) == Timer(2, 19, 35)")
    self.assertEqual(b2, True, "Timer(0, 5, 30) != Timer(2, 19, 35)")

  def test3(self):
    timer1 = Timer(0, 55, 30)
    timer2 = Timer(2, 10, 0)
    b1 = timer1 == timer2
    b2 = timer1 != timer2
    self.assertEqual(b1, False, "Timer(0, 55, 30) == Timer(2, 10, 0)")
    self.assertEqual(b2, True, "Timer(0, 55, 30) != Timer(2, 10, 0)")

  def test4(self):
    timer1 = Timer(14, 40, 30)
    timer2 = Timer(6, 10, 45)
    b1 = timer1 == timer2
    b2 = timer1 != timer2
    self.assertEqual(b1, False, "Timer(14, 40, 30) == Timer(6, 10, 45)")
    self.assertEqual(b2, True, "Timer(14, 40, 30) != Timer(6, 10, 45)")

  def test5(self):
    timer1 = Timer(1, 51, 41)
    timer2 = Timer(4, 48, 59)
    b1 = timer1 == timer2
    b2 = timer1 != timer2
    self.assertEqual(b1, False, "Timer(1, 51, 41) == Timer(4, 48, 59)")
    self.assertEqual(b2, True, "Timer(1, 51, 41) != Timer(4, 48, 59)")

  def test6(self):
    timer1 = Timer(10, 49, 59)
    timer2 = Timer(30, 54, 50)
    b1 = timer1 == timer2
    b2 = timer1 != timer2
    self.assertEqual(b1, False, "Timer(10, 49, 59) == Timer(30, 54, 50)")
    self.assertEqual(b2, True, "Timer(10, 49, 59) != Timer(30, 54, 50)")

myTests().main()
</tests>
      </program>
    </exercise>
  </exercises>
</section>
