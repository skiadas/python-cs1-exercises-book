<section xml:id="sec-HW7-1-practice">
  <title>HW7 Practice</title>
  <introduction />
  <exercises>
    <exercise xml:id="exer-swap_list_ends-1-practice" label="exe-sec-HW7-1-103572-practice">
      <title>Swap List Ends</title>
      <statement>
        <p>The function <c>swap_list_ends</c> takes one parameter, <c>L</c>, which is a list. The function then swaps the first and last items in <c>L</c> and returns the object <c>None</c>.  Notice that since <c>L</c> is mutable, the changes the function makes to <c>L</c> are <em>visible back in the calling program</em>.</p>
        <p>SPECIAL CASE: If the list L has length less than 2, then the function does nothing to L and returns <c>None</c>.</p>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="40%" />
          <col top="minor" width="60%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Test</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>L = [1, 3, 9, 2]
if not(swap_list_ends(L) is None):
    print("Error: function should return None")
print(L)                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>[2, 3, 9, 1]</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>L = ['super', 'awesome', 'excellent']
if not(swap_list_ends(L) is None):
    print("Error: function should return None")
print(L)                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>['excellent', 'awesome', 'super']</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>L = [True, False]
if not(swap_list_ends(L) is None):
    print("Error: function should return None")
print(L)                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>[False, True]</cd>
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">_my_out = ""
_my_in = []
_datafiles = {}

# Start of FileLike
class FileLike:
  def __init__(self, contents):
    self.contents = contents
    self.cursor = 0

  def __enter__(self):
    return self

  def __exit__(self, exc_type, exc_value, traceback):
    self.close()

  def tell(self):
    return self.cursor

  def seek(self, n):
    self.cursor = n

  def read(self):
    n = self.cursor
    self.cursor = max(n, len(self.contents))
    return self.contents[n:]

  def readline(self):
    n = self.cursor
    rest = self.contents[n:]
    index = rest.find("\n")
    if index == -1:
      self.cursor = len(self.contents)
      return rest
    index += 1
    self.cursor = n + index
    return rest[:index]

  def readlines(self):
    results = []
    while True:
      line = self.readline()
      if line == '':
        return results
      results.append(line)

  def __iter__(self):
    for l in self.readlines():
      yield l


  def close(self):
    pass

# End of FileLike

def open(fname, mode = "r"):
  """our own open"""
  if fname in _datafiles:
    return FileLike(_datafiles[fname])
  raise BaseException(f"File not found: {fname}")


def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise RuntimeError()
  return _my_in.pop()

None

        </preamble>
        <code>

        </code>
        <postamble visible="no">
        </postamble>
        <tests>import re

RIGHT_WHITESPACE_TRIMMER = re.compile("[ \\t]+?(?=\\n|$)")


from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')

    L = [1, 3, 9, 2]
    if not(swap_list_ends(L) is None):
        print("Error: function should return None")
    print(L)

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '[2, 3, 9, 1]\n'.strip(), "Test: " + 'L = [1, 3, 9, 2]\nif not(swap_list_ends(L) is None):\n    print("Error: function should return None")\nprint(L)')


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')

    L = ['super', 'awesome', 'excellent']
    if not(swap_list_ends(L) is None):
        print("Error: function should return None")
    print(L)

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), "['excellent', 'awesome', 'super']\n".strip(), "Test: " + 'L = [\'super\', \'awesome\', \'excellent\']\nif not(swap_list_ends(L) is None):\n    print("Error: function should return None")\nprint(L)')


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')

    L = [['a', 'b'], ['c', 'd', 'e']]
    if not(swap_list_ends(L) is None):
        print("Error: function should return None")
    print(L)

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), "[['c', 'd', 'e'], ['a', 'b']]\n".strip(), "Test: " + 'L = [[\'a\', \'b\'], [\'c\', \'d\', \'e\']]\nif not(swap_list_ends(L) is None):\n    print("Error: function should return None")\nprint(L)')


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')

    L = [True, False]
    if not(swap_list_ends(L) is None):
        print("Error: function should return None")
    print(L)

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '[False, True]\n'.strip(), "Test: " + 'L = [True, False]\nif not(swap_list_ends(L) is None):\n    print("Error: function should return None")\nprint(L)')


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')

    L = ['just one thing']
    if not(swap_list_ends(L) is None):
        print("Error: function should return None")
    print(L)

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), "['just one thing']\n".strip(), "Test: " + 'L = [\'just one thing\']\nif not(swap_list_ends(L) is None):\n    print("Error: function should return None")\nprint(L)')


  def test6(self):
    resetMyStdOut()
    setMyStdIn('')

    L = []
    if not(swap_list_ends(L) is None):
        print("Error: function should return None")
    print(L)

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '[]\n'.strip(), "Test: " + 'L = []\nif not(swap_list_ends(L) is None):\n    print("Error: function should return None")\nprint(L)')


  def test7(self):
    resetMyStdOut()
    setMyStdIn('')

    L = [5]
    if not(swap_list_ends(L) is None):
        print("Error: function should return None")
    print(L)

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '[5]\n'.strip(), "Test: " + 'L = [5]\nif not(swap_list_ends(L) is None):\n    print("Error: function should return None")\nprint(L)')


  def test8(self):
    resetMyStdOut()
    setMyStdIn('')

    L = list("outstanding")
    if not(swap_list_ends(L) is None):
        print("Error: function should return None")
    print(L)

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), "['g', 'u', 't', 's', 't', 'a', 'n', 'd', 'i', 'n', 'o']\n".strip(), "Test: " + 'L = list("outstanding")\nif not(swap_list_ends(L) is None):\n    print("Error: function should return None")\nprint(L)')



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-make_list_items_upper_2-3-practice" label="exe-sec-HW7-1-31105-practice">
      <title>Make List Items Uppercase 2</title>
      <statement>
        <p>Define the function <c>make_uppercase(mylist)</c>, which takes a list parameter <c>mylist</c> (a list of strings), mutates the list by uppercasing each string in mylist. The function returns <c>None</c>.</p>
        <p>For example, if <c>mylist</c> is <c>['cat', 'Dog', 'frOG']</c>, then the mutated list should  be <c>['CAT', 'DOG', 'FROG']</c>.</p>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="40%" />
          <col top="minor" width="60%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Test</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>mylist = ['cat', 'Dog', 'frOG']
result = make_uppercase(mylist)
print(mylist)
if result != None:
    print("Error, return value should be None")                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>['CAT', 'DOG', 'FROG']</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>mylist = ['baNanas', 'appLes', 'pEAches', 'PEArs']
result = make_uppercase(mylist)
print(mylist)
if result != None:
    print("Error, return value should be None")                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>['BANANAS', 'APPLES', 'PEACHES', 'PEARS']</cd>
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">_my_out = ""
_my_in = []
_datafiles = {}

# Start of FileLike
class FileLike:
  def __init__(self, contents):
    self.contents = contents
    self.cursor = 0

  def __enter__(self):
    return self

  def __exit__(self, exc_type, exc_value, traceback):
    self.close()

  def tell(self):
    return self.cursor

  def seek(self, n):
    self.cursor = n

  def read(self):
    n = self.cursor
    self.cursor = max(n, len(self.contents))
    return self.contents[n:]

  def readline(self):
    n = self.cursor
    rest = self.contents[n:]
    index = rest.find("\n")
    if index == -1:
      self.cursor = len(self.contents)
      return rest
    index += 1
    self.cursor = n + index
    return rest[:index]

  def readlines(self):
    results = []
    while True:
      line = self.readline()
      if line == '':
        return results
      results.append(line)

  def __iter__(self):
    for l in self.readlines():
      yield l


  def close(self):
    pass

# End of FileLike

def open(fname, mode = "r"):
  """our own open"""
  if fname in _datafiles:
    return FileLike(_datafiles[fname])
  raise BaseException(f"File not found: {fname}")


def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise RuntimeError()
  return _my_in.pop()

None

        </preamble>
        <code>

        </code>
        <postamble visible="no">
        </postamble>
        <tests>import re

RIGHT_WHITESPACE_TRIMMER = re.compile("[ \\t]+?(?=\\n|$)")


from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')

    mylist = ['cat', 'Dog', 'frOG']
    result = make_uppercase(mylist)
    print(mylist)
    if result != None:
        print("Error, return value should be None")

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), "['CAT', 'DOG', 'FROG']\n".strip(), "Test: " + 'mylist = [\'cat\', \'Dog\', \'frOG\']\nresult = make_uppercase(mylist)\nprint(mylist)\nif result != None:\n    print("Error, return value should be None")')


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')

    mylist = ['baNanas', 'appLes', 'pEAches', 'PEArs']
    result = make_uppercase(mylist)
    print(mylist)
    if result != None:
        print("Error, return value should be None")

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), "['BANANAS', 'APPLES', 'PEACHES', 'PEARS']\n".strip(), "Test: " + 'mylist = [\'baNanas\', \'appLes\', \'pEAches\', \'PEArs\']\nresult = make_uppercase(mylist)\nprint(mylist)\nif result != None:\n    print("Error, return value should be None")')


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')

    mylist = ['w', 'x', 'y', 'z', 'yes']
    result = make_uppercase(mylist)
    print(mylist)
    if result != None:
        print("Error, return value should be None")

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), "['W', 'X', 'Y', 'Z', 'YES']\n".strip(), "Test: " + 'mylist = [\'w\', \'x\', \'y\', \'z\', \'yes\']\nresult = make_uppercase(mylist)\nprint(mylist)\nif result != None:\n    print("Error, return value should be None")')


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')

    mylist = []
    result = make_uppercase(mylist)
    print(mylist)
    if result != None:
        print("Error, return value should be None")

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '[]\n'.strip(), "Test: " + 'mylist = []\nresult = make_uppercase(mylist)\nprint(mylist)\nif result != None:\n    print("Error, return value should be None")')


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')

    mylist = ['cOw', 'HoRse', 'pig', 'BUNNy']
    result = make_uppercase(mylist)
    print(mylist)
    if result != None:
        print("Error, return value should be None")

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), "['COW', 'HORSE', 'PIG', 'BUNNY']\n".strip(), "Test: " + 'mylist = [\'cOw\', \'HoRse\', \'pig\', \'BUNNy\']\nresult = make_uppercase(mylist)\nprint(mylist)\nif result != None:\n    print("Error, return value should be None")')



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-square_nums_2-1-practice" label="exe-sec-HW7-1-31106-practice">
      <title>Square Nums 2</title>
      <statement>
        <p>Define the function <c>square_nums_2</c> which takes a list of numbers, <alert>L</alert>, and mutates <alert>L</alert> so that each original item is now squared. For example, if L is <c>[2, -5, 9]</c> then, after calling <c>square_nums_2(L)</c>, <c>L == [4, 25, 81]</c>.</p>
        <p>Nothing is printed and None is returned.</p>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="40%" />
          <col top="minor" width="60%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Test</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>L = [0, 1, 2, 3]
square_nums_2(L)
print(L)                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>[0, 1, 4, 9]</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>L = [5]
square_nums_2(L)
print(L)                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>[25]</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>L = []
square_nums_2(L)
print(L)                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>[]</cd>
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">_my_out = ""
_my_in = []
_datafiles = {}

# Start of FileLike
class FileLike:
  def __init__(self, contents):
    self.contents = contents
    self.cursor = 0

  def __enter__(self):
    return self

  def __exit__(self, exc_type, exc_value, traceback):
    self.close()

  def tell(self):
    return self.cursor

  def seek(self, n):
    self.cursor = n

  def read(self):
    n = self.cursor
    self.cursor = max(n, len(self.contents))
    return self.contents[n:]

  def readline(self):
    n = self.cursor
    rest = self.contents[n:]
    index = rest.find("\n")
    if index == -1:
      self.cursor = len(self.contents)
      return rest
    index += 1
    self.cursor = n + index
    return rest[:index]

  def readlines(self):
    results = []
    while True:
      line = self.readline()
      if line == '':
        return results
      results.append(line)

  def __iter__(self):
    for l in self.readlines():
      yield l


  def close(self):
    pass

# End of FileLike

def open(fname, mode = "r"):
  """our own open"""
  if fname in _datafiles:
    return FileLike(_datafiles[fname])
  raise BaseException(f"File not found: {fname}")


def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise RuntimeError()
  return _my_in.pop()

None

        </preamble>
        <code>

        </code>
        <postamble visible="no">
        </postamble>
        <tests>import re

RIGHT_WHITESPACE_TRIMMER = re.compile("[ \\t]+?(?=\\n|$)")


from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')

    L = [0, 1, 2, 3]
    square_nums_2(L)
    print(L)

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '[0, 1, 4, 9]\n'.strip(), "Test: " + 'L = [0, 1, 2, 3]\nsquare_nums_2(L)\nprint(L)')


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')

    L = [5]
    square_nums_2(L)
    print(L)

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '[25]\n'.strip(), "Test: " + 'L = [5]\nsquare_nums_2(L)\nprint(L)')


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')

    L = []
    square_nums_2(L)
    print(L)

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '[]\n'.strip(), "Test: " + 'L = []\nsquare_nums_2(L)\nprint(L)')


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')

    L = [-1, 1, -2, 2, -3, 3]
    square_nums_2(L)
    print(L)

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '[1, 1, 4, 4, 9, 9]\n'.strip(), "Test: " + 'L = [-1, 1, -2, 2, -3, 3]\nsquare_nums_2(L)\nprint(L)')


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')

    L = [9, 94, 39, 60, 99, 83]
    square_nums_2(L)
    print(L)

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '[81, 8836, 1521, 3600, 9801, 6889]\n'.strip(), "Test: " + 'L = [9, 94, 39, 60, 99, 83]\nsquare_nums_2(L)\nprint(L)')


  def test6(self):
    resetMyStdOut()
    setMyStdIn('')

    L  = [99, 9, 94, 39, 60, 83, 99]
    square_nums_2(L)
    print(L)

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '[9801, 81, 8836, 1521, 3600, 6889, 9801]\n'.strip(), "Test: " + 'L  = [99, 9, 94, 39, 60, 83, 99]\nsquare_nums_2(L)\nprint(L)')



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-nested_accum_hyphenated_pairs-1-practice" label="exe-sec-HW7-1-32007-practice">
      <title>Hyphenated Pairs with Nested Loop</title>
      <statement>
        <p>Define the function <c>get_pairs</c>, which takes a list L of strings, such as</p>
        <pre>L = ['r', 'g']</pre>
        <p>and returns a list of all the hyphenated pairs of strings from the list (returns a list of strings, such as <c>['r-r', 'r-g', 'g-r', 'g-g']</c>)</p>
        <p>Use a double for loop or list comprehension to accumulate the result.</p>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="40%" />
          <col top="minor" width="60%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Test</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>L = ['yes', 'no', 'maybe']
print(get_pairs(L))                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>['yes-yes', 'yes-no', 'yes-maybe', 'no-yes', 'no-no', 'no-maybe', 'maybe-yes', 'maybe-no', 'maybe-maybe']</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>strlist = ["X", "x"]
print(get_pairs(strlist))                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>['X-X', 'X-x', 'x-X', 'x-x']</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>empty = []
print(get_pairs(empty))                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>[]</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>food = ['apple', 'cheese', 'bread']
print(get_pairs(food))                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>['apple-apple', 'apple-cheese', 'apple-bread', 'cheese-apple', 'cheese-cheese', 'cheese-bread', 'bread-apple', 'bread-cheese', 'bread-bread']</cd>
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">_my_out = ""
_my_in = []
_datafiles = {}

# Start of FileLike
class FileLike:
  def __init__(self, contents):
    self.contents = contents
    self.cursor = 0

  def __enter__(self):
    return self

  def __exit__(self, exc_type, exc_value, traceback):
    self.close()

  def tell(self):
    return self.cursor

  def seek(self, n):
    self.cursor = n

  def read(self):
    n = self.cursor
    self.cursor = max(n, len(self.contents))
    return self.contents[n:]

  def readline(self):
    n = self.cursor
    rest = self.contents[n:]
    index = rest.find("\n")
    if index == -1:
      self.cursor = len(self.contents)
      return rest
    index += 1
    self.cursor = n + index
    return rest[:index]

  def readlines(self):
    results = []
    while True:
      line = self.readline()
      if line == '':
        return results
      results.append(line)

  def __iter__(self):
    for l in self.readlines():
      yield l


  def close(self):
    pass

# End of FileLike

def open(fname, mode = "r"):
  """our own open"""
  if fname in _datafiles:
    return FileLike(_datafiles[fname])
  raise BaseException(f"File not found: {fname}")


def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise RuntimeError()
  return _my_in.pop()

None

        </preamble>
        <code>

        </code>
        <postamble visible="no">
        </postamble>
        <tests>import re

RIGHT_WHITESPACE_TRIMMER = re.compile("[ \\t]+?(?=\\n|$)")


from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')

    L = ['yes', 'no', 'maybe']
    print(get_pairs(L))

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), "['yes-yes', 'yes-no', 'yes-maybe', 'no-yes', 'no-no', 'no-maybe', 'maybe-yes', 'maybe-no', 'maybe-maybe']\n".strip(), "Test: " + "L = ['yes', 'no', 'maybe']\nprint(get_pairs(L))")


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')

    fish = ["angel", "gold", "cat", "puffer", "damsel"]
    print(get_pairs(fish))

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), "['angel-angel', 'angel-gold', 'angel-cat', 'angel-puffer', 'angel-damsel', 'gold-angel', 'gold-gold', 'gold-cat', 'gold-puffer', 'gold-damsel', 'cat-angel', 'cat-gold', 'cat-cat', 'cat-puffer', 'cat-damsel', 'puffer-angel', 'puffer-gold', 'puffer-cat', 'puffer-puffer', 'puffer-damsel', 'damsel-angel', 'damsel-gold', 'damsel-cat', 'damsel-puffer', 'damsel-damsel']\n".strip(), "Test: " + 'fish = ["angel", "gold", "cat", "puffer", "damsel"]\nprint(get_pairs(fish))')


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')

    strlist = ["X", "x"]
    print(get_pairs(strlist))

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), "['X-X', 'X-x', 'x-X', 'x-x']\n".strip(), "Test: " + 'strlist = ["X", "x"]\nprint(get_pairs(strlist))')


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')

    empty = []
    print(get_pairs(empty))

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '[]\n'.strip(), "Test: " + 'empty = []\nprint(get_pairs(empty))')


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')

    L = ["UNO"]
    print(get_pairs(L))

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), "['UNO-UNO']\n".strip(), "Test: " + 'L = ["UNO"]\nprint(get_pairs(L))')


  def test6(self):
    resetMyStdOut()
    setMyStdIn('')

    food = ['apple', 'cheese', 'bread']
    print(get_pairs(food))

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), "['apple-apple', 'apple-cheese', 'apple-bread', 'cheese-apple', 'cheese-cheese', 'cheese-bread', 'bread-apple', 'bread-cheese', 'bread-bread']\n".strip(), "Test: " + "food = ['apple', 'cheese', 'bread']\nprint(get_pairs(food))")


  def test7(self):
    resetMyStdOut()
    setMyStdIn('')

    instruments = ["Box drum", "Paixiao", "Saxophone", "Txistu", "Xalam", "Xaphoon", "Xun", "Xylophone"]
    print(get_pairs(instruments))

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), "['Box drum-Box drum', 'Box drum-Paixiao', 'Box drum-Saxophone', 'Box drum-Txistu', 'Box drum-Xalam', 'Box drum-Xaphoon', 'Box drum-Xun', 'Box drum-Xylophone', 'Paixiao-Box drum', 'Paixiao-Paixiao', 'Paixiao-Saxophone', 'Paixiao-Txistu', 'Paixiao-Xalam', 'Paixiao-Xaphoon', 'Paixiao-Xun', 'Paixiao-Xylophone', 'Saxophone-Box drum', 'Saxophone-Paixiao', 'Saxophone-Saxophone', 'Saxophone-Txistu', 'Saxophone-Xalam', 'Saxophone-Xaphoon', 'Saxophone-Xun', 'Saxophone-Xylophone', 'Txistu-Box drum', 'Txistu-Paixiao', 'Txistu-Saxophone', 'Txistu-Txistu', 'Txistu-Xalam', 'Txistu-Xaphoon', 'Txistu-Xun', 'Txistu-Xylophone', 'Xalam-Box drum', 'Xalam-Paixiao', 'Xalam-Saxophone', 'Xalam-Txistu', 'Xalam-Xalam', 'Xalam-Xaphoon', 'Xalam-Xun', 'Xalam-Xylophone', 'Xaphoon-Box drum', 'Xaphoon-Paixiao', 'Xaphoon-Saxophone', 'Xaphoon-Txistu', 'Xaphoon-Xalam', 'Xaphoon-Xaphoon', 'Xaphoon-Xun', 'Xaphoon-Xylophone', 'Xun-Box drum', 'Xun-Paixiao', 'Xun-Saxophone', 'Xun-Txistu', 'Xun-Xalam', 'Xun-Xaphoon', 'Xun-Xun', 'Xun-Xylophone', 'Xylophone-Box drum', 'Xylophone-Paixiao', 'Xylophone-Saxophone', 'Xylophone-Txistu', 'Xylophone-Xalam', 'Xylophone-Xaphoon', 'Xylophone-Xun', 'Xylophone-Xylophone']\n".strip(), "Test: " + 'instruments = ["Box drum", "Paixiao", "Saxophone", "Txistu", "Xalam", "Xaphoon", "Xun", "Xylophone"]\nprint(get_pairs(instruments))')


  def test8(self):
    resetMyStdOut()
    setMyStdIn('')

    L = ['hearts', 'diamonds', 'clubs', 'spades']
    print(get_pairs(L))

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), "['hearts-hearts', 'hearts-diamonds', 'hearts-clubs', 'hearts-spades', 'diamonds-hearts', 'diamonds-diamonds', 'diamonds-clubs', 'diamonds-spades', 'clubs-hearts', 'clubs-diamonds', 'clubs-clubs', 'clubs-spades', 'spades-hearts', 'spades-diamonds', 'spades-clubs', 'spades-spades']\n".strip(), "Test: " + "L = ['hearts', 'diamonds', 'clubs', 'spades']\nprint(get_pairs(L))")



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-print_stars_grid_nested_loop-1-practice" label="exe-sec-HW7-1-271584-practice">
      <title>Print Grid of Asterisks with a Nested Loop</title>
      <statement>
        <p>Define a function <c>print_star_grid(rows, cols)</c>, which takes two positive integers as parameters and prints a rectangular grid of asterisks in response. <alert>rows</alert> indicates the number of rows to be printed, and <alert>cols</alert> indicates the number of columns (i.e., the length of each row).</p>
        <p>After each <c>"*"</c>, print a space (to match the examples).</p>
        <p>Hints:</p>
        <p>
          <ul>
            <li>For each r in range(rows), for each c in range(cols), print <c>"*  "</c> (a star followed by a space).</li>
            <li>To prevent going to a new line each time, include <alert>keyword argument:</alert><alert>end =</alert><alert>""</alert> in  your print call.</li>
            <li>Make a call to <alert>print() with no arguments</alert> each time the inner loop finishes (to make the end of a row).</li>
          </ul>
        </p>
        <p><alert>Note</alert>: This function does NOT explicitly return a value.</p>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="40%" />
          <col top="minor" width="60%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Test</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>print_star_grid(2,3)</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>* * *
* * *                </cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>print_star_grid(1,1)</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>*</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>print_star_grid(5,5)</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>* * * * *
* * * * *
* * * * *
* * * * *
* * * * *                </cd>
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">_my_out = ""
_my_in = []
_datafiles = {}

# Start of FileLike
class FileLike:
  def __init__(self, contents):
    self.contents = contents
    self.cursor = 0

  def __enter__(self):
    return self

  def __exit__(self, exc_type, exc_value, traceback):
    self.close()

  def tell(self):
    return self.cursor

  def seek(self, n):
    self.cursor = n

  def read(self):
    n = self.cursor
    self.cursor = max(n, len(self.contents))
    return self.contents[n:]

  def readline(self):
    n = self.cursor
    rest = self.contents[n:]
    index = rest.find("\n")
    if index == -1:
      self.cursor = len(self.contents)
      return rest
    index += 1
    self.cursor = n + index
    return rest[:index]

  def readlines(self):
    results = []
    while True:
      line = self.readline()
      if line == '':
        return results
      results.append(line)

  def __iter__(self):
    for l in self.readlines():
      yield l


  def close(self):
    pass

# End of FileLike

def open(fname, mode = "r"):
  """our own open"""
  if fname in _datafiles:
    return FileLike(_datafiles[fname])
  raise BaseException(f"File not found: {fname}")


def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise RuntimeError()
  return _my_in.pop()

None

        </preamble>
        <code>

        </code>
        <postamble visible="no">
        </postamble>
        <tests>import re

RIGHT_WHITESPACE_TRIMMER = re.compile("[ \\t]+?(?=\\n|$)")


from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')

    print_star_grid(2,3)

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '* * *\n* * *\n'.strip(), "Test: " + 'print_star_grid(2,3)')


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')

    print_star_grid(1,1)

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '*\n'.strip(), "Test: " + 'print_star_grid(1,1)')


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')

    print_star_grid(5,5)

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '* * * * *\n* * * * *\n* * * * *\n* * * * *\n* * * * *\n'.strip(), "Test: " + 'print_star_grid(5,5)')


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')

    print_star_grid(3,2)

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '* *\n* *\n* *\n'.strip(), "Test: " + 'print_star_grid(3,2)')


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')

    print_star_grid(7,3)

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '* * *\n* * *\n* * *\n* * *\n* * *\n* * *\n* * *\n'.strip(), "Test: " + 'print_star_grid(7,3)')



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-print_X_O_grid_nested_loop-1-practice" label="exe-sec-HW7-1-103574-practice">
      <title>Print X's and O's in a Grid with a Nested Loop</title>
      <statement>
        <p>Define a function <c>print_XO_grid(rows, cols)</c>, which takes two positive integers as parameters and prints a rectangular grid of X's and O's in response. rows indicates the number of rows to be printed, and cols indicates the number of columns (i.e., the length of each row).</p>
        <p>After each "X" or "O", print a space (to match the examples).</p>
        <p>Hints:</p>
        <p>
          <ul>
            <li>For each r in range(rows), for each c in range(cols), print "X " if r + c is even; otherwise, print "O ".</li>
            <li>To prevent going to a new line each time, include <alert>keyword argument:</alert><c>end = ""</c> in  your print call.</li>
            <li>Make a call to <alert>print() with no arguments</alert> each time the inner loop finishes (to make the end of a row).</li>
          </ul>
        </p>
        <p><alert>Note</alert>: This function does NOT explicitly return a value.</p>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="40%" />
          <col top="minor" width="60%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Test</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>print_XO_grid(2,3)</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>X O X
O X O                </cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>print_XO_grid(3,2)</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>X O
O X
X O                </cd>
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">_my_out = ""
_my_in = []
_datafiles = {}

# Start of FileLike
class FileLike:
  def __init__(self, contents):
    self.contents = contents
    self.cursor = 0

  def __enter__(self):
    return self

  def __exit__(self, exc_type, exc_value, traceback):
    self.close()

  def tell(self):
    return self.cursor

  def seek(self, n):
    self.cursor = n

  def read(self):
    n = self.cursor
    self.cursor = max(n, len(self.contents))
    return self.contents[n:]

  def readline(self):
    n = self.cursor
    rest = self.contents[n:]
    index = rest.find("\n")
    if index == -1:
      self.cursor = len(self.contents)
      return rest
    index += 1
    self.cursor = n + index
    return rest[:index]

  def readlines(self):
    results = []
    while True:
      line = self.readline()
      if line == '':
        return results
      results.append(line)

  def __iter__(self):
    for l in self.readlines():
      yield l


  def close(self):
    pass

# End of FileLike

def open(fname, mode = "r"):
  """our own open"""
  if fname in _datafiles:
    return FileLike(_datafiles[fname])
  raise BaseException(f"File not found: {fname}")


def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise RuntimeError()
  return _my_in.pop()

None

        </preamble>
        <code>

        </code>
        <postamble visible="no">
        </postamble>
        <tests>import re

RIGHT_WHITESPACE_TRIMMER = re.compile("[ \\t]+?(?=\\n|$)")


from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')

    print_XO_grid(2,3)

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'X O X\nO X O\n'.strip(), "Test: " + 'print_XO_grid(2,3)')


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')

    print_XO_grid(3,2)

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'X O\nO X\nX O\n'.strip(), "Test: " + 'print_XO_grid(3,2)')


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')

    print_XO_grid(1, 5)

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'X O X O X\n'.strip(), "Test: " + 'print_XO_grid(1, 5)')


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')

    print_XO_grid(3,1)

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'X\nO\nX\n'.strip(), "Test: " + 'print_XO_grid(3,1)')


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')

    print_XO_grid(5, 5)

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'X O X O X\nO X O X O\nX O X O X\nO X O X O\nX O X O X\n'.strip(), "Test: " + 'print_XO_grid(5, 5)')


  def test6(self):
    resetMyStdOut()
    setMyStdIn('')

    print_XO_grid(8, 3)

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'X O X\nO X O\nX O X\nO X O\nX O X\nO X O\nX O X\nO X O\n'.strip(), "Test: " + 'print_XO_grid(8, 3)')



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-nested_list_sum_up_all_items-1-practice" label="exe-sec-HW7-1-31565-practice">
      <title>Sum of Nested List Items</title>
      <statement>
        <p>Define the function <c>sum_nested(L)</c>, which takes parameter L (a list of lists of integers) and returns the sum of all the elements of all the inner lists of L.</p>
        <p>For example, if L  = [[1, 2], [3, 3, 2], [7, -6]], then <c>sum_nested(L)</c> would return 1 + 2 + 3 + 3 + 2 + 7 + (-6) = 12.</p>
        <p>TO DO:</p>
        <p>Write a double for loop to accumulate the sum.</p>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="40%" />
          <col top="minor" width="60%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Test</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>L = [[5]]
print(sum_nested(L))                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>5</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>L=[[1,2],[8,7,6]]
print(sum_nested(L))                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>24</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>L =  []
print(sum_nested(L))                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>0</cd>
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">_my_out = ""
_my_in = []
_datafiles = {}

# Start of FileLike
class FileLike:
  def __init__(self, contents):
    self.contents = contents
    self.cursor = 0

  def __enter__(self):
    return self

  def __exit__(self, exc_type, exc_value, traceback):
    self.close()

  def tell(self):
    return self.cursor

  def seek(self, n):
    self.cursor = n

  def read(self):
    n = self.cursor
    self.cursor = max(n, len(self.contents))
    return self.contents[n:]

  def readline(self):
    n = self.cursor
    rest = self.contents[n:]
    index = rest.find("\n")
    if index == -1:
      self.cursor = len(self.contents)
      return rest
    index += 1
    self.cursor = n + index
    return rest[:index]

  def readlines(self):
    results = []
    while True:
      line = self.readline()
      if line == '':
        return results
      results.append(line)

  def __iter__(self):
    for l in self.readlines():
      yield l


  def close(self):
    pass

# End of FileLike

def open(fname, mode = "r"):
  """our own open"""
  if fname in _datafiles:
    return FileLike(_datafiles[fname])
  raise BaseException(f"File not found: {fname}")


def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise RuntimeError()
  return _my_in.pop()

None

        </preamble>
        <code>

        </code>
        <postamble visible="no">
        </postamble>
        <tests>import re

RIGHT_WHITESPACE_TRIMMER = re.compile("[ \\t]+?(?=\\n|$)")


from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')

    L = [[5]]
    print(sum_nested(L))

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '5\n'.strip(), "Test: " + 'L = [[5]]\nprint(sum_nested(L))')


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')

    L=[[1,2],[8,7,6]]
    print(sum_nested(L))

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '24\n'.strip(), "Test: " + 'L=[[1,2],[8,7,6]]\nprint(sum_nested(L))')


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')

    L =  []
    print(sum_nested(L))

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '0\n'.strip(), "Test: " + 'L =  []\nprint(sum_nested(L))')


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')

    L = [[5,4],[3,1,1,1,10],[2],[4]]
    print(sum_nested(L))

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '31\n'.strip(), "Test: " + 'L = [[5,4],[3,1,1,1,10],[2],[4]]\nprint(sum_nested(L))')


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')

    L = [[1],[2,3],[-3,-2,-1,0]]
    print(sum_nested(L))

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '0\n'.strip(), "Test: " + 'L = [[1],[2,3],[-3,-2,-1,0]]\nprint(sum_nested(L))')


  def test6(self):
    resetMyStdOut()
    setMyStdIn('')

    L = [[1,1,1],[2,3,2],[5,5,5],[10,11,12,13,14]]
    print(sum_nested(L))

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '85\n'.strip(), "Test: " + 'L = [[1,1,1],[2,3,2],[5,5,5],[10,11,12,13,14]]\nprint(sum_nested(L))')



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-gen_triples-1-practice" label="exe-sec-HW7-1-103575-practice">
      <title>Triplets</title>
      <statement>
        <p>The function <c>gen_triples</c> takes one parameter, <c>L</c>, a list of characters (i.e., strings of length one). The function returns a list of all possible 3-character strings that can be made from the characters in <c>L</c>.</p>
        <p>For example, if <c>L = ['n', 'o']</c>, then <c>gen_triples(L)</c> should return the list:</p>
        <p><c>['nnn', 'nno', 'non',
'noo', 'onn', 'ono', 'oon', 'ooo']</c></p>
        <p>If <c>L</c> is empty, gen_triples returns an empty list.</p>
        <p><alert>Hint:</alert> Use a <alert><em>triple</em></alert><em><alert>nested for loop</alert></em> or a list comprehension to accumulate the list of triples.</p>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="40%" />
          <col top="minor" width="60%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Test</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>L = ['n', 'o']
ans = gen_triples(L)
ans.sort()
print(ans)                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>['nnn', 'nno', 'non', 'noo', 'onn', 'ono', 'oon', 'ooo']</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>L = ['?']
ans = gen_triples(L)
ans.sort()
print(ans)                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>['???']</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>L = []
ans = gen_triples(L)
ans.sort()
print(ans)                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>[]</cd>
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">_my_out = ""
_my_in = []
_datafiles = {}

# Start of FileLike
class FileLike:
  def __init__(self, contents):
    self.contents = contents
    self.cursor = 0

  def __enter__(self):
    return self

  def __exit__(self, exc_type, exc_value, traceback):
    self.close()

  def tell(self):
    return self.cursor

  def seek(self, n):
    self.cursor = n

  def read(self):
    n = self.cursor
    self.cursor = max(n, len(self.contents))
    return self.contents[n:]

  def readline(self):
    n = self.cursor
    rest = self.contents[n:]
    index = rest.find("\n")
    if index == -1:
      self.cursor = len(self.contents)
      return rest
    index += 1
    self.cursor = n + index
    return rest[:index]

  def readlines(self):
    results = []
    while True:
      line = self.readline()
      if line == '':
        return results
      results.append(line)

  def __iter__(self):
    for l in self.readlines():
      yield l


  def close(self):
    pass

# End of FileLike

def open(fname, mode = "r"):
  """our own open"""
  if fname in _datafiles:
    return FileLike(_datafiles[fname])
  raise BaseException(f"File not found: {fname}")


def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise RuntimeError()
  return _my_in.pop()

None

        </preamble>
        <code>
def gen_triples(L):
        </code>
        <postamble visible="no">
        </postamble>
        <tests>import re

RIGHT_WHITESPACE_TRIMMER = re.compile("[ \\t]+?(?=\\n|$)")


from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')

    L = ['n', 'o']
    ans = gen_triples(L)
    ans.sort()
    print(ans)

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), "['nnn', 'nno', 'non', 'noo', 'onn', 'ono', 'oon', 'ooo']\n".strip(), "Test: " + "L = ['n', 'o']\nans = gen_triples(L)\nans.sort()\nprint(ans)")


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')

    L = ['?']
    ans = gen_triples(L)
    ans.sort()
    print(ans)

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), "['???']\n".strip(), "Test: " + "L = ['?']\nans = gen_triples(L)\nans.sort()\nprint(ans)")


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')

    L = []
    ans = gen_triples(L)
    ans.sort()
    print(ans)

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '[]\n'.strip(), "Test: " + 'L = []\nans = gen_triples(L)\nans.sort()\nprint(ans)')


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')

    L = ['x', 'y', 'z', 'w']
    ans = gen_triples(L)
    ans.sort()
    print(ans)

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), "['www', 'wwx', 'wwy', 'wwz', 'wxw', 'wxx', 'wxy', 'wxz', 'wyw', 'wyx', 'wyy', 'wyz', 'wzw', 'wzx', 'wzy', 'wzz', 'xww', 'xwx', 'xwy', 'xwz', 'xxw', 'xxx', 'xxy', 'xxz', 'xyw', 'xyx', 'xyy', 'xyz', 'xzw', 'xzx', 'xzy', 'xzz', 'yww', 'ywx', 'ywy', 'ywz', 'yxw', 'yxx', 'yxy', 'yxz', 'yyw', 'yyx', 'yyy', 'yyz', 'yzw', 'yzx', 'yzy', 'yzz', 'zww', 'zwx', 'zwy', 'zwz', 'zxw', 'zxx', 'zxy', 'zxz', 'zyw', 'zyx', 'zyy', 'zyz', 'zzw', 'zzx', 'zzy', 'zzz']\n".strip(), "Test: " + "L = ['x', 'y', 'z', 'w']\nans = gen_triples(L)\nans.sort()\nprint(ans)")


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')

    L = ['d', 'o', 'g', 's']
    ans = gen_triples(L)
    ans.sort()
    print(ans)

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), "['ddd', 'ddg', 'ddo', 'dds', 'dgd', 'dgg', 'dgo', 'dgs', 'dod', 'dog', 'doo', 'dos', 'dsd', 'dsg', 'dso', 'dss', 'gdd', 'gdg', 'gdo', 'gds', 'ggd', 'ggg', 'ggo', 'ggs', 'god', 'gog', 'goo', 'gos', 'gsd', 'gsg', 'gso', 'gss', 'odd', 'odg', 'odo', 'ods', 'ogd', 'ogg', 'ogo', 'ogs', 'ood', 'oog', 'ooo', 'oos', 'osd', 'osg', 'oso', 'oss', 'sdd', 'sdg', 'sdo', 'sds', 'sgd', 'sgg', 'sgo', 'sgs', 'sod', 'sog', 'soo', 'sos', 'ssd', 'ssg', 'sso', 'sss']\n".strip(), "Test: " + "L = ['d', 'o', 'g', 's']\nans = gen_triples(L)\nans.sort()\nprint(ans)")



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-add_entry_to_dictionary-1-practice" label="exe-sec-HW7-1-32141-practice">
      <title>Add Entry</title>
      <statement>
        <p>The function <c>add_entry</c> takes a dictionary <c>D</c> and two additional parameters, <c>new_key</c> and <c>new_val</c>. The function adds <c>new_key</c> to the dictionary, using <c>new_val</c> for the value of <c>D[new_key]</c>.</p>
        <p><alert>Hint</alert>: <c>add_entry</c> prints nothing and returns nothing; it simply mutates (i.e., changes the value of) D by adding a new key-value pair.</p>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="40%" />
          <col top="minor" width="60%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Test</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>D = {'Hitting Percent': 0.174, 'Blocks': 5.0, 'Digs': 47, 'Aces': 7}
add_entry(D, 'Spikes', 42)
check_answer(D, ('Spikes', 42), 5)                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>correctly added Spikes:42</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>D = {'wins': 9, 'losses': 2}
add_entry(D, 'ties', 1)
check_answer(D, ('ties', 1), 3)                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>correctly added ties:1</cd>
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">_my_out = ""
_my_in = []
_datafiles = {}

# Start of FileLike
class FileLike:
  def __init__(self, contents):
    self.contents = contents
    self.cursor = 0

  def __enter__(self):
    return self

  def __exit__(self, exc_type, exc_value, traceback):
    self.close()

  def tell(self):
    return self.cursor

  def seek(self, n):
    self.cursor = n

  def read(self):
    n = self.cursor
    self.cursor = max(n, len(self.contents))
    return self.contents[n:]

  def readline(self):
    n = self.cursor
    rest = self.contents[n:]
    index = rest.find("\n")
    if index == -1:
      self.cursor = len(self.contents)
      return rest
    index += 1
    self.cursor = n + index
    return rest[:index]

  def readlines(self):
    results = []
    while True:
      line = self.readline()
      if line == '':
        return results
      results.append(line)

  def __iter__(self):
    for l in self.readlines():
      yield l


  def close(self):
    pass

# End of FileLike

def open(fname, mode = "r"):
  """our own open"""
  if fname in _datafiles:
    return FileLike(_datafiles[fname])
  raise BaseException(f"File not found: {fname}")


def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise RuntimeError()
  return _my_in.pop()

def check_answer(D, new_pair, new_size):
    if D[new_pair[0]] == new_pair[1] and len(D) == new_size:
        print("correctly added", str(new_pair[0]) + ":" + str(new_pair[1]))
    else:
        print("error")



        </preamble>
        <code>

        </code>
        <postamble visible="no">
        </postamble>
        <tests>import re

RIGHT_WHITESPACE_TRIMMER = re.compile("[ \\t]+?(?=\\n|$)")


from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')

    D = {'Hitting Percent': 0.174, 'Blocks': 5.0, 'Digs': 47, 'Aces': 7}
    add_entry(D, 'Spikes', 42)
    check_answer(D, ('Spikes', 42), 5)

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'correctly added Spikes:42\n'.strip(), "Test: " + "D = {'Hitting Percent': 0.174, 'Blocks': 5.0, 'Digs': 47, 'Aces': 7}\nadd_entry(D, 'Spikes', 42)\ncheck_answer(D, ('Spikes', 42), 5)")


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')

    D = {'wins': 9, 'losses': 2}
    add_entry(D, 'ties', 1)
    check_answer(D, ('ties', 1), 3)

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'correctly added ties:1\n'.strip(), "Test: " + "D = {'wins': 9, 'losses': 2}\nadd_entry(D, 'ties', 1)\ncheck_answer(D, ('ties', 1), 3)")


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')

    D = {'major1 gpa': 3.7, 'major2 gpa': 3.4, 'credits': 17, 'graduation year': 2022}
    add_entry(D, 'minor', 'Counting Sheep')
    check_answer(D, ('minor', 'Counting Sheep'), 5)

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'correctly added minor:Counting Sheep\n'.strip(), "Test: " + "D = {'major1 gpa': 3.7, 'major2 gpa': 3.4, 'credits': 17, 'graduation year': 2022}\nadd_entry(D, 'minor', 'Counting Sheep')\ncheck_answer(D, ('minor', 'Counting Sheep'), 5)")


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')

    D = {}
    for i in range(11):
        D[i] = i * i
    add_entry(D, 20, 400)
    check_answer(D, (20, 400), 12)

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'correctly added 20:400\n'.strip(), "Test: " + 'D = {}\nfor i in range(11):\n    D[i] = i * i\nadd_entry(D, 20, 400)\ncheck_answer(D, (20, 400), 12)')


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')

    student_ages = {('Steph','Martin'): 4, ('Bobby', 'Roo'): 5, ('Tiffany', 'Roo'): 5,
                   ('Alex', 'Oriole'): 6, ('Sandy', 'Singh'): 4, ('Ida', 'North-West'): 6,
                   ('Mihrimah', 'Suleiman'): 5, ('Kat', 'Mouse'): 4}
    s = ('Felix', 'Dumezweni')
    add_entry(student_ages, s, 6)
    if student_ages[s] == 6 and len(student_ages) == 9:
        print("Woohoo!")
    else:
        print("Oh, noes!")


    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'Woohoo!\n'.strip(), "Test: " + 'student_ages = {(\'Steph\',\'Martin\'): 4, (\'Bobby\', \'Roo\'): 5, (\'Tiffany\', \'Roo\'): 5,\n               (\'Alex\', \'Oriole\'): 6, (\'Sandy\', \'Singh\'): 4, (\'Ida\', \'North-West\'): 6,\n               (\'Mihrimah\', \'Suleiman\'): 5, (\'Kat\', \'Mouse\'): 4}\ns = (\'Felix\', \'Dumezweni\')\nadd_entry(student_ages, s, 6)\nif student_ages[s] == 6 and len(student_ages) == 9:\n    print("Woohoo!")\nelse:\n    print("Oh, noes!")\n')


  def test6(self):
    resetMyStdOut()
    setMyStdIn('')

    D = {}
    add_entry(D, 'wins', 100)
    check_answer(D, ('wins', 100), 1)

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'correctly added wins:100\n'.strip(), "Test: " + "D = {}\nadd_entry(D, 'wins', 100)\ncheck_answer(D, ('wins', 100), 1)")



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-delete_entry_from_dictionary-1-practice" label="exe-sec-HW7-1-32142-practice">
      <title>Delete Entry</title>
      <statement>
        <p>The function <c>delete_entry</c> takes a parameter <c>D</c> (a dictionary) and a parameter <c>k</c> (a supposed key in <c>D</c>).</p>
        <p>
          <ul>
            <li>The function <alert>removes</alert>the entry whose key is <c>k</c> and returns the value that was associated with <c>k</c>.</li>
            <li><em>However</em>, if <c>k</c> is <alert>not</alert>a key in <c>D</c>, the function leaves <c>D</c> unchanged and returns the value <c>None</c>.</li>
          </ul>
        </p>
        <p>Hint: <c>D.pop(k)</c> is helpful here, but first you need to handle the case where k is <alert>not</alert> a key in D. You can search online to learn more, using search string: <em>python dictionary delete item</em></p>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="40%" />
          <col top="minor" width="60%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Test</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>D = {'Hitting Percent': 0.174, 'Blocks': 5.0, 'Digs': 47, 'Aces': 7}
ans = delete_entry(D, 'Digs')
print(ans)

                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>47</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>D = {'wins': 9, 'losses': 2}
ans = delete_entry(D, 'ties')
print(ans)                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>None</cd>
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">_my_out = ""
_my_in = []
_datafiles = {}

# Start of FileLike
class FileLike:
  def __init__(self, contents):
    self.contents = contents
    self.cursor = 0

  def __enter__(self):
    return self

  def __exit__(self, exc_type, exc_value, traceback):
    self.close()

  def tell(self):
    return self.cursor

  def seek(self, n):
    self.cursor = n

  def read(self):
    n = self.cursor
    self.cursor = max(n, len(self.contents))
    return self.contents[n:]

  def readline(self):
    n = self.cursor
    rest = self.contents[n:]
    index = rest.find("\n")
    if index == -1:
      self.cursor = len(self.contents)
      return rest
    index += 1
    self.cursor = n + index
    return rest[:index]

  def readlines(self):
    results = []
    while True:
      line = self.readline()
      if line == '':
        return results
      results.append(line)

  def __iter__(self):
    for l in self.readlines():
      yield l


  def close(self):
    pass

# End of FileLike

def open(fname, mode = "r"):
  """our own open"""
  if fname in _datafiles:
    return FileLike(_datafiles[fname])
  raise BaseException(f"File not found: {fname}")


def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise RuntimeError()
  return _my_in.pop()

None

        </preamble>
        <code>

        </code>
        <postamble visible="no">
        </postamble>
        <tests>import re

RIGHT_WHITESPACE_TRIMMER = re.compile("[ \\t]+?(?=\\n|$)")


from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')

    D = {'Hitting Percent': 0.174, 'Blocks': 5.0, 'Digs': 47, 'Aces': 7}
    ans = delete_entry(D, 'Digs')
    print(ans)



    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '47\n'.strip(), "Test: " + "D = {'Hitting Percent': 0.174, 'Blocks': 5.0, 'Digs': 47, 'Aces': 7}\nans = delete_entry(D, 'Digs')\nprint(ans)\n\n")


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')

    D = {'wins': 9, 'losses': 2}
    ans = delete_entry(D, 'ties')
    print(ans)

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'None\n'.strip(), "Test: " + "D = {'wins': 9, 'losses': 2}\nans = delete_entry(D, 'ties')\nprint(ans)")


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')

    D = {'major1 gpa': 3.7, 'major2 gpa': 3.4, 'credits': 17, 'graduation year': 2022}
    ans = delete_entry(D, 'major2 gpa')
    print(ans)


    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '3.4\n'.strip(), "Test: " + "D = {'major1 gpa': 3.7, 'major2 gpa': 3.4, 'credits': 17, 'graduation year': 2022}\nans = delete_entry(D, 'major2 gpa')\nprint(ans)\n")


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')

    D = {}
    for i in range(10): D[i] = i*i - 1
    ans = delete_entry(D, 12)
    print(ans)



    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'None\n'.strip(), "Test: " + 'D = {}\nfor i in range(10): D[i] = i*i - 1\nans = delete_entry(D, 12)\nprint(ans)\n\n')


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')

    student_ages = {('Steph','Martin'): 4, ('Bobby', 'Roo'): 5, ('Tiffany', 'Roo'): 5,
                   ('Alex', 'Oriole'): 6, ('Sandy', 'Singh'): 4, ('Ida', 'North-West'): 6,
                   ('Mihrimah', 'Suleiman'): 5, ('Kat', 'Mouse'): 4}
    student = ('Steph', 'Martin')
    ans = delete_entry(student_ages, student)
    print(ans)



    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '4\n'.strip(), "Test: " + "student_ages = {('Steph','Martin'): 4, ('Bobby', 'Roo'): 5, ('Tiffany', 'Roo'): 5,\n               ('Alex', 'Oriole'): 6, ('Sandy', 'Singh'): 4, ('Ida', 'North-West'): 6,\n               ('Mihrimah', 'Suleiman'): 5, ('Kat', 'Mouse'): 4}\nstudent = ('Steph', 'Martin')\nans = delete_entry(student_ages, student)\nprint(ans)\n\n")


  def test6(self):
    resetMyStdOut()
    setMyStdIn('')

    student_ages = {('Steph','Martin'): 4, ('Bobby', 'Roo'): 5, ('Tiffany', 'Roo'): 5,
                   ('Alex', 'Oriole'): 6, ('Sandy', 'Singh'): 4, ('Ida', 'North-West'): 6,
                   ('Mihrimah', 'Suleiman'): 5, ('Kat', 'Mouse'): 4}
    student = ('Abe', 'Lincoln')
    ans = delete_entry(student_ages, student)
    print(ans)


    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'None\n'.strip(), "Test: " + "student_ages = {('Steph','Martin'): 4, ('Bobby', 'Roo'): 5, ('Tiffany', 'Roo'): 5,\n               ('Alex', 'Oriole'): 6, ('Sandy', 'Singh'): 4, ('Ida', 'North-West'): 6,\n               ('Mihrimah', 'Suleiman'): 5, ('Kat', 'Mouse'): 4}\nstudent = ('Abe', 'Lincoln')\nans = delete_entry(student_ages, student)\nprint(ans)\n")



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-dictionary_has_key-1-practice" label="exe-sec-HW7-1-32129-practice">
      <title>Has Key</title>
      <statement>
        <p>The function <c>has_key</c> takes two parameters: <c>D</c> and <c>k</c>, where <c>D</c> is a dictionary and <c>k</c> is a possible key in <c>D</c>. The function returns <c>True</c> if <c>k</c> is a <em>key</em> in the dictionary <c>D</c> and <c>False</c> otherwise.</p>
        <p><alert>Hint:</alert>Read up on using the <c>in</c> operator with dictionaries.</p>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="40%" />
          <col top="minor" width="60%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Test</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>D = {'Hitting Percent': 0.174, 'Blocks': 5.0, 'Digs': 47, 'Aces': 7}
print(has_key(D, 'Blocks') == True)
                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>True</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>D = {'Hitting Percent': 0.174, 'Blocks': 5.0, 'Digs': 47, 'Aces': 7}
print(has_key(D, 'Spikes') == True)
                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>False</cd>
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">_my_out = ""
_my_in = []
_datafiles = {}

# Start of FileLike
class FileLike:
  def __init__(self, contents):
    self.contents = contents
    self.cursor = 0

  def __enter__(self):
    return self

  def __exit__(self, exc_type, exc_value, traceback):
    self.close()

  def tell(self):
    return self.cursor

  def seek(self, n):
    self.cursor = n

  def read(self):
    n = self.cursor
    self.cursor = max(n, len(self.contents))
    return self.contents[n:]

  def readline(self):
    n = self.cursor
    rest = self.contents[n:]
    index = rest.find("\n")
    if index == -1:
      self.cursor = len(self.contents)
      return rest
    index += 1
    self.cursor = n + index
    return rest[:index]

  def readlines(self):
    results = []
    while True:
      line = self.readline()
      if line == '':
        return results
      results.append(line)

  def __iter__(self):
    for l in self.readlines():
      yield l


  def close(self):
    pass

# End of FileLike

def open(fname, mode = "r"):
  """our own open"""
  if fname in _datafiles:
    return FileLike(_datafiles[fname])
  raise BaseException(f"File not found: {fname}")


def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise RuntimeError()
  return _my_in.pop()

None

        </preamble>
        <code>

        </code>
        <postamble visible="no">
        </postamble>
        <tests>import re

RIGHT_WHITESPACE_TRIMMER = re.compile("[ \\t]+?(?=\\n|$)")


from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')

    D = {'Hitting Percent': 0.174, 'Blocks': 5.0, 'Digs': 47, 'Aces': 7}
    print(has_key(D, 'Blocks') == True)


    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'True'.strip(), "Test: " + "D = {'Hitting Percent': 0.174, 'Blocks': 5.0, 'Digs': 47, 'Aces': 7}\nprint(has_key(D, 'Blocks') == True)\n")


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')

    D = {'Hitting Percent': 0.174, 'Blocks': 5.0, 'Digs': 47, 'Aces': 7}
    print(has_key(D, 'Spikes') == True)


    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'False'.strip(), "Test: " + "D = {'Hitting Percent': 0.174, 'Blocks': 5.0, 'Digs': 47, 'Aces': 7}\nprint(has_key(D, 'Spikes') == True)\n")


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')

    D = {'major1 gpa': 3.7, 'major2 gpa': 3.4, 'credits': 17, 'graduation year': 2022}
    print(has_key(D, 'credits') == True)

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'True'.strip(), "Test: " + "D = {'major1 gpa': 3.7, 'major2 gpa': 3.4, 'credits': 17, 'graduation year': 2022}\nprint(has_key(D, 'credits') == True)")


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')

    D = {'major1 gpa': 3.7, 'major2 gpa': 3.4, 'credits': 17, 'graduation year': 2022}
    print(has_key(D, 'gpa'))

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'False'.strip(), "Test: " + "D = {'major1 gpa': 3.7, 'major2 gpa': 3.4, 'credits': 17, 'graduation year': 2022}\nprint(has_key(D, 'gpa'))")


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')

    student_ages = {('Steph','Martin'): 4, ('Bobby', 'Roo'): 5, ('Tiffany', 'Roo'): 5,
                   ('Alex', 'Oriole'): 6, ('Sandy', 'Singh'): 4, ('Ida', 'North-West'): 6,
                   ('Mihrimah', 'Suleiman'): 5, ('Kat', 'Mouse'): 4, ('Felix', 'Dumezweni'): 6}
    student = ('Bobby', 'Roo')
    print(has_key(student_ages, student) == True)


    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'True'.strip(), "Test: " + "student_ages = {('Steph','Martin'): 4, ('Bobby', 'Roo'): 5, ('Tiffany', 'Roo'): 5,\n               ('Alex', 'Oriole'): 6, ('Sandy', 'Singh'): 4, ('Ida', 'North-West'): 6,\n               ('Mihrimah', 'Suleiman'): 5, ('Kat', 'Mouse'): 4, ('Felix', 'Dumezweni'): 6}\nstudent = ('Bobby', 'Roo')\nprint(has_key(student_ages, student) == True)\n")


  def test6(self):
    resetMyStdOut()
    setMyStdIn('')

    student_ages = {('Steph','Martin'): 4, ('Bobby', 'Roo'): 5, ('Tiffany', 'Roo'): 5,
                   ('Alex', 'Oriole'): 6, ('Sandy', 'Singh'): 4, ('Ida', 'North-West'): 6,
                   ('Mihrimah', 'Suleiman'): 5, ('Kat', 'Mouse'): 4, ('Felix', 'Dumezweni'): 6}
    student = ('Bobby', 'Nguyen')
    print(has_key(student_ages, student) == True)

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'False'.strip(), "Test: " + "student_ages = {('Steph','Martin'): 4, ('Bobby', 'Roo'): 5, ('Tiffany', 'Roo'): 5,\n               ('Alex', 'Oriole'): 6, ('Sandy', 'Singh'): 4, ('Ida', 'North-West'): 6,\n               ('Mihrimah', 'Suleiman'): 5, ('Kat', 'Mouse'): 4, ('Felix', 'Dumezweni'): 6}\nstudent = ('Bobby', 'Nguyen')\nprint(has_key(student_ages, student) == True)")



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-dictionary_has_value-1-practice" label="exe-sec-HW7-1-160598-practice">
      <title>Has Value</title>
      <statement>
        <p>The function <c>has_value</c> takes two parameters: a dictionary <c>D</c> and a number <c>num</c>. The function returns <c>True</c> if <c>num</c> is a <em>value</em> in dictionary <c>D</c>; otherwise, it returns <c>False</c>.</p>
        <p><alert>Hint:</alert>Remind yourself about the various operators and methods for dictionaries.</p>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="40%" />
          <col top="minor" width="60%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Test</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>D = {'Hitting Percent': 0.174, 'Blocks': 5.0, 'Digs': 47, 'Aces': 7}
print(has_value(D, 47) == True)
                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>True</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>D = {'Hitting Percent': 0.174, 'Blocks': 5.0, 'Digs': 47, 'Aces': 7}
print(has_value(D, 3047) == True)
                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>False</cd>
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">_my_out = ""
_my_in = []
_datafiles = {}

# Start of FileLike
class FileLike:
  def __init__(self, contents):
    self.contents = contents
    self.cursor = 0

  def __enter__(self):
    return self

  def __exit__(self, exc_type, exc_value, traceback):
    self.close()

  def tell(self):
    return self.cursor

  def seek(self, n):
    self.cursor = n

  def read(self):
    n = self.cursor
    self.cursor = max(n, len(self.contents))
    return self.contents[n:]

  def readline(self):
    n = self.cursor
    rest = self.contents[n:]
    index = rest.find("\n")
    if index == -1:
      self.cursor = len(self.contents)
      return rest
    index += 1
    self.cursor = n + index
    return rest[:index]

  def readlines(self):
    results = []
    while True:
      line = self.readline()
      if line == '':
        return results
      results.append(line)

  def __iter__(self):
    for l in self.readlines():
      yield l


  def close(self):
    pass

# End of FileLike

def open(fname, mode = "r"):
  """our own open"""
  if fname in _datafiles:
    return FileLike(_datafiles[fname])
  raise BaseException(f"File not found: {fname}")


def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise RuntimeError()
  return _my_in.pop()

None

        </preamble>
        <code>

        </code>
        <postamble visible="no">
        </postamble>
        <tests>import re

RIGHT_WHITESPACE_TRIMMER = re.compile("[ \\t]+?(?=\\n|$)")


from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')

    D = {'Hitting Percent': 0.174, 'Blocks': 5.0, 'Digs': 47, 'Aces': 7}
    print(has_value(D, 47) == True)


    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'True'.strip(), "Test: " + "D = {'Hitting Percent': 0.174, 'Blocks': 5.0, 'Digs': 47, 'Aces': 7}\nprint(has_value(D, 47) == True)\n")


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')

    D = {'Hitting Percent': 0.174, 'Blocks': 5.0, 'Digs': 47, 'Aces': 7}
    print(has_value(D, 3047) == True)


    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'False'.strip(), "Test: " + "D = {'Hitting Percent': 0.174, 'Blocks': 5.0, 'Digs': 47, 'Aces': 7}\nprint(has_value(D, 3047) == True)\n")


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')

    D = {'major1 gpa': 3.7, 'major2 gpa': 3.4, 'credits': 17, 'graduation year': 2022}
    print(has_value(D, 2022) == True)

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'True'.strip(), "Test: " + "D = {'major1 gpa': 3.7, 'major2 gpa': 3.4, 'credits': 17, 'graduation year': 2022}\nprint(has_value(D, 2022) == True)")


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')

    D = {'major1 gpa': 3.7, 'major2 gpa': 3.4, 'credits': 17, 'graduation year': 2022}
    print(has_value(D, 2020) == True)

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'False'.strip(), "Test: " + "D = {'major1 gpa': 3.7, 'major2 gpa': 3.4, 'credits': 17, 'graduation year': 2022}\nprint(has_value(D, 2020) == True)")


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')

    D = {'major1 gpa': 3.7, 'major2 gpa': 3.4, 'credits': 17, 'graduation year': 2022}
    print(has_value(D, 3.7) == True)

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'True'.strip(), "Test: " + "D = {'major1 gpa': 3.7, 'major2 gpa': 3.4, 'credits': 17, 'graduation year': 2022}\nprint(has_value(D, 3.7) == True)")



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-dictionary_num_pairs-1-practice" label="exe-sec-HW7-1-32126-practice">
      <title>Get Num Pairs</title>
      <statement>
        <p>The function <c>get_num_pairs</c> takes one parameter, <c>D</c>, which is a dictionary. The function returns the <alert>number</alert>of key-value pairs in <c>D</c>.</p>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="40%" />
          <col top="minor" width="60%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Test</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>D = {'Hitting Percent': 0.174, 'Blocks': 5.0, 'Digs': 47, 'Aces': 7}
print(get_num_pairs(D))
                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>4</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>D = {'wins': 9, 'losses': 2}
print(get_num_pairs(D))

                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>2</cd>
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">_my_out = ""
_my_in = []
_datafiles = {}

# Start of FileLike
class FileLike:
  def __init__(self, contents):
    self.contents = contents
    self.cursor = 0

  def __enter__(self):
    return self

  def __exit__(self, exc_type, exc_value, traceback):
    self.close()

  def tell(self):
    return self.cursor

  def seek(self, n):
    self.cursor = n

  def read(self):
    n = self.cursor
    self.cursor = max(n, len(self.contents))
    return self.contents[n:]

  def readline(self):
    n = self.cursor
    rest = self.contents[n:]
    index = rest.find("\n")
    if index == -1:
      self.cursor = len(self.contents)
      return rest
    index += 1
    self.cursor = n + index
    return rest[:index]

  def readlines(self):
    results = []
    while True:
      line = self.readline()
      if line == '':
        return results
      results.append(line)

  def __iter__(self):
    for l in self.readlines():
      yield l


  def close(self):
    pass

# End of FileLike

def open(fname, mode = "r"):
  """our own open"""
  if fname in _datafiles:
    return FileLike(_datafiles[fname])
  raise BaseException(f"File not found: {fname}")


def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise RuntimeError()
  return _my_in.pop()

None

        </preamble>
        <code>

        </code>
        <postamble visible="no">
        </postamble>
        <tests>import re

RIGHT_WHITESPACE_TRIMMER = re.compile("[ \\t]+?(?=\\n|$)")


from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')

    D = {'Hitting Percent': 0.174, 'Blocks': 5.0, 'Digs': 47, 'Aces': 7}
    print(get_num_pairs(D))


    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '4'.strip(), "Test: " + "D = {'Hitting Percent': 0.174, 'Blocks': 5.0, 'Digs': 47, 'Aces': 7}\nprint(get_num_pairs(D))\n")


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')

    D = {'wins': 9, 'losses': 2}
    print(get_num_pairs(D))



    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '2'.strip(), "Test: " + "D = {'wins': 9, 'losses': 2}\nprint(get_num_pairs(D))\n\n")


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')

    D = {'gpa': 3.7, 'credits': 17, 'graduation year': 2022}
    print(get_num_pairs(D))

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '3'.strip(), "Test: " + "D = {'gpa': 3.7, 'credits': 17, 'graduation year': 2022}\nprint(get_num_pairs(D))")


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')

    D = {}
    for i in range(50,101):
        D[chr(i)] = i
    print(get_num_pairs(D))

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '51'.strip(), "Test: " + 'D = {}\nfor i in range(50,101):\n    D[chr(i)] = i\nprint(get_num_pairs(D))')


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')

    student_ages = {('Steph','Martin'): 4, ('Bobby', 'Roo'): 5, ('Tiffany', 'Roo'): 5,
                   ('Alex', 'Oriole'): 6, ('Sandy', 'Singh'): 4, ('Ida', 'North-West'): 6,
                   ('Mihrimah', 'Suleiman'): 5, ('Kat', 'Mouse'): 4, ('Felix', 'Dumezweni'): 6}
    print(get_num_pairs(student_ages))


    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '9'.strip(), "Test: " + "student_ages = {('Steph','Martin'): 4, ('Bobby', 'Roo'): 5, ('Tiffany', 'Roo'): 5,\n               ('Alex', 'Oriole'): 6, ('Sandy', 'Singh'): 4, ('Ida', 'North-West'): 6,\n               ('Mihrimah', 'Suleiman'): 5, ('Kat', 'Mouse'): 4, ('Felix', 'Dumezweni'): 6}\nprint(get_num_pairs(student_ages))\n")


  def test6(self):
    resetMyStdOut()
    setMyStdIn('')

    D = {}
    print(get_num_pairs(D))

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '0'.strip(), "Test: " + 'D = {}\nprint(get_num_pairs(D))')



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-build_dictionary-1-practice" label="exe-sec-HW7-1-161337-practice">
      <title>Build Dictionary</title>
      <statement>
        <p>Define the function <c>build_dictionary</c> which takes two parameters, <c>key_list</c> and <c>value_list</c>.  The function returns a dictionary.</p>
        <p>
          <ul>
            <li>Both lists have the same length.</li>
            <li>The two lists are organized such that each item in <c>key_list</c> can be matched up with the item at the corresponding index in <c>value_list</c> to form a key-value pair for a dictionary.</li>
            <li>For example, if <c>key_list</c> is <c>['a', 'b', 'c']</c> and <c>value_list</c>is <c>['yes', 'no', 'maybe']</c>, then the new dictionary should contain these pairs: <c>'a':'yes', 'b':'no', 'c':'maybe'</c></li>
          </ul>
        </p>
        <p>Implement the function so that it <em><alert>accumulates</alert></em> a new dictionary.</p>
        <p>
          <ol>
            <li>Initialize D to an empty dictionary, <c>{}</c></li>
            <li>Iterate k over an appropriate range of indices</li>
            <li>Inside the loop, update D by giving D a new pair, using <c>key_list[k]</c> and <c>value_list[k]</c></li>
          </ol>
        </p>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="40%" />
          <col top="minor" width="60%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Test</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>key_list = ['Hitting Percent', 'Blocks', 'Digs', 'Aces']
value_list = [0.174, 5.0, 47, 7]
D = build_dictionary(key_list, value_list)
print(D)
                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>{'Hitting Percent': 0.174, 'Blocks': 5.0, 'Digs': 47, 'Aces': 7}</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>key_list = ['wins', 'losses']
value_list = [9, 2]
D = build_dictionary(key_list, value_list)
print(D)                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>{'wins': 9, 'losses': 2}</cd>
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">_my_out = ""
_my_in = []
_datafiles = {}

# Start of FileLike
class FileLike:
  def __init__(self, contents):
    self.contents = contents
    self.cursor = 0

  def __enter__(self):
    return self

  def __exit__(self, exc_type, exc_value, traceback):
    self.close()

  def tell(self):
    return self.cursor

  def seek(self, n):
    self.cursor = n

  def read(self):
    n = self.cursor
    self.cursor = max(n, len(self.contents))
    return self.contents[n:]

  def readline(self):
    n = self.cursor
    rest = self.contents[n:]
    index = rest.find("\n")
    if index == -1:
      self.cursor = len(self.contents)
      return rest
    index += 1
    self.cursor = n + index
    return rest[:index]

  def readlines(self):
    results = []
    while True:
      line = self.readline()
      if line == '':
        return results
      results.append(line)

  def __iter__(self):
    for l in self.readlines():
      yield l


  def close(self):
    pass

# End of FileLike

def open(fname, mode = "r"):
  """our own open"""
  if fname in _datafiles:
    return FileLike(_datafiles[fname])
  raise BaseException(f"File not found: {fname}")


def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise RuntimeError()
  return _my_in.pop()

None

        </preamble>
        <code>

        </code>
        <postamble visible="no">
        </postamble>
        <tests>import re

RIGHT_WHITESPACE_TRIMMER = re.compile("[ \\t]+?(?=\\n|$)")


from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')

    key_list = ['Hitting Percent', 'Blocks', 'Digs', 'Aces']
    value_list = [0.174, 5.0, 47, 7]
    D = build_dictionary(key_list, value_list)
    print(D)


    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), "{'Hitting Percent': 0.174, 'Blocks': 5.0, 'Digs': 47, 'Aces': 7}\n".strip(), "Test: " + "key_list = ['Hitting Percent', 'Blocks', 'Digs', 'Aces']\nvalue_list = [0.174, 5.0, 47, 7]\nD = build_dictionary(key_list, value_list)\nprint(D)\n")


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')

    key_list = ['wins', 'losses']
    value_list = [9, 2]
    D = build_dictionary(key_list, value_list)
    print(D)

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), "{'wins': 9, 'losses': 2}\n".strip(), "Test: " + "key_list = ['wins', 'losses']\nvalue_list = [9, 2]\nD = build_dictionary(key_list, value_list)\nprint(D)")


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')

    key_list = ['major1 gpa', 'major2 gpa', 'credits', 'graduation year']
    value_list = [3.7, 3.4, 17, 2022]
    D = build_dictionary(key_list, value_list)
    print(D)

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), "{'major1 gpa': 3.7, 'major2 gpa': 3.4, 'credits': 17, 'graduation year': 2022}\n".strip(), "Test: " + "key_list = ['major1 gpa', 'major2 gpa', 'credits', 'graduation year']\nvalue_list = [3.7, 3.4, 17, 2022]\nD = build_dictionary(key_list, value_list)\nprint(D)")


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')

    key_list = ['First Years', 'Sophomores', 'Juniors', 'Seniors']
    value_list = [135, 114, 109, 105]
    D = build_dictionary(key_list, value_list)
    print(D)

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), "{'First Years': 135, 'Sophomores': 114, 'Juniors': 109, 'Seniors': 105}\n".strip(), "Test: " + "key_list = ['First Years', 'Sophomores', 'Juniors', 'Seniors']\nvalue_list = [135, 114, 109, 105]\nD = build_dictionary(key_list, value_list)\nprint(D)")


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')

    key_list = [('Steph','Martin'), ('Bobby', 'Roo'), ('Alex', 'Oriole'), ('Mihrimah', 'Suleiman'), ('Felix', 'Dumezweni')]
    value_list = [4, 5, 6, 5, 6]
    D = build_dictionary(key_list, value_list)
    print(D)

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), "{('Steph', 'Martin'): 4, ('Bobby', 'Roo'): 5, ('Alex', 'Oriole'): 6, ('Mihrimah', 'Suleiman'): 5, ('Felix', 'Dumezweni'): 6}\n".strip(), "Test: " + "key_list = [('Steph','Martin'), ('Bobby', 'Roo'), ('Alex', 'Oriole'), ('Mihrimah', 'Suleiman'), ('Felix', 'Dumezweni')]\nvalue_list = [4, 5, 6, 5, 6]\nD = build_dictionary(key_list, value_list)\nprint(D)")


  def test6(self):
    resetMyStdOut()
    setMyStdIn('')

    key_list = ['x', 'a', 'u', 't', 'ww']
    value_list = ['pizza', 'steak', 'sushi', 'dim sum', 'tuna']
    D = build_dictionary(key_list, value_list)
    print(D)
    print(type(D))
    print(D['x'])

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), "{'x': 'pizza', 'a': 'steak', 'u': 'sushi', 't': 'dim sum', 'ww': 'tuna'}\n&lt;class 'dict'&gt;\npizza\n".strip(), "Test: " + "key_list = ['x', 'a', 'u', 't', 'ww']\nvalue_list = ['pizza', 'steak', 'sushi', 'dim sum', 'tuna']\nD = build_dictionary(key_list, value_list)\nprint(D)\nprint(type(D))\nprint(D['x'])")



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-find_frequencies_dictionary_of_list-1-practice" label="exe-sec-HW7-1-103581-practice">
      <title>Accumulate Frequencies Dictionary</title>
      <statement>
        <p>The function <c>get_freq_dict(L)</c> takes a list of integers and <alert>returns</alert>a dictionary D such that for each number x in L, D[x] is the frequency of x in L.</p>
        <p>TO DO: Accumulate D as explained in your textbook. Read up on how to generate a frequency table using a dictionary if the following hint leaves you puzzled.</p>
        <p>Hint: Use the accumulator pattern.</p>
        <p>
          <ol>
            <li>Initialize D to be an empty dictionary: <c>D  = {}</c></li>
            <li>
              <p>
                For each x in L:
                <ul>
                  <li>if x is already a key in D, update the frequency  of x: <c>D[x] = D[x] + 1</c></li>
                  <li>else, make x:1 a new pair in D</li>
                </ul>
              </p>
            </li>
            <li>When the loop has finished, return D.</li>
          </ol>
        </p>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="40%" />
          <col top="minor" width="60%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Test</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>L = [1, 5, 25, 5, 1]
print(get_freq_dict(L))                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>{1: 2, 5: 2, 25: 1}</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>L = [17]
print(get_freq_dict(L))                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>{17: 1}</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>L = [1, 1, 1, 1, 2, 2, 2, 3, 3, 4]
print(get_freq_dict(L))                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>{1: 4, 2: 3, 3: 2, 4: 1}</cd>
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">_my_out = ""
_my_in = []
_datafiles = {}

# Start of FileLike
class FileLike:
  def __init__(self, contents):
    self.contents = contents
    self.cursor = 0

  def __enter__(self):
    return self

  def __exit__(self, exc_type, exc_value, traceback):
    self.close()

  def tell(self):
    return self.cursor

  def seek(self, n):
    self.cursor = n

  def read(self):
    n = self.cursor
    self.cursor = max(n, len(self.contents))
    return self.contents[n:]

  def readline(self):
    n = self.cursor
    rest = self.contents[n:]
    index = rest.find("\n")
    if index == -1:
      self.cursor = len(self.contents)
      return rest
    index += 1
    self.cursor = n + index
    return rest[:index]

  def readlines(self):
    results = []
    while True:
      line = self.readline()
      if line == '':
        return results
      results.append(line)

  def __iter__(self):
    for l in self.readlines():
      yield l


  def close(self):
    pass

# End of FileLike

def open(fname, mode = "r"):
  """our own open"""
  if fname in _datafiles:
    return FileLike(_datafiles[fname])
  raise BaseException(f"File not found: {fname}")


def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise RuntimeError()
  return _my_in.pop()

None

        </preamble>
        <code>

        </code>
        <postamble visible="no">
        </postamble>
        <tests>import re

RIGHT_WHITESPACE_TRIMMER = re.compile("[ \\t]+?(?=\\n|$)")


from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')

    L = [1, 5, 25, 5, 1]
    print(get_freq_dict(L))

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '{1: 2, 5: 2, 25: 1}\n'.strip(), "Test: " + 'L = [1, 5, 25, 5, 1]\nprint(get_freq_dict(L))')


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')

    L = [5, 5, 5, 5, 5, 3]
    print(get_freq_dict(L))

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '{5: 5, 3: 1}\n'.strip(), "Test: " + 'L = [5, 5, 5, 5, 5, 3]\nprint(get_freq_dict(L))')


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')

    L = [17]
    print(get_freq_dict(L))

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '{17: 1}\n'.strip(), "Test: " + 'L = [17]\nprint(get_freq_dict(L))')


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')

    L = list(range(5))
    print(get_freq_dict(L))

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '{0: 1, 1: 1, 2: 1, 3: 1, 4: 1}\n'.strip(), "Test: " + 'L = list(range(5))\nprint(get_freq_dict(L))')


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')

    L = list(range(3))*2 + [3, 4]
    print(get_freq_dict(L))

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '{0: 2, 1: 2, 2: 2, 3: 1, 4: 1}\n'.strip(), "Test: " + 'L = list(range(3))*2 + [3, 4]\nprint(get_freq_dict(L))')


  def test6(self):
    resetMyStdOut()
    setMyStdIn('')

    L = [1, 1, 1, 1, 2, 2, 2, 3, 3, 4]
    print(get_freq_dict(L))

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '{1: 4, 2: 3, 3: 2, 4: 1}\n'.strip(), "Test: " + 'L = [1, 1, 1, 1, 2, 2, 2, 3, 3, 4]\nprint(get_freq_dict(L))')


  def test7(self):
    resetMyStdOut()
    setMyStdIn('')

    print(get_freq_dict([]))

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '{}\n'.strip(), "Test: " + 'print(get_freq_dict([]))')


  def test8(self):
    resetMyStdOut()
    setMyStdIn('')

    L = list(range(3))*3 + [1, 2] + [7, 8, 8]
    print(get_freq_dict(L))

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '{0: 3, 1: 4, 2: 4, 7: 1, 8: 2}\n'.strip(), "Test: " + 'L = list(range(3))*3 + [1, 2] + [7, 8, 8]\nprint(get_freq_dict(L))')



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-dict_find_mode_of_list-1-practice" label="exe-sec-HW7-1-103582-practice">
      <title>Calculate Mode of List (using a dictionary)</title>
      <statement>
        <p>The function <c>get_mode(L)</c> takes one parameter, <alert>L</alert>, a list of integers. <c>get_mode</c> builds a dictionary of frequencies to determine how often each number in the list occurs. Then it returns the <em>mode</em> of the list, that is, the number in L which occurs with the highest frequency.</p>
        <p>For example, <c>get_mode([3, 8, 5, 5, 8, 8])</c> would determine that</p>
        <p>
          <ul>
            <li>3 has frequency 1</li>
            <li>8 has frequency 3</li>
            <li>5 has frequency 2</li>
          </ul>
        </p>
        <p>Because  8 has the highest frequency, <alert>get_mode</alert> would return 8  for this example.</p>
        <p>Note: You may assume that L will not be empty and there will be a single mode in L (no ties for most frequent).</p>
        <p>Tip: Suppose D is a dictionary with integer values. The following code will determine the maximum value in D: <c>max_value = max(D.values())</c></p>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="40%" />
          <col top="minor" width="60%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Test</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>L = [3, 8, 5, 5, 8, 8]
print(get_mode(L))                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>8</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>L = [3, 8, 5, 5, 8, 8, 3, 3, 5, 3, 3]
print(get_mode(L))                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>3</cd>
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">_my_out = ""
_my_in = []
_datafiles = {}

# Start of FileLike
class FileLike:
  def __init__(self, contents):
    self.contents = contents
    self.cursor = 0

  def __enter__(self):
    return self

  def __exit__(self, exc_type, exc_value, traceback):
    self.close()

  def tell(self):
    return self.cursor

  def seek(self, n):
    self.cursor = n

  def read(self):
    n = self.cursor
    self.cursor = max(n, len(self.contents))
    return self.contents[n:]

  def readline(self):
    n = self.cursor
    rest = self.contents[n:]
    index = rest.find("\n")
    if index == -1:
      self.cursor = len(self.contents)
      return rest
    index += 1
    self.cursor = n + index
    return rest[:index]

  def readlines(self):
    results = []
    while True:
      line = self.readline()
      if line == '':
        return results
      results.append(line)

  def __iter__(self):
    for l in self.readlines():
      yield l


  def close(self):
    pass

# End of FileLike

def open(fname, mode = "r"):
  """our own open"""
  if fname in _datafiles:
    return FileLike(_datafiles[fname])
  raise BaseException(f"File not found: {fname}")


def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise RuntimeError()
  return _my_in.pop()

None

        </preamble>
        <code>

        </code>
        <postamble visible="no">
        </postamble>
        <tests>import re

RIGHT_WHITESPACE_TRIMMER = re.compile("[ \\t]+?(?=\\n|$)")


from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')

    L = [3, 8, 5, 5, 8, 8]
    print(get_mode(L))

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '8\n'.strip(), "Test: " + 'L = [3, 8, 5, 5, 8, 8]\nprint(get_mode(L))')


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')

    L = [3, 8, 5, 5, 8, 8, 3, 3, 5, 3, 3]
    print(get_mode(L))

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '3\n'.strip(), "Test: " + 'L = [3, 8, 5, 5, 8, 8, 3, 3, 5, 3, 3]\nprint(get_mode(L))')


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')

    L = [-5, 10, -4, 10, -3]
    print(get_mode(L))

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '10'.strip(), "Test: " + 'L = [-5, 10, -4, 10, -3]\nprint(get_mode(L))')


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')

    L = [-5]
    print(get_mode(L))

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '-5\n'.strip(), "Test: " + 'L = [-5]\nprint(get_mode(L))')


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')

    L = [4, 3, 4]
    print(get_mode(L))

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '4\n'.strip(), "Test: " + 'L = [4, 3, 4]\nprint(get_mode(L))')


  def test6(self):
    resetMyStdOut()
    setMyStdIn('')

    L = list(range(20))+[17,17]+list(range(20))
    print(get_mode(L))

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '17\n'.strip(), "Test: " + 'L = list(range(20))+[17,17]+list(range(20))\nprint(get_mode(L))')



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-Counting-by-k-1-practice" label="exe-sec-HW7-1-160712-practice">
      <title>Counting by k</title>
      <statement>
        <p>Write a 6-line Python script (not a function definition). The purpose of the program is to read a positive integer n from standard input and then show how to "count by k" for k = 0, 1, 2, ..., n.</p>
        <p>Hint: Use a nested for loop.</p>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="30%" />
          <col top="minor" width="70%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Input</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>3
                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>Counting by: 0
0 0 0 0 0 0 0
Counting by: 1
0 1 2 3 4 5 6
Counting by: 2
0 2 4 6 8 10 12
Counting by: 3
0 3 6 9 12 15 18                </cd>
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">_my_out = ""
_my_in = []
_datafiles = {}

# Start of FileLike
class FileLike:
  def __init__(self, contents):
    self.contents = contents
    self.cursor = 0

  def __enter__(self):
    return self

  def __exit__(self, exc_type, exc_value, traceback):
    self.close()

  def tell(self):
    return self.cursor

  def seek(self, n):
    self.cursor = n

  def read(self):
    n = self.cursor
    self.cursor = max(n, len(self.contents))
    return self.contents[n:]

  def readline(self):
    n = self.cursor
    rest = self.contents[n:]
    index = rest.find("\n")
    if index == -1:
      self.cursor = len(self.contents)
      return rest
    index += 1
    self.cursor = n + index
    return rest[:index]

  def readlines(self):
    results = []
    while True:
      line = self.readline()
      if line == '':
        return results
      results.append(line)

  def __iter__(self):
    for l in self.readlines():
      yield l


  def close(self):
    pass

# End of FileLike

def open(fname, mode = "r"):
  """our own open"""
  if fname in _datafiles:
    return FileLike(_datafiles[fname])
  raise BaseException(f"File not found: {fname}")


def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise RuntimeError()
  return _my_in.pop()

None


_program = """
        </preamble>
        <code>

        </code>
        <postamble visible="no">

"""
        </postamble>
        <tests>import re

RIGHT_WHITESPACE_TRIMMER = re.compile("[ \\t]+?(?=\\n|$)")


from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('3\n')

    exec(_program)

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), RIGHT_WHITESPACE_TRIMMER.sub("",'Counting by: 0\n0 0 0 0 0 0 0\nCounting by: 1\n0 1 2 3 4 5 6 \nCounting by: 2\n0 2 4 6 8 10 12 \nCounting by: 3\n0 3 6 9 12 15 18 \n').strip(), "Input: " + '3\n')


  def test2(self):
    resetMyStdOut()
    setMyStdIn('4')

    exec(_program)

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), RIGHT_WHITESPACE_TRIMMER.sub("",'Counting by: 0\n0 0 0 0 0 0 0 \nCounting by: 1\n0 1 2 3 4 5 6 \nCounting by: 2\n0 2 4 6 8 10 12 \nCounting by: 3\n0 3 6 9 12 15 18 \nCounting by: 4\n0 4 8 12 16 20 24 ').strip(), "Input: " + '4')


  def test3(self):
    resetMyStdOut()
    setMyStdIn('5\n')

    exec(_program)

    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), RIGHT_WHITESPACE_TRIMMER.sub("",'Counting by: 0\n0 0 0 0 0 0 0 \nCounting by: 1\n0 1 2 3 4 5 6 \nCounting by: 2\n0 2 4 6 8 10 12 \nCounting by: 3\n0 3 6 9 12 15 18 \nCounting by: 4\n0 4 8 12 16 20 24 \nCounting by: 5\n0 5 10 15 20 25 30 \n').strip(), "Input: " + '5\n')



myTests().main()        </tests>
      </program>
    </exercise>
  </exercises>
</section>
