<section xml:id="sec-HW10-PRACTICE-1">
  <title>HW10 PRACTICE</title>
  <introduction>
    <p dir="ltr">- Ungraded Assignment</p>
  </introduction>
  <exercises>
    <exercise xml:id="exer-defining_classes_intro-2" label="exe-sec-HW10-PRACTICE-1-271604">
      <title>Defining Classes</title>
      <statement correct="yes">
        <p>Previously, you have used built-in types in Python like <c>dict</c>, <c>str</c>, and <c>list</c>. Each of these types comes with its own methods, such as <c>keys</c>, <c>lower</c>, and <c>append</c>.</p>
        <p>Every object has a <alert>type</alert>that indicates which class the object belongs to. The purpose of the class definition is to specify the instance variables (aka data, attributes) and methods (aka functions) that each object belonging to the class will have.</p>
        <p>For example, in real life, every <alert>car</alert>has attributes such as make, model, and current odometer. And every reasonable car has available methods such as start engine, shift transmission, and honk horn.</p>
        <p>Our goal in this assignment is to learn how to <em>create new data types</em> by defining our own classes.</p>
      </statement>
    </exercise>
    <exercise xml:id="exer-pogil_1a_classname-2" label="exe-sec-HW10-PRACTICE-1-271605">
      <statement>
        <p>What is the <alert>name</alert>of the class being defined here:</p>
        <pre>
# sentenceclass.py

class Sentence:
    def __init__(self, chars):
        # store the chars in an instance variable
        self.chars = chars
        
    def getChars(self):
        return self.chars
    
    def setChars(self, newChars):
        self.chars = newChars
        </pre>
        <fillin answer="Sentence" width="16" />
      </statement>
      <evaluation>
        <evaluate>
          <test correct="yes">
            <strcmp>Sentence</strcmp>
            <feedback />
          </test>
          <test>
            <strcmp>sentence</strcmp>
            <feedback>
              <p>Spell it exactly right, including capitalization.</p>
            </feedback>
          </test>
        </evaluate>
      </evaluation>
    </exercise>
    <exercise xml:id="exer-pogil_1b_methods-2" label="exe-sec-HW10-PRACTICE-1-271606">
      <statement>
        <p>How many <alert>methods</alert>are in the class being defined here:</p>
        <pre>
# sentenceclass.py

class Sentence:
    def __init__(self, chars):
        # store the chars in an instance variable
        self.chars = chars
        
    def getChars(self):
        return self.chars
    
    def setChars(self, newChars):
        self.chars = newChars
        </pre>
        <fillin answer="3.0" width="16" />
      </statement>
      <evaluation>
        <evaluate>
          <test correct="yes">
            <numcmp tolerance="0.0" value="3.0" />
            <feedback>
              <p>Correct! The three methods are <alert>__init__, getChars, setChars</alert>.</p>
            </feedback>
          </test>
        </evaluate>
      </evaluation>
    </exercise>
    <exercise xml:id="exer-pogil_1c_self-2" label="exe-sec-HW10-PRACTICE-1-271608">
      <statement>
        <p>Here is a <c>Length</c> class definition. What is the <alert>name of the first parameter</alert> in all the instance method definitions for a Python class?</p>
        <pre>
class Length:
    def __init__(self, quantity, unit):
        # A Length object has a quantity (numerical) and a unit label (string).
        # The unit will be one of these: 'inches', 'yards'
        self.quantity = quantity
        self.unit = unit
    
    def has_unit(self, some_unit):
        # return True if the Length object's unit label is
        # the same as some_unit, otherwise False
        return self.unit == some_unit
    
    def convert_to(self, new_unit):
        # convert this Length object to the new unit
        if self.has_unit('inches') and new_unit == 'yards':
            self.quantity = self.quantity / 36
            self.unit = new_unit
        elif self.has_unit('yards') and new_unit == 'inches':
            self.quantity = self.quantity * 36
            self.unit = new_unit
            
    def __str__(self):
        # return a string for printing the Length object information
        rounded_quantity = round(self.quantity, 3)
        return f'{rounded_quantity} {self.unit}'
        </pre>
        <fillin answer="self" width="16" />
      </statement>
      <evaluation>
        <evaluate>
          <test correct="yes">
            <strcmp>self</strcmp>
            <feedback>
              <p>Correct. The first parameter, <c>self</c>, refers to the Length object which activated the method.</p>
            </feedback>
          </test>
          <test>
            <strcmp>Self</strcmp>
            <feedback>
              <p>Spell it exactly right, including capitalization.</p>
            </feedback>
          </test>
        </evaluate>
      </evaluation>
    </exercise>
    <exercise xml:id="exer-pogil_2a_main_num_objects-2" label="exe-sec-HW10-PRACTICE-1-271610">
      <statement>
        <p>In the code block below, how many different <c>Sentence</c>objects are created by activating the class constructor?</p>
        <pre>
if __name__ == "__main__":
    greeting = Sentence("Hi")
    question = Sentence("How are you doing today?")
    mystr = question.getChars()
    name = Sentence("My name is Tina")
    name.setChars("My name is Tony")
    another = Sentence("Did you see 'Turning Red'?")
        </pre>
        <fillin answer="4.0" width="16" />
      </statement>
      <evaluation>
        <evaluate>
          <test correct="yes">
            <numcmp tolerance="0.0" value="4.0" />
            <feedback>
              <p>Correct! The four Sentence objects are<alert>greeting, question, name, and another.</alert></p>
            </feedback>
          </test>
        </evaluate>
      </evaluation>
    </exercise>
    <exercise xml:id="exer-pogil_2d_method_parameters-2" label="exe-sec-HW10-PRACTICE-1-271611">
      <statement>
        <p><alert>How many parameters</alert> does the <c>convert_to</c> method have?</p>
        <pre>
def convert_to(self, new_unit):
    # convert this Length object to the new unit
    if self.has_unit('inches') and new_unit == 'yards':
        self.quantity = self.quantity / 36
        self.unit = new_unit
    elif self.has_unit('yards') and new_unit == 'inches':
        self.quantity = self.quantity * 36
        self.unit = new_unit
        </pre>
        <fillin answer="2.0" width="16" />
      </statement>
      <evaluation>
        <evaluate>
          <test correct="yes">
            <numcmp tolerance="0.0" value="2.0" />
            <feedback>
              <p>Correct! The two parameters are <c>self</c>and <c>new_unit</c>.</p>
            </feedback>
          </test>
        </evaluate>
      </evaluation>
    </exercise>
    <exercise xml:id="exer-pogil_2e_method_call_arguments-2" label="exe-sec-HW10-PRACTICE-1-271612">
      <statement>
        <p>Notice that the <c>convert_to</c> method is called twice in the code block below. What is the number of <alert>arguments</alert> for a <c>convert_to</c> method call?</p>
        <c><pre>if __name__ == "__main__":
    football_field = Length(100, 'yards')
    print("Length of a football field:", football_field)
    football_field.convert_to("inches")
    print("Length of a football field:", football_field)
    
    rattler = Length(38, "inches")
    print("Length of a female black-tailed rattler:", rattler)
    rattler.convert_to("yards")
    print("Length of a female black-tailed rattler:", rattler)</pre></c><fillin answer="1.0" width="16" />
      </statement>
      <evaluation>
        <evaluate>
          <test correct="yes">
            <numcmp tolerance="0.0" value="1.0" />
            <feedback>
              <p>Correct! When we call convert_to on a Length object, we provide one argument, the new_unit.</p>
            </feedback>
          </test>
        </evaluate>
      </evaluation>
    </exercise>
    <exercise xml:id="exer-pogil_2f_arguments_vs_parameters-2" label="exe-sec-HW10-PRACTICE-1-32326">
      <statement>
        <p>Based on your previous answers, how does the number of arguments for each method <em>call</em><alert>differ from</alert> the number of parameters specified in the method's <em>definition</em>?</p>
      </statement>
      <choices multiple-correct="no" randomize="yes">
        <choice correct="yes">
          <statement>
            <p>
              <p>There is one less argument.</p>
            </p>
          </statement>
          <feedback>
            <p>Yes! We do not provide an argument for the "self" parameter.</p>
          </feedback>
        </choice>
        <choice correct="no">
          <statement>
            <p>
              <p>There is no difference.</p>
            </p>
          </statement>
          <feedback>
            <p>Review your answers to the previous two questions.</p>
          </feedback>
        </choice>
        <choice correct="no">
          <statement>
            <p>
              <p>There is one less parameter.</p>
            </p>
          </statement>
          <feedback>
            <p>Review your answers to the previous two questions.</p>
          </feedback>
        </choice>
      </choices>
    </exercise>
    <exercise xml:id="exer-timer_class-multi1-2" label="exe-sec-HW10-PRACTICE-1-271613">
      <title>Initializing New Instances of the Class</title>
      <statement>
        <p>Consider the following class definition.</p>
        <pre>  class Timer:
      """ A class that represents a timer. """
      def __init__(self):
          self.hours = 0
          self.minutes = 0
          self.seconds = 0

      def print_with_labels(self):
          print('Hours:', self.hours, end=' ')
          print('Minutes:', self.minutes, end=' ')
          print('Seconds:', self.seconds)

      def __str__(self):
          return f'{self.hours}:{self.minutes}:{self.seconds}'
        </pre>
        <p>Which of these methods is responsible for initializing the instance variables (attributes) of a new instance?</p>
      </statement>
      <choices multiple-correct="no" randomize="yes">
        <choice correct="yes">
          <statement>
            <p>
              <p><c>__init__</c></p>
            </p>
          </statement>
          <feedback />
        </choice>
        <choice correct="no">
          <statement>
            <p>
              <p><c>__str__</c></p>
            </p>
          </statement>
          <feedback />
        </choice>
        <choice correct="no">
          <statement>
            <p>
              <p><c>print_with_labels</c></p>
            </p>
          </statement>
          <feedback />
        </choice>
      </choices>
    </exercise>
    <exercise xml:id="exer-timer_class-multi2-2" label="exe-sec-HW10-PRACTICE-1-271614">
      <title>Creating Objects</title>
      <statement>
        <p>Consider the following class definition.</p>
        <pre>  class Timer:
      """ A class that represents a timer. """
      def __init__(self):
          self.hours = 0
          self.minutes = 0
          self.seconds = 0

      def print_with_labels(self):
          print('Hours:', self.hours, end=' ')
          print('Minutes:', self.minutes, end=' ')
          print('Seconds:', self.seconds)

      def __str__(self):
          return f'{self.hours}:{self.minutes}:{self.seconds}'
        </pre>
        <p>Which of the following lines of code will create a new Timer object set to 0 seconds, 0 minutes, and 0 hours, and assign it to the variable <c>timer1</c>?</p>
      </statement>
      <choices multiple-correct="no" randomize="yes">
        <choice correct="yes">
          <statement>
            <p>
              <p><c>timer1 = Timer()</c></p>
            </p>
          </statement>
          <feedback />
        </choice>
        <choice correct="no">
          <statement>
            <p>
              <p><c>timer1 = Timer(0, 0, 0)</c></p>
            </p>
          </statement>
          <feedback />
        </choice>
        <choice correct="no">
          <statement>
            <p>
              <p><c>timer1.__init__(self)</c></p>
            </p>
          </statement>
          <feedback />
        </choice>
        <choice correct="no">
          <statement>
            <p>
              <p><c>timer1.Timer()</c></p>
            </p>
          </statement>
          <feedback />
        </choice>
        <choice correct="no">
          <statement>
            <p>
              <p><c>timer1.Timer(0, 0, 0)</c></p>
            </p>
          </statement>
          <feedback />
        </choice>
        <choice correct="no">
          <statement>
            <p>
              <p><c>timer1.__init__()</c></p>
            </p>
          </statement>
          <feedback />
        </choice>
      </choices>
    </exercise>
    <exercise xml:id="exer-timer_class-multi4-2" label="exe-sec-HW10-PRACTICE-1-271615">
      <title>Calling Methods 1</title>
      <statement>
        <p>Consider the following class definition.</p>
        <pre>  class Timer:
      """ A class that represents a timer. """
      def __init__(self):
          self.hours = 0
          self.minutes = 0
          self.seconds = 0

      def print_with_labels(self):
          print('Hours:', self.hours, end=' ')
          print('Minutes:', self.minutes, end=' ')
          print('Seconds:', self.seconds)

      def __str__(self):
          return f'{self.hours}:{self.minutes}:{self.seconds}'
        </pre>
        <p><alert>Recall:</alert> The <c>__str__</c>method returns the string representation of the object. This method is activated (automatically!) whenever <c>print()</c> or <alert><c>str</c><c>()</c></alert> is invoked on an object. (Like all the other methods whose names are surrounded by double underscores (<c>__</c>), we never call <c>__str__</c> directly.  It is there, waiting to "answer the call" when we ask to <c>print</c> an object or use <c>str()</c>to convert an object to a string.)</p>
        <p><alert>Question:</alert> What output will be produced when the following lines of code are executed?</p>
        <pre>    t2 = Timer()
    t2.minutes = 7
    t2.seconds = 15
    print(t2)
        </pre>
      </statement>
      <choices multiple-correct="no" randomize="yes">
        <choice correct="yes">
          <statement>
            <p>
              <p><c>0:7:15</c></p>
            </p>
          </statement>
          <feedback />
        </choice>
        <choice correct="no">
          <statement>
            <p>
              <p><c>0 7 15</c></p>
            </p>
          </statement>
          <feedback />
        </choice>
        <choice correct="no">
          <statement>
            <p>
              <p><c>Hours: 0 Minutes: 7 Seconds: 15</c></p>
            </p>
          </statement>
          <feedback />
        </choice>
        <choice correct="no">
          <statement>
            <p>
              <p><alert><c>Hours: 15</c><c>Minutes: 7 Seconds: 0</c></alert></p>
            </p>
          </statement>
          <feedback />
        </choice>
        <choice correct="no">
          <statement>
            <p>
              <p><c>15:7:0</c></p>
            </p>
          </statement>
          <feedback />
        </choice>
        <choice correct="no">
          <statement>
            <p>
              <p><c>15  7  0</c></p>
            </p>
          </statement>
          <feedback />
        </choice>
      </choices>
    </exercise>
    <exercise xml:id="exer-timer_class-multi3-2" label="exe-sec-HW10-PRACTICE-1-271616">
      <title>Setting Attributes</title>
      <statement>
        <p>Consider the following class definition.</p>
        <pre>  class Timer:
      """ A class that represents a timer. """
      def __init__(self):
          self.hours = 0
          self.minutes = 0
          self.seconds = 0
      
      def set_hours(self, h):
          self.hours = h
          
      def set_minutes(self, m):
          self.minutes = m
          
      def set_seconds(self, s):
          self.seconds = s

      def print_with_labels(self):
          print('Hours:', self.hours, end=' ')
          print('Minutes:', self.minutes, end=' ')
          print('Seconds:', self.seconds)

      def __str__(self):
          return f'{self.hours}:{self.minutes}:{self.seconds}'        </pre>
        <p>What output will be produced when the following lines of code are executed?</p>
        <pre>      t1 = Timer()
      t1.set_hours(7)
      print(t1)
        </pre>
      </statement>
      <choices multiple-correct="no" randomize="yes">
        <choice correct="yes">
          <statement>
            <p>
              <p><c>7:0:0</c></p>
            </p>
          </statement>
          <feedback />
        </choice>
        <choice correct="no">
          <statement>
            <p>
              <p><c>7  0 0</c></p>
            </p>
          </statement>
          <feedback />
        </choice>
        <choice correct="no">
          <statement>
            <p>
              <p><c>0:0:7</c></p>
            </p>
          </statement>
          <feedback />
        </choice>
        <choice correct="no">
          <statement>
            <p><c>0 0 7</c></p>
          </statement>
          <feedback />
        </choice>
      </choices>
    </exercise>
    <exercise xml:id="exer-timer_class-multi5-2" label="exe-sec-HW10-PRACTICE-1-271617">
      <title>Calling Methods 2</title>
      <statement>
        <p>Consider the following class definition.</p>
        <pre>  class Timer:
      """ A class that represents a timer. """
      def __init__(self):
          self.hours = 0
          self.minutes = 0
          self.seconds = 0
      
      def set_hours(self, h):
          self.hours = h
          
      def set_minutes(self, m):
          self.minutes = m
          
      def set_seconds(self, s):
          self.seconds = s

      def print_with_labels(self):
          print('Hours:', self.hours, end=' ')
          print('Minutes:', self.minutes, end=' ')
          print('Seconds:', self.seconds)

      def __str__(self):
          return f'{self.hours}:{self.minutes}:{self.seconds}'        </pre>
        <p>What output will be produced when the following lines of code are executed?</p>
        <pre>    t2 = Timer()
    t2.set_hours(14)
    t2.set_minutes(55)
    t2.set_minutes(27)
    t2.print_with_labels()
        </pre>
      </statement>
      <choices multiple-correct="no" randomize="yes">
        <choice correct="no">
          <statement>
            <p>
              <p><c>14:27:0</c></p>
            </p>
          </statement>
          <feedback />
        </choice>
        <choice correct="no">
          <statement>
            <p>
              <p><c>14:55:27</c></p>
            </p>
          </statement>
          <feedback />
        </choice>
        <choice correct="yes">
          <statement>
            <p>
              <p><c>Hours: 14 Minutes: 27 Seconds: 0</c></p>
            </p>
          </statement>
          <feedback />
        </choice>
        <choice correct="no">
          <statement>
            <p>
              <p><c>Hours: 14 Minutes: 55 Seconds: 27</c></p>
            </p>
          </statement>
          <feedback />
        </choice>
        <choice correct="no">
          <statement>
            <p>
              <p><c>Hours: 15 Minutes: 22 Seconds: 0</c></p>
            </p>
          </statement>
          <feedback />
        </choice>
        <choice correct="no">
          <statement>
            <p>
              <p><c>15:22:0</c></p>
            </p>
          </statement>
          <feedback />
        </choice>
      </choices>
    </exercise>
    <exercise xml:id="exer-timer_class-multi6-2" label="exe-sec-HW10-PRACTICE-1-271619">
      <title>Writing Methods</title>
      <statement>
        <p>Consider the following class definition.</p>
        <pre>  class Timer:
      """ A class that represents a timer. """
      def __init__(self):
          self.hours = 0
          self.minutes = 0
          self.seconds = 0

      def print_with_labels(self):
          print('Hours:', self.hours, end=' ')
          print('Minutes:', self.minutes, end=' ')
          print('Seconds:', self.seconds)

      def __str__(self):
          return f'{self.hours}:{self.minutes}:{self.seconds}'        </pre>
        <p>Which of the following is the correct definition for a new <c>Timer</c> class method called <c>set</c> that will take three integer values representing hours, minutes, and seconds and set the object's instance variables (attributes) appropriately?</p>
      </statement>
      <choices multiple-correct="no" randomize="yes">
        <choice correct="yes">
          <statement>
            <p>
              <pre>def set(self, h, m, s):
    self.hours = h
    self.minutes = m
    self.seconds = s              </pre>
            </p>
          </statement>
          <feedback />
        </choice>
        <choice correct="no">
          <statement>
            <p>
              <pre>def set(h, m, s):
    self.hours = h
    self.minutes = m
    self.seconds = s              </pre>
            </p>
          </statement>
          <feedback>
            <p>Remember, when writing a method for a class, you always need to include <c>self</c> as the first parameter.</p>
          </feedback>
        </choice>
        <choice correct="no">
          <statement>
            <p>
              <pre>def set(self):
    self.hours = h
    self.minutes = m
    self.seconds = s              </pre>
            </p>
          </statement>
          <feedback>
            <p>To be able give new values to the object's <c>hours</c> and <c>minutes</c>, you give the method parameters to hold those values.</p>
          </feedback>
        </choice>
        <choice correct="no">
          <statement>
            <p>
              <pre>def set(self, h, m, s):
    hours = h
    minutes = m
    seconds = s              </pre>
            </p>
          </statement>
          <feedback>
            <p>You need to assign the new values to the object's attributes.</p>
          </feedback>
        </choice>
      </choices>
    </exercise>
    <exercise xml:id="exer-timer_class-call_set_short-2" label="exe-sec-HW10-PRACTICE-1-271620">
      <title>Calling the Set Method</title>
      <statement>
        <p>Consider the following class definition.</p>
        <pre>  class Timer:
      """ A class that represents a timer. """
      def __init__(self):
          self.hours = 0
          self.minutes = 0
          self.seconds = 0

      def print_with_labels(self):
          print('Hours:', self.hours, end=' ')
          print('Minutes:', self.minutes, end=' ')
          print('Seconds:', self.seconds)

      def __str__(self):
          return f'{self.hours}:{self.minutes}:{self.seconds}'        </pre>
        <p>Suppose <c>t1</c> is a newly created instance of the the <c>Timer</c> class (i.e., a <c>Timer</c> object). Give the line of code that will call the <c>set</c> method, as described in the previous question, to set <c>t1</c> to 5 hours, 17 minutes, 51 seconds.</p>
        <fillin answer="t1.set(5, 17, 51)" width="16" />
      </statement>
      <evaluation>
        <evaluate>
          <test correct="yes">
            <strcmp>t1.set(5, 17, 51)</strcmp>
            <feedback />
          </test>
          <test>
            <strcmp>t1.set(5,17,51)</strcmp>
            <feedback />
          </test>
          <test>
            <strcmp>t1.set(5, 17,51)</strcmp>
            <feedback />
          </test>
          <test>
            <strcmp>t1.set(5,17, 51)</strcmp>
            <feedback />
          </test>
        </evaluate>
      </evaluation>
    </exercise>
    <exercise xml:id="exer-timer_class-convert_to_seconds_method-2" label="exe-sec-HW10-PRACTICE-1-271622">
      <title>Convert to Seconds</title>
      <statement>
        <p>Implement a method for the Timer class, <c>convert_to_seconds</c>. For a given Timer, the method returns the equivalent number of seconds. For example, if Timer <c>t1</c> is currently set to 0:1:15 (0 hours, 1 minute, 15 seconds), then the call <c>t1.convert_to_seconds()</c> will return 75.</p>
        <p>Hint: Remember that inside the body of the convert_to_seconds method definition, we use the parameter <c>self</c>to refer to the <c>Timer</c>object which activated the method.</p>
        <p>The <c>Timer</c> class definition is given below for reference.</p>
        <pre>    class Timer:
        """ A class that represents a timer. """
        def __init__(self, h, m, s):
            self.hours = h
            self.minutes = m
            self.seconds = s

        def print_with_labels(self):
            print('Hours:', self.hours, end=' ')
            print('Minutes:', self.minutes, end=' ')
            print('Seconds:', self.seconds)

        def __str__(self):
            return f'{self.hours}:{self.minutes}:{self.seconds}'        </pre>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="40%" />
          <col top="minor" width="60%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Test</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>timer1 = Timer(0, 5, 30)
ans = timer1.convert_to_seconds()
print(ans)                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>330</cd>
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">_my_out = ""
_my_in = []
_datafiles = {}

# Start of FileLike
class FileLike:
  def __init__(self, contents):
    self.contents = contents
    self.cursor = 0

  def __enter__(self):
    return self

  def __exit__(self, exc_type, exc_value, traceback):
    self.close()

  def tell(self):
    return self.cursor

  def seek(self, n):
    self.cursor = n

  def read(self):
    n = self.cursor
    self.cursor = max(n, len(self.contents))
    return self.contents[n:]

  def readline(self):
    n = self.cursor
    rest = self.contents[n:]
    index = rest.find("\n")
    if index == -1:
      self.cursor = len(self.contents)
      return rest
    index += 1
    self.cursor = n + index
    return rest[:index]

  def readlines(self):
    results = []
    while True:
      line = self.readline()
      if line == '':
        return results
      results.append(line)

  def close(self):
    pass

# End of FileLike

def open(fname, mode = "r"):
  """our own open"""
  if fname in _datafiles:
    return FileLike(_datafiles[fname])
  raise BaseException(f"File not found: {fname}")


def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise EOFError()
  return _my_in.pop()

class Timer:
    """ A class that represents a timer. """
    def __init__(self, h, m, s):
        self.hours = h
        self.minutes = m
        self.seconds= s

    def print_with_labels(self):
        print('Hours:', self.hours, end=' ')
        print('Minutes:', self.minutes, end=' ')
        print('Seconds:', self.seconds)

    def __str__(self):
        return f'{self.hours}:{self.minutes}:{self.seconds}'
    


        </preamble>
        <code>
# NOTE: Do not change the indentation! It is required because the
# code will be pasted into the Timer class definition body.
    def convert_to_seconds(self):
        </code>
        <postamble visible="no">
        </postamble>
        <tests>import re

RIGHT_WHITESPACE_TRIMMER = re.compile("\\s+(?=\\n|$)")


from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')
    
    timer1 = Timer(0, 5, 30)
    ans = timer1.convert_to_seconds()
    print(ans)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '330\n'.strip(), "Test: " + 'timer1 = Timer(0, 5, 30)\nans = timer1.convert_to_seconds()\nprint(ans)')


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')
    
    timer1 = Timer(0, 5, 30)
    ans = timer1.convert_to_seconds()
    print(ans)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '330\n'.strip(), "Test: " + 'timer1 = Timer(0, 5, 30)\nans = timer1.convert_to_seconds()\nprint(ans)')


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')
    
    timer1 = Timer(0, 55, 30)
    ans = timer1.convert_to_seconds()
    print(ans)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '3330\n'.strip(), "Test: " + 'timer1 = Timer(0, 55, 30)\nans = timer1.convert_to_seconds()\nprint(ans)')


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')
    
    timer1 = Timer(14, 40, 30)
    ans = timer1.convert_to_seconds()
    print(ans)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '52830\n'.strip(), "Test: " + 'timer1 = Timer(14, 40, 30)\nans = timer1.convert_to_seconds()\nprint(ans)')


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')
    
    timer1 = Timer(1, 2, 3)
    ans = timer1.convert_to_seconds()
    print(ans)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '3723\n'.strip(), "Test: " + 'timer1 = Timer(1, 2, 3)\nans = timer1.convert_to_seconds()\nprint(ans)')


  def test6(self):
    resetMyStdOut()
    setMyStdIn('')
    
    timer1 = Timer(10, 45, 59)
    ans = timer1.convert_to_seconds()
    print(ans)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '38759\n'.strip(), "Test: " + 'timer1 = Timer(10, 45, 59)\nans = timer1.convert_to_seconds()\nprint(ans)')


  def test7(self):
    resetMyStdOut()
    setMyStdIn('')
    
    timer1 = Timer(100, 35, 58)
    ans = timer1.convert_to_seconds()
    print(ans)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '362158\n'.strip(), "Test: " + 'timer1 = Timer(100, 35, 58)\nans = timer1.convert_to_seconds()\nprint(ans)')



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-timer_class-add_timers-2" label="exe-sec-HW10-PRACTICE-1-271624">
      <title>Add Two Timers</title>
      <statement>
        <p>Write a function, add_timers, that takes two <c>Timer</c> objects, <c>t1</c> and <c>t2</c>, and returns a new <c>Timer</c> object that is the sum of <c>t1</c> and <c>t2</c>. Neither of the original <c>Timer</c> objects should be changed.</p>
        <p>The minutes and seconds attributes for the new <c>Timer</c> object must be valid (i.e., in the range 0 through 59). This means you may need to do some conversion from seconds to minutes and from minutes to hours. You may assume that the attributes for the provided <c>Timer</c> objects <c>t1</c> and <c>t2</c> are valid.</p>
        <p>Note that the function you are writing is <alert>NOT</alert> a <c>Timer</c> class method. It is just a regular function.</p>
        <p><alert>HINT</alert>: Use floor division (//) and remainder (%) to implement this function.</p>
        <p>The <c>Timer</c> class is given below for reference.</p>
        <pre>class Timer:
        """ A class that represents a timer. """
        def __init__(self, h, m, s):
            self.hours = h
            self.minutes = m
            self.seconds = s

        def print_with_labels(self):
            print('Hours:', self.hours, end=' ')
            print('Minutes:', self.minutes, end=' ')
            print('Seconds:', self.seconds)
            
        def get_seconds(self):
            return self.seconds
        
        def get_minutes(self):
            return self.minutes
        
        def get_hours(self):
            return self.hours

        def __str__(self):
            return f'{self.hours}:{self.minutes}:{self.seconds}'        </pre>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="40%" />
          <col top="minor" width="60%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Test</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>timer1 = Timer(0, 5, 30)
timer2 = Timer(2, 19, 0)
timer3 = add_timers(timer1, timer2)
print(timer3)
if(str(timer3) != "2:24:30"):  print("Should be: 2:24:30")                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>2:24:30</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>timer1 = Timer(1, 51, 41)
timer2 = Timer(4, 48, 59)
timer3 = add_timers(timer1, timer2)
print(timer3)
if(str(timer3) != "6:40:40"):  print("Should be: 6:40:40")                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>6:40:40</cd>
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">_my_out = ""
_my_in = []
_datafiles = {}

# Start of FileLike
class FileLike:
  def __init__(self, contents):
    self.contents = contents
    self.cursor = 0

  def __enter__(self):
    return self

  def __exit__(self, exc_type, exc_value, traceback):
    self.close()

  def tell(self):
    return self.cursor

  def seek(self, n):
    self.cursor = n

  def read(self):
    n = self.cursor
    self.cursor = max(n, len(self.contents))
    return self.contents[n:]

  def readline(self):
    n = self.cursor
    rest = self.contents[n:]
    index = rest.find("\n")
    if index == -1:
      self.cursor = len(self.contents)
      return rest
    index += 1
    self.cursor = n + index
    return rest[:index]

  def readlines(self):
    results = []
    while True:
      line = self.readline()
      if line == '':
        return results
      results.append(line)

  def close(self):
    pass

# End of FileLike

def open(fname, mode = "r"):
  """our own open"""
  if fname in _datafiles:
    return FileLike(_datafiles[fname])
  raise BaseException(f"File not found: {fname}")


def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise EOFError()
  return _my_in.pop()

class Timer:
    """ A class that represents a timer. """
    def __init__(self, h, m, s):
        self.hours = h
        self.minutes = m
        self.seconds= s

    def print_with_labels(self):
        print('Hours:', self.hours, end=' ')
        print('Minutes:', self.minutes, end=' ')
        print('Seconds:', self.seconds)
        
    def get_seconds(self):
        return self.seconds
        
    def get_minutes(self):
        return self.minutes
        
    def get_hours(self):
        return self.hours

    def __str__(self):
        return f'{self.hours}:{self.minutes}:{self.seconds}'
    


        </preamble>
        <code>
def add_timers(t1, t2):
        </code>
        <postamble visible="no">
        </postamble>
        <tests>import re

RIGHT_WHITESPACE_TRIMMER = re.compile("\\s+(?=\\n|$)")


from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')
    
    timer1 = Timer(0, 5, 30)
    timer2 = Timer(2, 19, 0)
    timer3 = add_timers(timer1, timer2)
    print(timer3)
    if(str(timer3) != "2:24:30"):  print("Should be: 2:24:30")
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '2:24:30\n'.strip(), "Test: " + 'timer1 = Timer(0, 5, 30)\ntimer2 = Timer(2, 19, 0)\ntimer3 = add_timers(timer1, timer2)\nprint(timer3)\nif(str(timer3) != "2:24:30"):  print("Should be: 2:24:30")')


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')
    
    timer1 = Timer(0, 5, 30)
    timer2 = Timer(2, 19, 35)
    timer3 = add_timers(timer1, timer2)
    print(timer3)
    if(str(timer3) != "2:25:5"):  print("Should be: 2:25:5")
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '2:25:5\n'.strip(), "Test: " + 'timer1 = Timer(0, 5, 30)\ntimer2 = Timer(2, 19, 35)\ntimer3 = add_timers(timer1, timer2)\nprint(timer3)\nif(str(timer3) != "2:25:5"):  print("Should be: 2:25:5")')


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')
    
    timer1 = Timer(0, 55, 30)
    timer2 = Timer(2, 10, 0)
    timer3 = add_timers(timer1, timer2)
    print(timer3)
    if(str(timer3) != "3:5:30"):  print("Should be: 3:5:30")
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '3:5:30\n'.strip(), "Test: " + 'timer1 = Timer(0, 55, 30)\ntimer2 = Timer(2, 10, 0)\ntimer3 = add_timers(timer1, timer2)\nprint(timer3)\nif(str(timer3) != "3:5:30"):  print("Should be: 3:5:30")')


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')
    
    timer1 = Timer(14, 40, 30)
    timer2 = Timer(6, 10, 45)
    timer3 = add_timers(timer1, timer2)
    print(timer3)
    if(str(timer3) != "20:51:15"):  print("Should be: 20:51:15")
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '20:51:15\n'.strip(), "Test: " + 'timer1 = Timer(14, 40, 30)\ntimer2 = Timer(6, 10, 45)\ntimer3 = add_timers(timer1, timer2)\nprint(timer3)\nif(str(timer3) != "20:51:15"):  print("Should be: 20:51:15")')


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')
    
    timer1 = Timer(1, 51, 41)
    timer2 = Timer(4, 48, 59)
    timer3 = add_timers(timer1, timer2)
    print(timer3)
    if(str(timer3) != "6:40:40"):  print("Should be: 6:40:40")
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '6:40:40'.strip(), "Test: " + 'timer1 = Timer(1, 51, 41)\ntimer2 = Timer(4, 48, 59)\ntimer3 = add_timers(timer1, timer2)\nprint(timer3)\nif(str(timer3) != "6:40:40"):  print("Should be: 6:40:40")')


  def test6(self):
    resetMyStdOut()
    setMyStdIn('')
    
    timer1 = Timer(10, 45, 59)
    timer2 = Timer(30, 54, 50)
    timer3 = add_timers(timer1, timer2)
    print(timer3)
    if(str(timer3) != "41:40:49"):  print("Should be: 41:40:49")
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '41:40:49'.strip(), "Test: " + 'timer1 = Timer(10, 45, 59)\ntimer2 = Timer(30, 54, 50)\ntimer3 = add_timers(timer1, timer2)\nprint(timer3)\nif(str(timer3) != "41:40:49"):  print("Should be: 41:40:49")')


  def test7(self):
    resetMyStdOut()
    setMyStdIn('')
    
    timer1 = Timer(100, 35, 58)
    timer2 = Timer(130, 59, 37)
    timer3 = add_timers(timer1, timer2)
    print(timer3)
    if(str(timer3) != "231:35:35"):  print("Should be: 231:35:35")
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '231:35:35\n'.strip(), "Test: " + 'timer1 = Timer(100, 35, 58)\ntimer2 = Timer(130, 59, 37)\ntimer3 = add_timers(timer1, timer2)\nprint(timer3)\nif(str(timer3) != "231:35:35"):  print("Should be: 231:35:35")')


  def test8(self):
    resetMyStdOut()
    setMyStdIn('')
    
    timer1 = Timer(200, 36, 59)
    timer2 = Timer(330, 58, 59)
    timer3 = add_timers(timer1, timer2)
    print(timer3)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '531:35:58\n'.strip(), "Test: " + 'timer1 = Timer(200, 36, 59)\ntimer2 = Timer(330, 58, 59)\ntimer3 = add_timers(timer1, timer2)\nprint(timer3)')



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-implement_comp_oper_info-2" label="exe-sec-HW10-PRACTICE-1-271625">
      <title>Implementing the Comparison Operators</title>
      <statement correct="yes">
        <p>Python has "magic" methods to make the comparison operators work with objects. The six comparison operators (&lt;, &lt;=, &gt;, &gt;=, == and !=) are enabled simply by implementing the following special methods: <c>__lt__, __le__, __gt__, __ge__, __eq__ and __ne__</c></p>
        <p>See: <em><url href="https://www.tutorialspoint.com/How-to-overload-Python-comparison-operators">https://www.tutorialspoint.com/How-to-overload-Python-comparison-operators</url></em></p>
        <p>For example, here is the code to implement <c>__lt__</c> (i.e., &lt;, the "less than" operator) for the <c>Timer</c>class. Notice we start by converting both Timers to an integer number of seconds, then simply compare those numbers of seconds. Comparing two Timers reduces to the problem of comparing two integers.</p>
        <pre>
    def __lt__(self, other):
        sec_self = self.convert_to_seconds()
        sec_other = other.convert_to_seconds()
        return sec_self &lt; sec_other
        </pre>
      </statement>
    </exercise>
    <exercise xml:id="exer-timer_class-equivalence_operator_overload-2" label="exe-sec-HW10-PRACTICE-1-271627">
      <title>Equivalence and Inequivalence Operators: ==, !=</title>
      <statement>
        <p>Two Timer objects are <alert>equivalent</alert>exactly when they represent the same amount of time. Implement the <c>__eq__</c>method (i.e., == ) for the <c>Timer</c>class.</p>
        <p><alert>Hint</alert>: You should assume that the <c>convert_to_seconds</c> method has already been implemented.</p>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="40%" />
          <col top="minor" width="60%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Test</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>timer1 = Timer(0, 5, 30)
timer2 = Timer(0, 5, 30)
ans1 = timer1 == timer2
ans2 = timer1 != timer2
print(ans1, ans2)                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>True False</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>timer1 = Timer(1, 5, 30)
timer2 = Timer(0, 5, 30)
ans = timer1 == timer2
ans2 = timer1 != timer2
print(ans, ans2)                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>False True</cd>
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">_my_out = ""
_my_in = []
_datafiles = {}

# Start of FileLike
class FileLike:
  def __init__(self, contents):
    self.contents = contents
    self.cursor = 0

  def __enter__(self):
    return self

  def __exit__(self, exc_type, exc_value, traceback):
    self.close()

  def tell(self):
    return self.cursor

  def seek(self, n):
    self.cursor = n

  def read(self):
    n = self.cursor
    self.cursor = max(n, len(self.contents))
    return self.contents[n:]

  def readline(self):
    n = self.cursor
    rest = self.contents[n:]
    index = rest.find("\n")
    if index == -1:
      self.cursor = len(self.contents)
      return rest
    index += 1
    self.cursor = n + index
    return rest[:index]

  def readlines(self):
    results = []
    while True:
      line = self.readline()
      if line == '':
        return results
      results.append(line)

  def close(self):
    pass

# End of FileLike

def open(fname, mode = "r"):
  """our own open"""
  if fname in _datafiles:
    return FileLike(_datafiles[fname])
  raise BaseException(f"File not found: {fname}")


def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise EOFError()
  return _my_in.pop()

class Timer:
    """ A class that represents a timer. """
    def __init__(self, h, m, s):
        self.hours = h
        self.minutes = m
        self.seconds= s

    def print_with_labels(self):
        print('Hours:', self.hours, end=' ')
        print('Minutes:', self.minutes, end=' ')
        print('Seconds:', self.seconds)
        
    def get_seconds(self):
        return self.seconds
        
    def get_minutes(self):
        return self.minutes
        
    def get_hours(self):
        return self.hours
        
    def convert_to_seconds(self):
        return self.hours*60*60 + self.minutes*60 + self.seconds

    def __str__(self):
        return f'{self.hours}:{self.minutes}:{self.seconds}'



        </preamble>
        <code>
# NOTE: Do not change the indentation! It is required because the
# code will be pasted into the Timer class definition body.
    def __eq__(self, other):
        

        </code>
        <postamble visible="no">
        </postamble>
        <tests>import re

RIGHT_WHITESPACE_TRIMMER = re.compile("\\s+(?=\\n|$)")


from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')
    
    timer1 = Timer(0, 5, 30)
    timer2 = Timer(0, 5, 30)
    ans1 = timer1 == timer2
    ans2 = timer1 != timer2
    print(ans1, ans2)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'True False\n'.strip(), "Test: " + 'timer1 = Timer(0, 5, 30)\ntimer2 = Timer(0, 5, 30)\nans1 = timer1 == timer2\nans2 = timer1 != timer2\nprint(ans1, ans2)')


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')
    
    timer1 = Timer(1, 5, 30)
    timer2 = Timer(0, 5, 30)
    ans = timer1 == timer2
    ans2 = timer1 != timer2
    print(ans, ans2)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'False True\n'.strip(), "Test: " + 'timer1 = Timer(1, 5, 30)\ntimer2 = Timer(0, 5, 30)\nans = timer1 == timer2\nans2 = timer1 != timer2\nprint(ans, ans2)')


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')
    
    timer1 = Timer(1, 5, 30)
    timer2 = Timer(1, 4, 30)
    ans = timer1 == timer2
    ans2 = timer1 != timer2
    print(ans, ans2)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'False True\n'.strip(), "Test: " + 'timer1 = Timer(1, 5, 30)\ntimer2 = Timer(1, 4, 30)\nans = timer1 == timer2\nans2 = timer1 != timer2\nprint(ans, ans2)')


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')
    
    timer1 = Timer(1, 5, 30)
    timer2 = Timer(0, 5, 32)
    ans = timer1 == timer2
    ans2 = timer1 != timer2
    print(ans, ans2)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'False True\n'.strip(), "Test: " + 'timer1 = Timer(1, 5, 30)\ntimer2 = Timer(0, 5, 32)\nans = timer1 == timer2\nans2 = timer1 != timer2\nprint(ans, ans2)')


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')
    
    timer1 = Timer(10, 50, 40)
    timer2 = Timer(10, 50, 40)
    ans = timer1 == timer2
    ans2 = timer1 != timer2
    print(ans, ans2)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'True False\n'.strip(), "Test: " + 'timer1 = Timer(10, 50, 40)\ntimer2 = Timer(10, 50, 40)\nans = timer1 == timer2\nans2 = timer1 != timer2\nprint(ans, ans2)')


  def test6(self):
    resetMyStdOut()
    setMyStdIn('')
    
    timer1 = Timer(10, 50, 40)
    timer2 = Timer(10, 50, 41)
    ans = timer1 == timer2
    ans2 = timer1 != timer2
    print(ans, ans2)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'False True\n'.strip(), "Test: " + 'timer1 = Timer(10, 50, 40)\ntimer2 = Timer(10, 50, 41)\nans = timer1 == timer2\nans2 = timer1 != timer2\nprint(ans, ans2)')


  def test7(self):
    resetMyStdOut()
    setMyStdIn('')
    
    timer1 = Timer(10, 50, 40)
    timer2 = Timer(11, 50, 40)
    ans = timer1 == timer2
    ans2 = timer1 != timer2
    print(ans, ans2)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'False True\n'.strip(), "Test: " + 'timer1 = Timer(10, 50, 40)\ntimer2 = Timer(11, 50, 40)\nans = timer1 == timer2\nans2 = timer1 != timer2\nprint(ans, ans2)')



myTests().main()        </tests>
      </program>
    </exercise>
  </exercises>
</section>