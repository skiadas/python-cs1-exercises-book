<section xml:id="sec-HW8-1">
  <title>HW8</title>
  <introduction>
    <p dir="ltr">- while loops</p>
    <p dir="ltr">- sets</p>
  </introduction>
  <exercises>
    <exercise xml:id="exer-build_num_list1-1" label="exe-sec-HW8-1-32073">
      <title>Build Num List</title>
      <statement>
        <p>Write a function, <c>build_num_list</c>, that has no parameters; the function reads <term>integers</term>from standard input, one at a time, stopping when a <c>0</c> is read.</p>
        <p>Each number read, except the final <c>0</c>, is appended to a new list (initially empty) created by the function. The function should <term>return</term> the accumulated list.</p>
        <p><term>Hint:</term>Use a while loop.</p>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="40%" />
          <col top="minor" width="20%" />
          <col top="minor" width="40%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Test</cell>
            <cell bottom="minor" right="minor">Input</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>N = build_num_list()
print(N)
print(type(N), type(N[0]))                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>55
20
20
0                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>[55, 20, 20]
&lt;class 'list'&gt; &lt;class 'int'&gt;                </cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>N = build_num_list()
print(N)
print(type(N))                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>0
1
1                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>[]
&lt;class 'list'&gt;                </cd>
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">_my_out = ""
_my_in = []
_datafiles = {}

# Start of FileLike
class FileLike:
  def __init__(self, contents):
    self.contents = contents
    self.cursor = 0

  def __enter__(self):
    return self

  def __exit__(self, exc_type, exc_value, traceback):
    self.close()

  def tell(self):
    return self.cursor

  def seek(self, n):
    self.cursor = n

  def read(self):
    n = self.cursor
    self.cursor = max(n, len(self.contents))
    return self.contents[n:]

  def readline(self):
    n = self.cursor
    rest = self.contents[n:]
    index = rest.find("\n")
    if index == -1:
      self.cursor = len(self.contents)
      return rest
    index += 1
    self.cursor = n + index
    return rest[:index]

  def readlines(self):
    results = []
    while True:
      line = self.readline()
      if line == '':
        return results
      results.append(line)

  def close(self):
    pass

# End of FileLike

def open(fname, mode = "r"):
  """our own open"""
  if fname in _datafiles:
    return FileLike(_datafiles[fname])
  raise BaseException(f"File not found: {fname}")


def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise EOFError()
  return _my_in.pop()

None

        </preamble>
        <code>

        </code>
        <postamble visible="no">
        </postamble>
        <tests>import re

RIGHT_WHITESPACE_TRIMMER = re.compile("\\s+(?=\\n|$)")


from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('55\n20\n20\n0')
    
    N = build_num_list()
    print(N)
    print(type(N), type(N[0]))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), "[55, 20, 20]\n&lt;class 'list'&gt; &lt;class 'int'&gt;\n".strip(), "Input: " + '55\n20\n20\n0')


  def test2(self):
    resetMyStdOut()
    setMyStdIn('0\n1\n1')
    
    N = build_num_list()
    print(N)
    print(type(N))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), "[]\n&lt;class 'list'&gt;\n".strip(), "Input: " + '0\n1\n1')


  def test3(self):
    resetMyStdOut()
    setMyStdIn('99\n-15\n11\n0\n5\n1\n1')
    
    N = build_num_list()
    print(N)
    print(type(N), type(N[0]))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), "[99, -15, 11]\n&lt;class 'list'&gt; &lt;class 'int'&gt;\n".strip(), "Input: " + '99\n-15\n11\n0\n5\n1\n1')


  def test4(self):
    resetMyStdOut()
    setMyStdIn('100\n2\n1\n-1\n-2\n0\n-2\n-1')
    
    N = build_num_list()
    print(N)
    print(type(N), type(N[0]))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), "[100, 2, 1, -1, -2]\n&lt;class 'list'&gt; &lt;class 'int'&gt;\n".strip(), "Input: " + '100\n2\n1\n-1\n-2\n0\n-2\n-1')


  def test5(self):
    resetMyStdOut()
    setMyStdIn('10\n0\n20\n30\n40\n50\n60\n70\n80\n90\n100')
    
    N = build_num_list()
    print(N)
    print(type(N), type(N[0]))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), "[10]\n&lt;class 'list'&gt; &lt;class 'int'&gt;\n".strip(), "Input: " + '10\n0\n20\n30\n40\n50\n60\n70\n80\n90\n100')



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-get_pos_input-1" label="exe-sec-HW8-1-32046">
      <title>Get Positive Input</title>
      <statement>
        <p>The function <c>get_pos_input</c> takes no parameters. Instead, it reads integers one at a time from standard input until a <term>positive</term> integer is read. Once a positive integer has been read, that integer is <term>returned</term>.</p>
        <p>Add Python code to implement the <c>get_pos_input</c> function.</p>
        <p><term>Hint</term>: Use a while loop.</p>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="40%" />
          <col top="minor" width="20%" />
          <col top="minor" width="40%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Test</cell>
            <cell bottom="minor" right="minor">Input</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>print(get_pos_input())</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>-3
-352034
-42342
-42455222
17
25
3
-2
                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>17</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>print(get_pos_input())</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>0
12                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>12</cd>
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">_my_out = ""
_my_in = []
_datafiles = {}

# Start of FileLike
class FileLike:
  def __init__(self, contents):
    self.contents = contents
    self.cursor = 0

  def __enter__(self):
    return self

  def __exit__(self, exc_type, exc_value, traceback):
    self.close()

  def tell(self):
    return self.cursor

  def seek(self, n):
    self.cursor = n

  def read(self):
    n = self.cursor
    self.cursor = max(n, len(self.contents))
    return self.contents[n:]

  def readline(self):
    n = self.cursor
    rest = self.contents[n:]
    index = rest.find("\n")
    if index == -1:
      self.cursor = len(self.contents)
      return rest
    index += 1
    self.cursor = n + index
    return rest[:index]

  def readlines(self):
    results = []
    while True:
      line = self.readline()
      if line == '':
        return results
      results.append(line)

  def close(self):
    pass

# End of FileLike

def open(fname, mode = "r"):
  """our own open"""
  if fname in _datafiles:
    return FileLike(_datafiles[fname])
  raise BaseException(f"File not found: {fname}")


def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise EOFError()
  return _my_in.pop()

None

        </preamble>
        <code>

        </code>
        <postamble visible="no">
        </postamble>
        <tests>import re

RIGHT_WHITESPACE_TRIMMER = re.compile("\\s+(?=\\n|$)")


from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('-3\n-352034\n-42342\n-42455222\n17\n25\n3\n-2\n')
    
    print(get_pos_input())
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '17'.strip(), "Input: " + '-3\n-352034\n-42342\n-42455222\n17\n25\n3\n-2\n')


  def test2(self):
    resetMyStdOut()
    setMyStdIn('0\n12')
    
    print(get_pos_input())
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '12'.strip(), "Input: " + '0\n12')


  def test3(self):
    resetMyStdOut()
    setMyStdIn('1492\n2')
    
    print(get_pos_input())
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '1492'.strip(), "Input: " + '1492\n2')


  def test4(self):
    resetMyStdOut()
    setMyStdIn('-1\n-2\n-3\n-4\n0\n99\n2')
    
    print(get_pos_input())
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '99'.strip(), "Input: " + '-1\n-2\n-3\n-4\n0\n99\n2')


  def test5(self):
    resetMyStdOut()
    setMyStdIn('-10\n-15\n-3\n-999\n-12\n-100\n98765')
    
    print(get_pos_input())
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '98765'.strip(), "Input: " + '-10\n-15\n-3\n-999\n-12\n-100\n98765')



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-sum_nonneg_input-1" label="exe-sec-HW8-1-32050">
      <title>Sum Nonnegative Input</title>
      <statement>
        <p>The function <c>sum_nonneg_input</c> takes no parameters. Instead, it reads <term>integers</term>one at a time from standard input, maintaining a running sum of numbers entered, until a negative integer is read. Once a negative integer is read, the function returns the current sum. Note: the negative number is not included in the sum.</p>
        <p>Write Python code to implement the <c>sum_nonneg_input</c> function.</p>
        <p><term>Hint</term>: Use a while loop.</p>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="40%" />
          <col top="minor" width="20%" />
          <col top="minor" width="40%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Test</cell>
            <cell bottom="minor" right="minor">Input</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>print(sum_nonneg_input())</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>3
35
42
-17
25
3
-2
                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>80</cd>
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">_my_out = ""
_my_in = []
_datafiles = {}

# Start of FileLike
class FileLike:
  def __init__(self, contents):
    self.contents = contents
    self.cursor = 0

  def __enter__(self):
    return self

  def __exit__(self, exc_type, exc_value, traceback):
    self.close()

  def tell(self):
    return self.cursor

  def seek(self, n):
    self.cursor = n

  def read(self):
    n = self.cursor
    self.cursor = max(n, len(self.contents))
    return self.contents[n:]

  def readline(self):
    n = self.cursor
    rest = self.contents[n:]
    index = rest.find("\n")
    if index == -1:
      self.cursor = len(self.contents)
      return rest
    index += 1
    self.cursor = n + index
    return rest[:index]

  def readlines(self):
    results = []
    while True:
      line = self.readline()
      if line == '':
        return results
      results.append(line)

  def close(self):
    pass

# End of FileLike

def open(fname, mode = "r"):
  """our own open"""
  if fname in _datafiles:
    return FileLike(_datafiles[fname])
  raise BaseException(f"File not found: {fname}")


def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise EOFError()
  return _my_in.pop()

None

        </preamble>
        <code>

        </code>
        <postamble visible="no">
        </postamble>
        <tests>import re

RIGHT_WHITESPACE_TRIMMER = re.compile("\\s+(?=\\n|$)")


from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('3\n35\n42\n-17\n25\n3\n-2\n')
    
    print(sum_nonneg_input())
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '80'.strip(), "Input: " + '3\n35\n42\n-17\n25\n3\n-2\n')


  def test2(self):
    resetMyStdOut()
    setMyStdIn('-8\n2')
    
    print(sum_nonneg_input())
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '0'.strip(), "Input: " + '-8\n2')


  def test3(self):
    resetMyStdOut()
    setMyStdIn('1492\n0\n100\n-1\n')
    
    print(sum_nonneg_input())
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '1592'.strip(), "Input: " + '1492\n0\n100\n-1\n')


  def test4(self):
    resetMyStdOut()
    setMyStdIn('1\n2\n3\n4\n-99')
    
    print(sum_nonneg_input())
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '10'.strip(), "Input: " + '1\n2\n3\n4\n-99')


  def test5(self):
    resetMyStdOut()
    setMyStdIn('1\n4\n9\n16\n25\n36\n49\n64\n-81')
    
    print(sum_nonneg_input())
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '204\n'.strip(), "Input: " + '1\n4\n9\n16\n25\n36\n49\n64\n-81')



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-max_float_input_with_sentinel-1" label="exe-sec-HW8-1-32049">
      <title>Max Float Input</title>
      <statement>
        <p>
          The function <c>max_float_input</c> takes no parameters. Instead, it reads strings from standard input, one at a time, until the string "<term>stop</term>" is read.
          <ul>
            <li>If the string is not "<term>stop</term>", the string is converted to a floating point value (type <c>float</c>) and compared to the largest previous float value entered (if any).</li>
            <li>Otherwise, the function stops and returns the <term>largest floating point value</term> that was entered so far.</li>
          </ul>
        </p>
        <p><term>Note</term>: If the <term>first</term>string entered is "<term>stop</term>", the function simply returns the Python object <c>None</c>.</p>
        <p>Add Python code to implement the <c>max_float_input</c> function.</p>
        <p><term>Hint</term>: Use a while loop.</p>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="40%" />
          <col top="minor" width="20%" />
          <col top="minor" width="40%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Test</cell>
            <cell bottom="minor" right="minor">Input</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>print(max_float_input())</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>2938.3
294184.2
2982.003
3
-23482498.5
stop
                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>294184.2</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>print(max_float_input())</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>stop</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>None</cd>
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">_my_out = ""
_my_in = []
_datafiles = {}

# Start of FileLike
class FileLike:
  def __init__(self, contents):
    self.contents = contents
    self.cursor = 0

  def __enter__(self):
    return self

  def __exit__(self, exc_type, exc_value, traceback):
    self.close()

  def tell(self):
    return self.cursor

  def seek(self, n):
    self.cursor = n

  def read(self):
    n = self.cursor
    self.cursor = max(n, len(self.contents))
    return self.contents[n:]

  def readline(self):
    n = self.cursor
    rest = self.contents[n:]
    index = rest.find("\n")
    if index == -1:
      self.cursor = len(self.contents)
      return rest
    index += 1
    self.cursor = n + index
    return rest[:index]

  def readlines(self):
    results = []
    while True:
      line = self.readline()
      if line == '':
        return results
      results.append(line)

  def close(self):
    pass

# End of FileLike

def open(fname, mode = "r"):
  """our own open"""
  if fname in _datafiles:
    return FileLike(_datafiles[fname])
  raise BaseException(f"File not found: {fname}")


def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise EOFError()
  return _my_in.pop()

None

        </preamble>
        <code>

        </code>
        <postamble visible="no">
        </postamble>
        <tests>import re

RIGHT_WHITESPACE_TRIMMER = re.compile("\\s+(?=\\n|$)")


from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('2938.3\n294184.2\n2982.003\n3\n-23482498.5\nstop\n')
    
    print(max_float_input())
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '294184.2'.strip(), "Input: " + '2938.3\n294184.2\n2982.003\n3\n-23482498.5\nstop\n')


  def test2(self):
    resetMyStdOut()
    setMyStdIn('stop')
    
    print(max_float_input())
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'None\n'.strip(), "Input: " + 'stop')


  def test3(self):
    resetMyStdOut()
    setMyStdIn('52.0\n41.2\n73.7\n53.9\n-34.6\nstop')
    
    print(max_float_input())
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '73.7'.strip(), "Input: " + '52.0\n41.2\n73.7\n53.9\n-34.6\nstop')


  def test4(self):
    resetMyStdOut()
    setMyStdIn('152.0\n41.2\n73.7\n53.9\n-34.6\nstop')
    
    print(max_float_input())
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '152.0'.strip(), "Input: " + '152.0\n41.2\n73.7\n53.9\n-34.6\nstop')


  def test5(self):
    resetMyStdOut()
    setMyStdIn('10.0\n-6.0\n6.0\n19.1\nstop')
    
    print(max_float_input())
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '19.1'.strip(), "Input: " + '10.0\n-6.0\n6.0\n19.1\nstop')


  def test6(self):
    resetMyStdOut()
    setMyStdIn('-5.6\n-2.6\n-9.9\n-8.7\nstop\n')
    
    print(max_float_input())
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '-2.6'.strip(), "Input: " + '-5.6\n-2.6\n-9.9\n-8.7\nstop\n')


  def test7(self):
    resetMyStdOut()
    setMyStdIn('-7.9\n-9.9\n1.0\n7.1\n9.6\n-4.5\n-4.5\n-7.6\nstop\n')
    
    print(max_float_input())
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '9.6'.strip(), "Input: " + '-7.9\n-9.9\n1.0\n7.1\n9.6\n-4.5\n-4.5\n-7.6\nstop\n')



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-multiplication_quiz_while-1" label="exe-sec-HW8-1-32047">
      <title>Multiplication Quiz</title>
      <statement>
        <p>The function <c>multiplication_quiz(a, b)</c> takes two integer parameters, <c>a</c> and <c>b</c>. The function prompts the user (just once) to enter the product of a times b, and uses a loop to keep checking the input for the correct answer.</p>
        <p>The function keeps a count of how many attempts were needed to get the right answer. When the correct answer is read, the function returns the count.</p>
        <p>Write the code needed to implement this function.</p>
        <p><term>Hint</term>: Use a while loop.</p>
        <p><term>Note</term>: You should assume that every input can be converted to an integer.</p>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="40%" />
          <col top="minor" width="20%" />
          <col top="minor" width="40%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Test</cell>
            <cell bottom="minor" right="minor">Input</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>n = multiplication_quiz(12, 7)
print("count =", n)                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>17
9
84
83
99                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>What is 12 times 7 ?
count = 3                </cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>n = multiplication_quiz(2, 3)
print("count =", n)                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>10
9
8
7
6
5
4                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>What is 2 times 3 ?
count = 5                </cd>
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">_my_out = ""
_my_in = []
_datafiles = {}

# Start of FileLike
class FileLike:
  def __init__(self, contents):
    self.contents = contents
    self.cursor = 0

  def __enter__(self):
    return self

  def __exit__(self, exc_type, exc_value, traceback):
    self.close()

  def tell(self):
    return self.cursor

  def seek(self, n):
    self.cursor = n

  def read(self):
    n = self.cursor
    self.cursor = max(n, len(self.contents))
    return self.contents[n:]

  def readline(self):
    n = self.cursor
    rest = self.contents[n:]
    index = rest.find("\n")
    if index == -1:
      self.cursor = len(self.contents)
      return rest
    index += 1
    self.cursor = n + index
    return rest[:index]

  def readlines(self):
    results = []
    while True:
      line = self.readline()
      if line == '':
        return results
      results.append(line)

  def close(self):
    pass

# End of FileLike

def open(fname, mode = "r"):
  """our own open"""
  if fname in _datafiles:
    return FileLike(_datafiles[fname])
  raise BaseException(f"File not found: {fname}")


def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise EOFError()
  return _my_in.pop()

None

        </preamble>
        <code>

        </code>
        <postamble visible="no">
        </postamble>
        <tests>import re

RIGHT_WHITESPACE_TRIMMER = re.compile("\\s+(?=\\n|$)")


from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('17\n9\n84\n83\n99')
    
    n = multiplication_quiz(12, 7)
    print("count =", n)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'What is 12 times 7 ?\ncount = 3\n'.strip(), "Input: " + '17\n9\n84\n83\n99')


  def test2(self):
    resetMyStdOut()
    setMyStdIn('55\n44\n2')
    
    n = multiplication_quiz(5, 11)
    print("count =", n)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'What is 5 times 11 ?\ncount = 1\n'.strip(), "Input: " + '55\n44\n2')


  def test3(self):
    resetMyStdOut()
    setMyStdIn('10\n9\n8\n7\n6\n5\n4')
    
    n = multiplication_quiz(2, 3)
    print("count =", n)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'What is 2 times 3 ?\ncount = 5\n'.strip(), "Input: " + '10\n9\n8\n7\n6\n5\n4')


  def test4(self):
    resetMyStdOut()
    setMyStdIn('60\n65\n70\n75')
    
    n = multiplication_quiz(13, 5)
    print("count =", n)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'What is 13 times 5 ?\ncount = 2\n'.strip(), "Input: " + '60\n65\n70\n75')


  def test5(self):
    resetMyStdOut()
    setMyStdIn('33\n11\n12\n13\n44\n144\n155\n')
    
    n = multiplication_quiz(12, 12)
    print("count =", n)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'What is 12 times 12 ?\ncount = 6\n'.strip(), "Input: " + '33\n11\n12\n13\n44\n144\n155\n')



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-list_has_repeat_using_set-1" label="exe-sec-HW8-1-32048">
      <title>List Has Repeat (using set)</title>
      <statement>
        <p>Write a definition for the function <c>has_repeat(L)</c>. The parameter L is a list of immutable items. The function returns True if L has at least one repeated item, otherwise it returns False.</p>
        <p><term>Hint</term>: If the set of items in L has a shorter length than L itself, return True; otherwise, return False.</p>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="40%" />
          <col top="minor" width="60%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Test</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>L = list('hello')
print(has_repeat(L), type(has_repeat(L)))                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>True &lt;class 'bool'&gt;</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>L = list('Maybe')
print(has_repeat(L), type(has_repeat(L)))                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>False &lt;class 'bool'&gt;</cd>
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">_my_out = ""
_my_in = []
_datafiles = {}

# Start of FileLike
class FileLike:
  def __init__(self, contents):
    self.contents = contents
    self.cursor = 0

  def __enter__(self):
    return self

  def __exit__(self, exc_type, exc_value, traceback):
    self.close()

  def tell(self):
    return self.cursor

  def seek(self, n):
    self.cursor = n

  def read(self):
    n = self.cursor
    self.cursor = max(n, len(self.contents))
    return self.contents[n:]

  def readline(self):
    n = self.cursor
    rest = self.contents[n:]
    index = rest.find("\n")
    if index == -1:
      self.cursor = len(self.contents)
      return rest
    index += 1
    self.cursor = n + index
    return rest[:index]

  def readlines(self):
    results = []
    while True:
      line = self.readline()
      if line == '':
        return results
      results.append(line)

  def close(self):
    pass

# End of FileLike

def open(fname, mode = "r"):
  """our own open"""
  if fname in _datafiles:
    return FileLike(_datafiles[fname])
  raise BaseException(f"File not found: {fname}")


def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise EOFError()
  return _my_in.pop()

None

        </preamble>
        <code>

        </code>
        <postamble visible="no">
        </postamble>
        <tests>import re

RIGHT_WHITESPACE_TRIMMER = re.compile("\\s+(?=\\n|$)")


from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = list('hello')
    print(has_repeat(L), type(has_repeat(L)))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), "True &lt;class 'bool'&gt;\n".strip(), "Test: " + "L = list('hello')\nprint(has_repeat(L), type(has_repeat(L)))")


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = list('Maybe')
    print(has_repeat(L), type(has_repeat(L)))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), "False &lt;class 'bool'&gt;\n".strip(), "Test: " + "L = list('Maybe')\nprint(has_repeat(L), type(has_repeat(L)))")


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = list('banana')
    print(has_repeat(L), type(has_repeat(L)))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), "True &lt;class 'bool'&gt;\n".strip(), "Test: " + "L = list('banana')\nprint(has_repeat(L), type(has_repeat(L)))")


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = []
    print(has_repeat(L), type(has_repeat(L)))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), "False &lt;class 'bool'&gt;\n".strip(), "Test: " + 'L = []\nprint(has_repeat(L), type(has_repeat(L)))')


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = ['banana']
    print(has_repeat(L), type(has_repeat(L)))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), "False &lt;class 'bool'&gt;\n".strip(), "Test: " + "L = ['banana']\nprint(has_repeat(L), type(has_repeat(L)))")


  def test6(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = ['cat', 'dog', 'cat']
    print(has_repeat(L), type(has_repeat(L)))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), "True &lt;class 'bool'&gt;\n".strip(), "Test: " + "L = ['cat', 'dog', 'cat']\nprint(has_repeat(L), type(has_repeat(L)))")


  def test7(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = list('abcdefg')
    print(has_repeat(L), type(has_repeat(L)))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), "False &lt;class 'bool'&gt;\n".strip(), "Test: " + "L = list('abcdefg')\nprint(has_repeat(L), type(has_repeat(L)))")



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-number_of_distinct_elements-1" label="exe-sec-HW8-1-32051">
      <title>Number of Distinct Elements (using set)</title>
      <statement>
        <p>Implement the function <c>num_distinct_elements(C)</c>. The function takes the parameter C, a collection of type list, string, or tuple, and returns the number of distinct items in C. For example, if C is the list [1, 2, 3, 3, 2, 1, 2, 3, 3, 10], the return value would be 4 (since 1, 2, 3, 10 are the "distinct" elements).</p>
        <p>HINT: The body of the function requires just one or two lines of code.</p>
        <p><term>NOTE</term>: Use <c>set</c> in your code.</p>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="40%" />
          <col top="minor" width="60%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Test</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>C = [1, 2, 3, 2, 2, 2, 1, 1, 1, 1]
print(num_distinct_elements(C))                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>3</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>C = "She sells sea shells by the sea shore."
print(num_distinct_elements(C))                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>13</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>C = ('b', 'a', 'b', 'b', 'l', 'e')
print(num_distinct_elements(C))                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>4</cd>
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">_my_out = ""
_my_in = []
_datafiles = {}

# Start of FileLike
class FileLike:
  def __init__(self, contents):
    self.contents = contents
    self.cursor = 0

  def __enter__(self):
    return self

  def __exit__(self, exc_type, exc_value, traceback):
    self.close()

  def tell(self):
    return self.cursor

  def seek(self, n):
    self.cursor = n

  def read(self):
    n = self.cursor
    self.cursor = max(n, len(self.contents))
    return self.contents[n:]

  def readline(self):
    n = self.cursor
    rest = self.contents[n:]
    index = rest.find("\n")
    if index == -1:
      self.cursor = len(self.contents)
      return rest
    index += 1
    self.cursor = n + index
    return rest[:index]

  def readlines(self):
    results = []
    while True:
      line = self.readline()
      if line == '':
        return results
      results.append(line)

  def close(self):
    pass

# End of FileLike

def open(fname, mode = "r"):
  """our own open"""
  if fname in _datafiles:
    return FileLike(_datafiles[fname])
  raise BaseException(f"File not found: {fname}")


def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise EOFError()
  return _my_in.pop()

None

        </preamble>
        <code>

        </code>
        <postamble visible="no">
        </postamble>
        <tests>import re

RIGHT_WHITESPACE_TRIMMER = re.compile("\\s+(?=\\n|$)")


from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')
    
    C = [1, 2, 3, 2, 2, 2, 1, 1, 1, 1]
    print(num_distinct_elements(C))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '3'.strip(), "Test: " + 'C = [1, 2, 3, 2, 2, 2, 1, 1, 1, 1]\nprint(num_distinct_elements(C))')


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')
    
    C = "She sells sea shells by the sea shore."
    print(num_distinct_elements(C))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '13\n'.strip(), "Test: " + 'C = "She sells sea shells by the sea shore."\nprint(num_distinct_elements(C))')


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')
    
    C = ('b', 'a', 'b', 'b', 'l', 'e')
    print(num_distinct_elements(C))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '4\n'.strip(), "Test: " + "C = ('b', 'a', 'b', 'b', 'l', 'e')\nprint(num_distinct_elements(C))")


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')
    
    C = [2, 3, 5, 7, 11, 13, 15]
    print(num_distinct_elements(C))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '7'.strip(), "Test: " + 'C = [2, 3, 5, 7, 11, 13, 15]\nprint(num_distinct_elements(C))')


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')
    
    C = []
    print(num_distinct_elements(C))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '0\n'.strip(), "Test: " + 'C = []\nprint(num_distinct_elements(C))')


  def test6(self):
    resetMyStdOut()
    setMyStdIn('')
    
    C = "aaaaaaaaaaaaaaaaaa"
    print(num_distinct_elements(C))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '1\n'.strip(), "Test: " + 'C = "aaaaaaaaaaaaaaaaaa"\nprint(num_distinct_elements(C))')


  def test7(self):
    resetMyStdOut()
    setMyStdIn('')
    
    C = list("mississippi river")
    print(num_distinct_elements(C))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '8\n'.strip(), "Test: " + 'C = list("mississippi river")\nprint(num_distinct_elements(C))')


  def test8(self):
    resetMyStdOut()
    setMyStdIn('')
    
    C = "Hanover College Panthers!"
    print(num_distinct_elements(C))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '16\n'.strip(), "Test: " + 'C = "Hanover College Panthers!"\nprint(num_distinct_elements(C))')



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-distinct_elements_in_nested_collection-1" label="exe-sec-HW8-1-32391">
      <title>Get Distinct From Nested</title>
      <statement>
        <p>Write a definition for the function <c>get_distinct_from_nested(C)</c>, where the parameter C is a sequence of sequences (e.g.,  a list of strings or a list of lists of integers). The job of the function is to use set operations to find and return the <term>sorted</term>list of unique elements in the nested collection C.</p>
        <p><term>Hint</term>: If S is a set, <c>sorted(S)</c> is a sorted list of the elements in S.</p>
        <p><term>Another Hint</term>: Use set union to accumulate the set S of distinct inner elements using a single for loop:</p>
        <p>
          <ul>
            <li>iterate <c>seq</c>over the top-level elements of C</li>
            <li>use <c>S = S.union(seq)</c> to update S with additional items from <c>seq</c></li>
          </ul>
          This only requires about 5 lines of code.
        </p>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="40%" />
          <col top="minor" width="60%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Test</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>C = ['Java', 'Jumble', 'BlackJack']
print(get_distinct_from_nested(C))                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>['B', 'J', 'a', 'b', 'c', 'e', 'k', 'l', 'm', 'u', 'v']</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>C = ['app', 'ban', 'can', 'def']
print(get_distinct_from_nested(C))                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>['a', 'b', 'c', 'd', 'e', 'f', 'n', 'p']</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>C = ['!', '!!', '!!!', '!!!!', '!!!!!']
print(get_distinct_from_nested(C))                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>['!']</cd>
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">_my_out = ""
_my_in = []
_datafiles = {}

# Start of FileLike
class FileLike:
  def __init__(self, contents):
    self.contents = contents
    self.cursor = 0

  def __enter__(self):
    return self

  def __exit__(self, exc_type, exc_value, traceback):
    self.close()

  def tell(self):
    return self.cursor

  def seek(self, n):
    self.cursor = n

  def read(self):
    n = self.cursor
    self.cursor = max(n, len(self.contents))
    return self.contents[n:]

  def readline(self):
    n = self.cursor
    rest = self.contents[n:]
    index = rest.find("\n")
    if index == -1:
      self.cursor = len(self.contents)
      return rest
    index += 1
    self.cursor = n + index
    return rest[:index]

  def readlines(self):
    results = []
    while True:
      line = self.readline()
      if line == '':
        return results
      results.append(line)

  def close(self):
    pass

# End of FileLike

def open(fname, mode = "r"):
  """our own open"""
  if fname in _datafiles:
    return FileLike(_datafiles[fname])
  raise BaseException(f"File not found: {fname}")


def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise EOFError()
  return _my_in.pop()

None

        </preamble>
        <code>

        </code>
        <postamble visible="no">
        </postamble>
        <tests>import re

RIGHT_WHITESPACE_TRIMMER = re.compile("\\s+(?=\\n|$)")


from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')
    
    C = ['Java', 'Jumble', 'BlackJack']
    print(get_distinct_from_nested(C))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), "['B', 'J', 'a', 'b', 'c', 'e', 'k', 'l', 'm', 'u', 'v']\n".strip(), "Test: " + "C = ['Java', 'Jumble', 'BlackJack']\nprint(get_distinct_from_nested(C))")


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')
    
    C = ['app', 'ban', 'can', 'def']
    print(get_distinct_from_nested(C))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), "['a', 'b', 'c', 'd', 'e', 'f', 'n', 'p']\n".strip(), "Test: " + "C = ['app', 'ban', 'can', 'def']\nprint(get_distinct_from_nested(C))")


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')
    
    C = ['!', '!!', '!!!', '!!!!', '!!!!!']
    print(get_distinct_from_nested(C))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), "['!']\n".strip(), "Test: " + "C = ['!', '!!', '!!!', '!!!!', '!!!!!']\nprint(get_distinct_from_nested(C))")


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')
    
    C = ['']
    print(get_distinct_from_nested(C))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '[]\n'.strip(), "Test: " + "C = ['']\nprint(get_distinct_from_nested(C))")


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')
    
    C = [list('zig'), list('zag'), list('bagpipes')]
    print(get_distinct_from_nested(C))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), "['a', 'b', 'e', 'g', 'i', 'p', 's', 'z']\n".strip(), "Test: " + "C = [list('zig'), list('zag'), list('bagpipes')]\nprint(get_distinct_from_nested(C))")


  def test6(self):
    resetMyStdOut()
    setMyStdIn('')
    
    C = ['apple', 'banana', 'candy', 'donut', 'eggs']
    print(get_distinct_from_nested(C))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), "['a', 'b', 'c', 'd', 'e', 'g', 'l', 'n', 'o', 'p', 's', 't', 'u', 'y']\n".strip(), "Test: " + "C = ['apple', 'banana', 'candy', 'donut', 'eggs']\nprint(get_distinct_from_nested(C))")



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-string_intersection_with_set-1" label="exe-sec-HW8-1-31949">
      <title>String Intersection</title>
      <statement>
        <p>Write the definition for a function <c>string_intersection(str1, str2)</c>, which takes two string parameters and returns a sorted list of the characters the two strings have in common.</p>
        <p><term>Hint</term>: Use set intersection and the sorted() function.</p>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="40%" />
          <col top="minor" width="60%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Test</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>L = string_intersection("cats", "caterpillar")
print(L)                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>['a', 'c', 't']</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>L = string_intersection("cats", "dogs")
print(L)                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>['s']</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>L = string_intersection("banana", "xylem")
print(L)                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>[]</cd>
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">_my_out = ""
_my_in = []
_datafiles = {}

# Start of FileLike
class FileLike:
  def __init__(self, contents):
    self.contents = contents
    self.cursor = 0

  def __enter__(self):
    return self

  def __exit__(self, exc_type, exc_value, traceback):
    self.close()

  def tell(self):
    return self.cursor

  def seek(self, n):
    self.cursor = n

  def read(self):
    n = self.cursor
    self.cursor = max(n, len(self.contents))
    return self.contents[n:]

  def readline(self):
    n = self.cursor
    rest = self.contents[n:]
    index = rest.find("\n")
    if index == -1:
      self.cursor = len(self.contents)
      return rest
    index += 1
    self.cursor = n + index
    return rest[:index]

  def readlines(self):
    results = []
    while True:
      line = self.readline()
      if line == '':
        return results
      results.append(line)

  def close(self):
    pass

# End of FileLike

def open(fname, mode = "r"):
  """our own open"""
  if fname in _datafiles:
    return FileLike(_datafiles[fname])
  raise BaseException(f"File not found: {fname}")


def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise EOFError()
  return _my_in.pop()

None

        </preamble>
        <code>

        </code>
        <postamble visible="no">
        </postamble>
        <tests>import re

RIGHT_WHITESPACE_TRIMMER = re.compile("\\s+(?=\\n|$)")


from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = string_intersection("cats", "caterpillar")
    print(L)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), "['a', 'c', 't']\n".strip(), "Test: " + 'L = string_intersection("cats", "caterpillar")\nprint(L)')


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = string_intersection("cats", "dogs")
    print(L)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), "['s']\n".strip(), "Test: " + 'L = string_intersection("cats", "dogs")\nprint(L)')


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = string_intersection("banana", "xylem")
    print(L)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '[]\n'.strip(), "Test: " + 'L = string_intersection("banana", "xylem")\nprint(L)')


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = string_intersection("dog-eared", "dog tails")
    print(L)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), "['a', 'd', 'g', 'o']\n".strip(), "Test: " + 'L = string_intersection("dog-eared", "dog tails")\nprint(L)')


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = string_intersection("Venus", "Mars")
    print(L)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), "['s']\n".strip(), "Test: " + 'L = string_intersection("Venus", "Mars")\nprint(L)')


  def test6(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = string_intersection("axbxcxd", "xaxcxfx")
    print(L)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), "['a', 'c', 'x']\n".strip(), "Test: " + 'L = string_intersection("axbxcxd", "xaxcxfx")\nprint(L)')



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-anagram_checker-1" label="exe-sec-HW8-1-103915">
      <title>Write a Program to Check for Anagrams</title>
      <statement>
        <p>Write the code to read two strings (str1, str2) from standard input and print a message regarding whether or not the strings are anagrams (rearrangements) of each other.</p>
        <p><term>Hint</term>: Compare sorted lists of characters for the two strings.</p>
        <p>In addition, if the strings are NOT anagrams of each other, give one of the following explanations: "They do not have the same character sets.", or "They do not have the same character frequencies."</p>
        <p>For example, "DOGS" and "GODS" are anagrams. "DOGS" and "HANOVER" do not have the same character sets, while "HANOVER" and "HANOOOVER" do not have the same character frequencies.</p>
        <p>Use set operations to determine if two non-anagrams have the same character set; if they do share the same set of characters, then you may conclude that their character frequencies are the only difference.</p>
        <p>Your code might be about 12 lines long.</p>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="30%" />
          <col top="minor" width="70%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Input</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>pizzzzzza
piizzaaaa                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>pizzzzzza and piizzaaaa are NOT anagrams.
They do not have the same character frequencies.                </cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>pizza
pasta                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>pizza and pasta are NOT anagrams.
They do not have the same character sets.                </cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>maps
spam
                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>maps and spam are anagrams!</cd>
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">_my_out = ""
_my_in = []
_datafiles = {}

# Start of FileLike
class FileLike:
  def __init__(self, contents):
    self.contents = contents
    self.cursor = 0

  def __enter__(self):
    return self

  def __exit__(self, exc_type, exc_value, traceback):
    self.close()

  def tell(self):
    return self.cursor

  def seek(self, n):
    self.cursor = n

  def read(self):
    n = self.cursor
    self.cursor = max(n, len(self.contents))
    return self.contents[n:]

  def readline(self):
    n = self.cursor
    rest = self.contents[n:]
    index = rest.find("\n")
    if index == -1:
      self.cursor = len(self.contents)
      return rest
    index += 1
    self.cursor = n + index
    return rest[:index]

  def readlines(self):
    results = []
    while True:
      line = self.readline()
      if line == '':
        return results
      results.append(line)

  def close(self):
    pass

# End of FileLike

def open(fname, mode = "r"):
  """our own open"""
  if fname in _datafiles:
    return FileLike(_datafiles[fname])
  raise BaseException(f"File not found: {fname}")


def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise EOFError()
  return _my_in.pop()

None


_program = """
        </preamble>
        <code>

        </code>
        <postamble visible="no">

"""
        </postamble>
        <tests>import re

RIGHT_WHITESPACE_TRIMMER = re.compile("\\s+(?=\\n|$)")


from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('pizzzzzza\npiizzaaaa')
    
    exec(_program)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'pizzzzzza and piizzaaaa are NOT anagrams.\nThey do not have the same character frequencies.\n'.strip(), "Input: " + 'pizzzzzza\npiizzaaaa')


  def test2(self):
    resetMyStdOut()
    setMyStdIn('pizza\npasta')
    
    exec(_program)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'pizza and pasta are NOT anagrams.\nThey do not have the same character sets.\n'.strip(), "Input: " + 'pizza\npasta')


  def test3(self):
    resetMyStdOut()
    setMyStdIn('maps\nspam\n')
    
    exec(_program)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'maps and spam are anagrams!\n'.strip(), "Input: " + 'maps\nspam\n')


  def test4(self):
    resetMyStdOut()
    setMyStdIn('HEY\nYEH')
    
    exec(_program)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'HEY and YEH are anagrams!\n'.strip(), "Input: " + 'HEY\nYEH')


  def test5(self):
    resetMyStdOut()
    setMyStdIn('monkey\nmonkee')
    
    exec(_program)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'monkey and monkee are NOT anagrams.\nThey do not have the same character sets.\n'.strip(), "Input: " + 'monkey\nmonkee')


  def test6(self):
    resetMyStdOut()
    setMyStdIn('jambaaaaa\njaammbbaa')
    
    exec(_program)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'jambaaaaa and jaammbbaa are NOT anagrams.\nThey do not have the same character frequencies.\n'.strip(), "Input: " + 'jambaaaaa\njaammbbaa')


  def test7(self):
    resetMyStdOut()
    setMyStdIn('abacad\naaadcb')
    
    exec(_program)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'abacad and aaadcb are anagrams!\n'.strip(), "Input: " + 'abacad\naaadcb')


  def test8(self):
    resetMyStdOut()
    setMyStdIn('aaabbb\naaacbb')
    
    exec(_program)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'aaabbb and aaacbb are NOT anagrams.\nThey do not have the same character sets.\n'.strip(), "Input: " + 'aaabbb\naaacbb')


  def test9(self):
    resetMyStdOut()
    setMyStdIn('aabbaa\nbbaabb')
    
    exec(_program)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'aabbaa and bbaabb are NOT anagrams.\nThey do not have the same character frequencies.\n'.strip(), "Input: " + 'aabbaa\nbbaabb')



myTests().main()        </tests>
      </program>
    </exercise>
  </exercises>
</section>