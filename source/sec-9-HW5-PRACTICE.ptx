<section xml:id="sec-HW5-PRACTICE-1">
  <title>HW5 PRACTICE</title>
  <introduction>
    <p dir="ltr">Ungraded Assignment</p>
  </introduction>
  <exercises>
    <exercise xml:id="exer-slice_three_from_front-2" label="exe-sec-HW5-PRACTICE-1-31939">
      <title>First Three Characters in a String</title>
      <statement>
        <p>The function <c>first_three</c> takes one string parameter, <alert>word</alert>, and <alert>returns</alert>a slice of length three from the front of word.  However, if word has length less than three, then the <c>None</c> object is returned instead.</p>
        <p>Hint: Use an if-else decision and the slicing operator [ : ] to solve this problem.</p>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="40%" />
          <col top="minor" width="60%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Test</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>word = "happy"
if type(first_three(word)) != type("ok"):
    print("error")
else:
    print(first_three(word))                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>hap</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>word = "dog"
if type(first_three(word)) != type("ok"):
    print("error")
else:
    print(first_three(word))                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>dog</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>word = ""
if type(first_three(word)) != type(None):
    print("error")
else:
    print(first_three(word))                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>None</cd>
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">_my_out = ""
_my_in = []
_datafiles = {}

# Start of FileLike
class FileLike:
  def __init__(self, contents):
    self.contents = contents
    self.cursor = 0

  def __enter__(self):
    return self

  def __exit__(self, exc_type, exc_value, traceback):
    self.close()

  def tell(self):
    return self.cursor

  def seek(self, n):
    self.cursor = n

  def read(self):
    n = self.cursor
    self.cursor = max(n, len(self.contents))
    return self.contents[n:]

  def readline(self):
    n = self.cursor
    rest = self.contents[n:]
    index = rest.find("\n")
    if index == -1:
      self.cursor = len(self.contents)
      return rest
    index += 1
    self.cursor = n + index
    return rest[:index]

  def readlines(self):
    results = []
    while True:
      line = self.readline()
      if line == '':
        return results
      results.append(line)

  def close(self):
    pass

# End of FileLike

def open(fname, mode = "r"):
  """our own open"""
  if fname in _datafiles:
    return FileLike(_datafiles[fname])
  raise BaseException(f"File not found: {fname}")


def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise EOFError()
  return _my_in.pop()

None

        </preamble>
        <code>

        </code>
        <postamble visible="no">
        </postamble>
        <tests>import re

RIGHT_WHITESPACE_TRIMMER = re.compile("\\s+(?=\\n|$)")


from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')
    
    word = "happy"
    if type(first_three(word)) != type("ok"):
        print("error")
    else:
        print(first_three(word))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'hap\n'.strip(), "Test: " + 'word = "happy"\nif type(first_three(word)) != type("ok"):\n    print("error")\nelse:\n    print(first_three(word))')


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')
    
    word = "NO"
    if type(first_three(word)) != type(None):
        print("error")
    else:
        print(first_three(word))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'None\n'.strip(), "Test: " + 'word = "NO"\nif type(first_three(word)) != type(None):\n    print("error")\nelse:\n    print(first_three(word))')


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')
    
    word = "dog"
    if type(first_three(word)) != type("ok"):
        print("error")
    else:
        print(first_three(word))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'dog\n'.strip(), "Test: " + 'word = "dog"\nif type(first_three(word)) != type("ok"):\n    print("error")\nelse:\n    print(first_three(word))')


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')
    
    word = ""
    if type(first_three(word)) != type(None):
        print("error")
    else:
        print(first_three(word))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'None\n'.strip(), "Test: " + 'word = ""\nif type(first_three(word)) != type(None):\n    print("error")\nelse:\n    print(first_three(word))')


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')
    
    word = "Mississippi"
    if type(first_three(word)) != type("ok"):
        print("error")
    else:
        print(first_three(word))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'Mis\n'.strip(), "Test: " + 'word = "Mississippi"\nif type(first_three(word)) != type("ok"):\n    print("error")\nelse:\n    print(first_three(word))')


  def test6(self):
    resetMyStdOut()
    setMyStdIn('')
    
    word = "SPAM"
    if type(first_three(word)) != type("ok"):
        print("error")
    else:
        print(first_three(word))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'SPA\n'.strip(), "Test: " + 'word = "SPAM"\nif type(first_three(word)) != type("ok"):\n    print("error")\nelse:\n    print(first_three(word))')


  def test7(self):
    resetMyStdOut()
    setMyStdIn('')
    
    word = "!@#$%^&amp;*"
    if type(first_three(word)) != type("ok"):
        print("error")
    else:
        print(first_three(word))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '!@#\n'.strip(), "Test: " + 'word = "!@#$%^&amp;*"\nif type(first_three(word)) != type("ok"):\n    print("error")\nelse:\n    print(first_three(word))')


  def test8(self):
    resetMyStdOut()
    setMyStdIn('')
    
    word = "h"
    if type(first_three(word)) != type(None):
        print("error")
    else:
        print(first_three(word))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'None\n'.strip(), "Test: " + 'word = "h"\nif type(first_three(word)) != type(None):\n    print("error")\nelse:\n    print(first_three(word))')



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-slice_end-2" label="exe-sec-HW5-PRACTICE-1-31920">
      <title />
      <statement>
        <h3>Slice the End of a String</h3>
        <p>The function <c>slice_end</c> takes a string parameter, <alert>word</alert>, and a positive integer <alert>n</alert>; the function <alert>returns</alert>a slice of length n from the end of word.  However, if word has length less than n, then the <alert>None</alert> object is returned instead.</p>
        <p>Hint: Notice that <em>returning the empty string when n is zero</em>might be a special case.</p>
        <p>You can use an if-elif-else decision structure and the slicing operator [ : ] to solve this problem.</p>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="40%" />
          <col top="minor" width="60%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Test</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>word = "pineapple"
n = 5
print(slice_end(word, n))                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>apple</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>word = "too short"
n = 20
print(slice_end(word, n))                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>None</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>word = "llama"
n = 0
print(slice_end(word, n))                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd />
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>word = "Saturn"
n = 6
print(slice_end(word, n))                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>Saturn</cd>
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">_my_out = ""
_my_in = []
_datafiles = {}

# Start of FileLike
class FileLike:
  def __init__(self, contents):
    self.contents = contents
    self.cursor = 0

  def __enter__(self):
    return self

  def __exit__(self, exc_type, exc_value, traceback):
    self.close()

  def tell(self):
    return self.cursor

  def seek(self, n):
    self.cursor = n

  def read(self):
    n = self.cursor
    self.cursor = max(n, len(self.contents))
    return self.contents[n:]

  def readline(self):
    n = self.cursor
    rest = self.contents[n:]
    index = rest.find("\n")
    if index == -1:
      self.cursor = len(self.contents)
      return rest
    index += 1
    self.cursor = n + index
    return rest[:index]

  def readlines(self):
    results = []
    while True:
      line = self.readline()
      if line == '':
        return results
      results.append(line)

  def close(self):
    pass

# End of FileLike

def open(fname, mode = "r"):
  """our own open"""
  if fname in _datafiles:
    return FileLike(_datafiles[fname])
  raise BaseException(f"File not found: {fname}")


def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise EOFError()
  return _my_in.pop()

None

        </preamble>
        <code>

        </code>
        <postamble visible="no">
        </postamble>
        <tests>import re

RIGHT_WHITESPACE_TRIMMER = re.compile("\\s+(?=\\n|$)")


from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')
    
    word = "pineapple"
    n = 5
    print(slice_end(word, n))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'apple\n'.strip(), "Test: " + 'word = "pineapple"\nn = 5\nprint(slice_end(word, n))')


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')
    
    word = "Enchilada"
    n = 7
    print(slice_end(word, n))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'chilada\n'.strip(), "Test: " + 'word = "Enchilada"\nn = 7\nprint(slice_end(word, n))')


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')
    
    word = "too short"
    n = 20
    print(slice_end(word, n))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'None\n'.strip(), "Test: " + 'word = "too short"\nn = 20\nprint(slice_end(word, n))')


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')
    
    word = "llama"
    n = 0
    print(slice_end(word, n))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), ''.strip(), "Test: " + 'word = "llama"\nn = 0\nprint(slice_end(word, n))')


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')
    
    word = "Washington"
    n = 1
    print(slice_end(word, n))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'n\n'.strip(), "Test: " + 'word = "Washington"\nn = 1\nprint(slice_end(word, n))')


  def test6(self):
    resetMyStdOut()
    setMyStdIn('')
    
    word = "Saturn"
    n = 6
    print(slice_end(word, n))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'Saturn\n'.strip(), "Test: " + 'word = "Saturn"\nn = 6\nprint(slice_end(word, n))')


  def test7(self):
    resetMyStdOut()
    setMyStdIn('')
    
    word = "Hanover College"
    n = 7
    print(slice_end(word, n))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'College\n'.strip(), "Test: " + 'word = "Hanover College"\nn = 7\nprint(slice_end(word, n))')


  def test8(self):
    resetMyStdOut()
    setMyStdIn('')
    
    word = "Hanover College"
    n = len(word) + 1
    print(slice_end(word, n))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'None\n'.strip(), "Test: " + 'word = "Hanover College"\nn = len(word) + 1\nprint(slice_end(word, n))')


  def test9(self):
    resetMyStdOut()
    setMyStdIn('')
    
    word = "Hanover College"
    n = len(word) - 2
    print(slice_end(word, n))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'nover College\n'.strip(), "Test: " + 'word = "Hanover College"\nn = len(word) - 2\nprint(slice_end(word, n))')


  def test10(self):
    resetMyStdOut()
    setMyStdIn('')
    
    word = "Hanover College"
    n = 0
    print(slice_end(word, n))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), ''.strip(), "Test: " + 'word = "Hanover College"\nn = 0\nprint(slice_end(word, n))')



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-slice_middle-2" label="exe-sec-HW5-PRACTICE-1-31924">
      <title>Slice the Middle of a String</title>
      <statement>
        <p>The function <c>slice_middle</c> takes a string parameter, <alert><c>word</c>.</alert></p>
        <p>
          <ul>
            <li>If the length of word is less than 3, the function returns the <alert>empty</alert> string.</li>
            <li>Otherwise, the function returns a substring made of all but the first and last characters in word.</li>
          </ul>
        </p>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="40%" />
          <col top="minor" width="60%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Test</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>print(slice_middle("onion"))</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>nio</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>print(slice_middle("?"))</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd />
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>print(slice_middle("slicing"))</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>licin</cd>
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">_my_out = ""
_my_in = []
_datafiles = {}

# Start of FileLike
class FileLike:
  def __init__(self, contents):
    self.contents = contents
    self.cursor = 0

  def __enter__(self):
    return self

  def __exit__(self, exc_type, exc_value, traceback):
    self.close()

  def tell(self):
    return self.cursor

  def seek(self, n):
    self.cursor = n

  def read(self):
    n = self.cursor
    self.cursor = max(n, len(self.contents))
    return self.contents[n:]

  def readline(self):
    n = self.cursor
    rest = self.contents[n:]
    index = rest.find("\n")
    if index == -1:
      self.cursor = len(self.contents)
      return rest
    index += 1
    self.cursor = n + index
    return rest[:index]

  def readlines(self):
    results = []
    while True:
      line = self.readline()
      if line == '':
        return results
      results.append(line)

  def close(self):
    pass

# End of FileLike

def open(fname, mode = "r"):
  """our own open"""
  if fname in _datafiles:
    return FileLike(_datafiles[fname])
  raise BaseException(f"File not found: {fname}")


def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise EOFError()
  return _my_in.pop()

None

        </preamble>
        <code>

        </code>
        <postamble visible="no">
        </postamble>
        <tests>import re

RIGHT_WHITESPACE_TRIMMER = re.compile("\\s+(?=\\n|$)")


from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(slice_middle("onion"))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'nio\n'.strip(), "Test: " + 'print(slice_middle("onion"))')


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(slice_middle("dam"))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'a\n'.strip(), "Test: " + 'print(slice_middle("dam"))')


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(slice_middle("?"))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), ''.strip(), "Test: " + 'print(slice_middle("?"))')


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(slice_middle("PIZZA"))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'IZZ\n'.strip(), "Test: " + 'print(slice_middle("PIZZA"))')


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(slice_middle("abracadabra"))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'bracadabr\n'.strip(), "Test: " + 'print(slice_middle("abracadabra"))')


  def test6(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(slice_middle("slicing"))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'licin\n'.strip(), "Test: " + 'print(slice_middle("slicing"))')


  def test7(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(slice_middle(""))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), ''.strip(), "Test: " + 'print(slice_middle(""))')


  def test8(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(slice_middle("factorial"))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'actoria\n'.strip(), "Test: " + 'print(slice_middle("factorial"))')


  def test9(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(slice_middle("pqr"))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'q\n'.strip(), "Test: " + 'print(slice_middle("pqr"))')


  def test10(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(slice_middle("ab"))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), ''.strip(), "Test: " + 'print(slice_middle("ab"))')


  def test11(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(slice_middle("x"))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), ''.strip(), "Test: " + 'print(slice_middle("x"))')



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-add_char_counts-2" label="exe-sec-HW5-PRACTICE-1-30807">
      <title>Add Character Counts</title>
      <statement>
        <p>The function <c>add_char_counts</c> takes three parameters: a string <c>s</c> and two strings of length 1, <c>char1</c> and <c>char2</c>, and returns the total number of times either char1 or char2 appears in s.</p>
        <p>For example, the word "scallions" has 2 s's and 1 n, so <c>add_char_counts("scallions", "s", "n")</c> returns 3.</p>
        <p>Hint: Use a <alert>string method</alert> to help solve this problem (<c>count</c>).  You do not need an accumulator.</p>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="40%" />
          <col top="minor" width="60%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Test</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>print(add_char_counts('Indiana', 'a', 'b'))</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>2</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>print(add_char_counts('BAHAMAS', 'A', 'B'))</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>4</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>print(add_char_counts('Mississippi', 'i', 'M'))</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>5</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>print(add_char_counts("spam spam spam spam", "s", "p"))</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>8</cd>
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">_my_out = ""
_my_in = []
_datafiles = {}

# Start of FileLike
class FileLike:
  def __init__(self, contents):
    self.contents = contents
    self.cursor = 0

  def __enter__(self):
    return self

  def __exit__(self, exc_type, exc_value, traceback):
    self.close()

  def tell(self):
    return self.cursor

  def seek(self, n):
    self.cursor = n

  def read(self):
    n = self.cursor
    self.cursor = max(n, len(self.contents))
    return self.contents[n:]

  def readline(self):
    n = self.cursor
    rest = self.contents[n:]
    index = rest.find("\n")
    if index == -1:
      self.cursor = len(self.contents)
      return rest
    index += 1
    self.cursor = n + index
    return rest[:index]

  def readlines(self):
    results = []
    while True:
      line = self.readline()
      if line == '':
        return results
      results.append(line)

  def close(self):
    pass

# End of FileLike

def open(fname, mode = "r"):
  """our own open"""
  if fname in _datafiles:
    return FileLike(_datafiles[fname])
  raise BaseException(f"File not found: {fname}")


def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise EOFError()
  return _my_in.pop()

None

        </preamble>
        <code>

        </code>
        <postamble visible="no">
        </postamble>
        <tests>import re

RIGHT_WHITESPACE_TRIMMER = re.compile("\\s+(?=\\n|$)")


from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(add_char_counts('Indiana', 'a', 'b'))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '2\n'.strip(), "Test: " + "print(add_char_counts('Indiana', 'a', 'b'))")


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(add_char_counts('BAHAMAS', 'A', 'B'))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '4'.strip(), "Test: " + "print(add_char_counts('BAHAMAS', 'A', 'B'))")


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(add_char_counts('Mississippi', 'i', 'M'))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '5\n'.strip(), "Test: " + "print(add_char_counts('Mississippi', 'i', 'M'))")


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(add_char_counts('pumpkin', 'e', 'g'))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '0'.strip(), "Test: " + "print(add_char_counts('pumpkin', 'e', 'g'))")


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(add_char_counts("=:^.^:=", "=", "."))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '3'.strip(), "Test: " + 'print(add_char_counts("=:^.^:=", "=", "."))')


  def test6(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(add_char_counts("spam spam spam spam", "s", "p"))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '8\n'.strip(), "Test: " + 'print(add_char_counts("spam spam spam spam", "s", "p"))')


  def test7(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(add_char_counts('soupspoons', 's', 'o'))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '6'.strip(), "Test: " + "print(add_char_counts('soupspoons', 's', 'o'))")


  def test8(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(add_char_counts('honorificabilitudinitatibus', 't', 'i'))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '10'.strip(), "Test: " + "print(add_char_counts('honorificabilitudinitatibus', 't', 'i'))")


  def test9(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(add_char_counts('Twyndyllyngs', 'y', 'z'))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '3'.strip(), "Test: " + "print(add_char_counts('Twyndyllyngs', 'y', 'z'))")


  def test10(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(add_char_counts('abracadabra', 'a', 'a'))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '10'.strip(), "Test: " + "print(add_char_counts('abracadabra', 'a', 'a'))")


  def test11(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(add_char_counts('She sells sea shells down by the sea shore.', ' ', 's'))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '15'.strip(), "Test: " + "print(add_char_counts('She sells sea shells down by the sea shore.', ' ', 's'))")



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-count_words_of_length_ACCUM-2" label="exe-sec-HW5-PRACTICE-1-31943">
      <title>Count Words of a Given Length</title>
      <statement>
        <p>The function <c>countWordsOfLength</c> takes a list of words L and an integer <c>n</c>, and returns the total number of <alert>words of length n</alert> that appear in the list. For example, <c>countWordsOfLength(["yes", "no", "maybe", "NNOOO"], 5)</c> would return 2 because the given list has two words of length 5.</p>
        <p>Hint: Use the <alert>accumulator</alert> pattern to solve this problem. Inside the for loop, use an <alert>if</alert>statement to only update the accumulator when the current word has length n.</p>
        <p>Hint: Instead of using a for loop with a <c>range</c>, you can iterate directly over  the elements of L.</p>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="40%" />
          <col top="minor" width="60%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Test</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>L = ['a', 'b', 'c', 'de', 'fgh', 'i', 'jkl']
print(countWordsOfLength(L, 1))                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>4</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>L = ['a', 'b', 'c', 'de', 'fgh', 'i', 'jkl']
print(countWordsOfLength(L, 5))                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>0</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>L = ['bacon', 'onion', 'pepper', 'garlic', 'paprika', 'chipotle chili powder', 'salt', 'black pepper', 'vinegar', 'bbq sauce', 'ketchup', 'mustard', 'brown sugar', 'beans']
print(countWordsOfLength(L, 5))                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>3</cd>
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">_my_out = ""
_my_in = []
_datafiles = {}

# Start of FileLike
class FileLike:
  def __init__(self, contents):
    self.contents = contents
    self.cursor = 0

  def __enter__(self):
    return self

  def __exit__(self, exc_type, exc_value, traceback):
    self.close()

  def tell(self):
    return self.cursor

  def seek(self, n):
    self.cursor = n

  def read(self):
    n = self.cursor
    self.cursor = max(n, len(self.contents))
    return self.contents[n:]

  def readline(self):
    n = self.cursor
    rest = self.contents[n:]
    index = rest.find("\n")
    if index == -1:
      self.cursor = len(self.contents)
      return rest
    index += 1
    self.cursor = n + index
    return rest[:index]

  def readlines(self):
    results = []
    while True:
      line = self.readline()
      if line == '':
        return results
      results.append(line)

  def close(self):
    pass

# End of FileLike

def open(fname, mode = "r"):
  """our own open"""
  if fname in _datafiles:
    return FileLike(_datafiles[fname])
  raise BaseException(f"File not found: {fname}")


def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise EOFError()
  return _my_in.pop()

None

        </preamble>
        <code>

        </code>
        <postamble visible="no">
        </postamble>
        <tests>import re

RIGHT_WHITESPACE_TRIMMER = re.compile("\\s+(?=\\n|$)")


from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = ['a', 'b', 'c', 'de', 'fgh', 'i', 'jkl']
    print(countWordsOfLength(L, 1))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '4\n'.strip(), "Test: " + "L = ['a', 'b', 'c', 'de', 'fgh', 'i', 'jkl']\nprint(countWordsOfLength(L, 1))")


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = ['a', 'b', 'c', 'de', 'fgh', 'i', 'jkl']
    print(countWordsOfLength(L, 3))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '2\n'.strip(), "Test: " + "L = ['a', 'b', 'c', 'de', 'fgh', 'i', 'jkl']\nprint(countWordsOfLength(L, 3))")


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = ['a', 'b', 'c', 'de', 'fgh', 'i', 'jkl']
    print(countWordsOfLength(L, 5))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '0'.strip(), "Test: " + "L = ['a', 'b', 'c', 'de', 'fgh', 'i', 'jkl']\nprint(countWordsOfLength(L, 5))")


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = ['bacon', 'onion', 'pepper', 'garlic', 'paprika', 'chipotle chili powder', 'salt', 'black pepper', 'vinegar', 'bbq sauce', 'ketchup', 'mustard', 'brown sugar', 'beans']
    print(countWordsOfLength(L, 12))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '1'.strip(), "Test: " + "L = ['bacon', 'onion', 'pepper', 'garlic', 'paprika', 'chipotle chili powder', 'salt', 'black pepper', 'vinegar', 'bbq sauce', 'ketchup', 'mustard', 'brown sugar', 'beans']\nprint(countWordsOfLength(L, 12))")


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = ['bacon', 'onion', 'pepper', 'garlic', 'paprika', 'chipotle chili powder', 'salt', 'black pepper', 'vinegar', 'bbq sauce', 'ketchup', 'mustard', 'brown sugar', 'beans']
    print(countWordsOfLength(L, 7))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '4\n'.strip(), "Test: " + "L = ['bacon', 'onion', 'pepper', 'garlic', 'paprika', 'chipotle chili powder', 'salt', 'black pepper', 'vinegar', 'bbq sauce', 'ketchup', 'mustard', 'brown sugar', 'beans']\nprint(countWordsOfLength(L, 7))")


  def test6(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = ['bacon', 'onion', 'pepper', 'garlic', 'paprika', 'chipotle chili powder', 'salt', 'black pepper', 'vinegar', 'bbq sauce', 'ketchup', 'mustard', 'brown sugar', 'beans']
    print(countWordsOfLength(L, 5))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '3\n'.strip(), "Test: " + "L = ['bacon', 'onion', 'pepper', 'garlic', 'paprika', 'chipotle chili powder', 'salt', 'black pepper', 'vinegar', 'bbq sauce', 'ketchup', 'mustard', 'brown sugar', 'beans']\nprint(countWordsOfLength(L, 5))")


  def test7(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = ['bacon', 'onion', 'pepper', 'garlic', 'paprika', 'chipotle chili powder', 'salt', 'black pepper', 'vinegar', 'bbq sauce', 'ketchup', 'mustard', 'brown sugar', 'beans']
    print(countWordsOfLength(L, 0))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '0\n'.strip(), "Test: " + "L = ['bacon', 'onion', 'pepper', 'garlic', 'paprika', 'chipotle chili powder', 'salt', 'black pepper', 'vinegar', 'bbq sauce', 'ketchup', 'mustard', 'brown sugar', 'beans']\nprint(countWordsOfLength(L, 0))")


  def test8(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = []
    print(countWordsOfLength(L, 5))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '0\n'.strip(), "Test: " + 'L = []\nprint(countWordsOfLength(L, 5))')


  def test9(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = ["just one thing here"]
    print(countWordsOfLength(L, 5))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '0\n'.strip(), "Test: " + 'L = ["just one thing here"]\nprint(countWordsOfLength(L, 5))')



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-make_abbreviation-2" label="exe-sec-HW5-PRACTICE-1-31995">
      <title>Make Abbreviation</title>
      <statement>
        <p>The function <c>make_abbreviation</c> takes one parameter, <c>wordlist</c>, a list of words, and produces an acronym out of the words in the list, with a period after each initial character.  The function returns the resulting acronym string.</p>
        <p>For example, the input <c>["International", "Business", "Machines"]</c> would cause the function to return <c>"I.B.M."</c></p>
        <p>Write a function definition for <c>make_abbreviation</c>.</p>
        <p>Hint: Use the accumulate-a-string pattern.</p>
        <p>- Initialize the accumulator variable to <c>""</c>, the empty string.</p>
        <p>- Iterate w over the items <c>wordlist</c></p>
        <p>- Inside the <alert>for</alert> loop, update the accumulator variable by concatenating it with the first character in the current word as well as a period.</p>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="40%" />
          <col top="minor" width="60%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Test</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>wordlist = ["Post", "Meridiem"]
print(make_abbreviation(wordlist))                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>P.M.</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>wordlist = ["Joint", "Photographic", "Experts", "Group"]
print(make_abbreviation(wordlist))                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>J.P.E.G.</cd>
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">_my_out = ""
_my_in = []
_datafiles = {}

# Start of FileLike
class FileLike:
  def __init__(self, contents):
    self.contents = contents
    self.cursor = 0

  def __enter__(self):
    return self

  def __exit__(self, exc_type, exc_value, traceback):
    self.close()

  def tell(self):
    return self.cursor

  def seek(self, n):
    self.cursor = n

  def read(self):
    n = self.cursor
    self.cursor = max(n, len(self.contents))
    return self.contents[n:]

  def readline(self):
    n = self.cursor
    rest = self.contents[n:]
    index = rest.find("\n")
    if index == -1:
      self.cursor = len(self.contents)
      return rest
    index += 1
    self.cursor = n + index
    return rest[:index]

  def readlines(self):
    results = []
    while True:
      line = self.readline()
      if line == '':
        return results
      results.append(line)

  def close(self):
    pass

# End of FileLike

def open(fname, mode = "r"):
  """our own open"""
  if fname in _datafiles:
    return FileLike(_datafiles[fname])
  raise BaseException(f"File not found: {fname}")


def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise EOFError()
  return _my_in.pop()

None

        </preamble>
        <code>

        </code>
        <postamble visible="no">
        </postamble>
        <tests>import re

RIGHT_WHITESPACE_TRIMMER = re.compile("\\s+(?=\\n|$)")


from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')
    
    wordlist = ["Post", "Meridiem"]
    print(make_abbreviation(wordlist))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'P.M.'.strip(), "Test: " + 'wordlist = ["Post", "Meridiem"]\nprint(make_abbreviation(wordlist))')


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')
    
    wordlist = ["Joint", "Photographic", "Experts", "Group"]
    print(make_abbreviation(wordlist))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'J.P.E.G.'.strip(), "Test: " + 'wordlist = ["Joint", "Photographic", "Experts", "Group"]\nprint(make_abbreviation(wordlist))')


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')
    
    wordlist = ["Subscriber's", "Identification", "Module"]
    print(make_abbreviation(wordlist))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'S.I.M.'.strip(), "Test: " + 'wordlist = ["Subscriber\'s", "Identification", "Module"]\nprint(make_abbreviation(wordlist))')


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')
    
    wordlist = ["What", "You", "See", "Is", "What", "You", "Get"]
    print(make_abbreviation(wordlist))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'W.Y.S.I.W.Y.G.'.strip(), "Test: " + 'wordlist = ["What", "You", "See", "Is", "What", "You", "Get"]\nprint(make_abbreviation(wordlist))')


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')
    
    wordlist = ["Monsieur"]
    print(make_abbreviation(wordlist))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'M.'.strip(), "Test: " + 'wordlist = ["Monsieur"]\nprint(make_abbreviation(wordlist))')


  def test6(self):
    resetMyStdOut()
    setMyStdIn('')
    
    wordlist = ["Vital", "Information", "Resources", "Under", "Seige"]
    print(make_abbreviation(wordlist))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'V.I.R.U.S.'.strip(), "Test: " + 'wordlist = ["Vital", "Information", "Resources", "Under", "Seige"]\nprint(make_abbreviation(wordlist))')


  def test7(self):
    resetMyStdOut()
    setMyStdIn('')
    
    wordlist = ["Wonderful", "Exciting", "Interesting", "Real", "Different"]
    print(make_abbreviation(wordlist))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'W.E.I.R.D.'.strip(), "Test: " + 'wordlist = ["Wonderful", "Exciting", "Interesting", "Real", "Different"]\nprint(make_abbreviation(wordlist))')


  def test8(self):
    resetMyStdOut()
    setMyStdIn('')
    
    wordlist = ["Bubbly", "Aromatic", "Therapeutic", "Hot"]
    print(make_abbreviation(wordlist))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'B.A.T.H.'.strip(), "Test: " + 'wordlist = ["Bubbly", "Aromatic", "Therapeutic", "Hot"]\nprint(make_abbreviation(wordlist))')



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-accum_count_contains_x-2" label="exe-sec-HW5-PRACTICE-1-161050">
      <title>Count Contains 'X' or 'x'</title>
      <statement>
        <p>The function <c>count_contains_x</c> takes a list of strings (<c>wordList</c>) and <alert>returns</alert>the count of how many strings in the list contain at least one upper- or lower-case 'x'.</p>
        <p>Hint: Use the accumulator pattern to accumulate the count.</p>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="40%" />
          <col top="minor" width="60%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Test</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>wordList = ["xerox", "OXEN", "whiffleball", "XOXOX"]
print(count_contains_x(wordList))                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>3</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>fish = ["angel", "gold", "cat", "puffer", "damsel"]
print(count_contains_x(fish))                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>0</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>wordList = ["X", "x"]
print(count_contains_x(wordList))                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>2</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>list_of_one_x = ["x"]
print(count_contains_x(list_of_one_x))                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>1</cd>
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">_my_out = ""
_my_in = []
_datafiles = {}

# Start of FileLike
class FileLike:
  def __init__(self, contents):
    self.contents = contents
    self.cursor = 0

  def __enter__(self):
    return self

  def __exit__(self, exc_type, exc_value, traceback):
    self.close()

  def tell(self):
    return self.cursor

  def seek(self, n):
    self.cursor = n

  def read(self):
    n = self.cursor
    self.cursor = max(n, len(self.contents))
    return self.contents[n:]

  def readline(self):
    n = self.cursor
    rest = self.contents[n:]
    index = rest.find("\n")
    if index == -1:
      self.cursor = len(self.contents)
      return rest
    index += 1
    self.cursor = n + index
    return rest[:index]

  def readlines(self):
    results = []
    while True:
      line = self.readline()
      if line == '':
        return results
      results.append(line)

  def close(self):
    pass

# End of FileLike

def open(fname, mode = "r"):
  """our own open"""
  if fname in _datafiles:
    return FileLike(_datafiles[fname])
  raise BaseException(f"File not found: {fname}")


def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise EOFError()
  return _my_in.pop()

None

        </preamble>
        <code>

        </code>
        <postamble visible="no">
        </postamble>
        <tests>import re

RIGHT_WHITESPACE_TRIMMER = re.compile("\\s+(?=\\n|$)")


from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')
    
    wordList = ["xerox", "OXEN", "whiffleball", "XOXOX"]
    print(count_contains_x(wordList))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '3\n'.strip(), "Test: " + 'wordList = ["xerox", "OXEN", "whiffleball", "XOXOX"]\nprint(count_contains_x(wordList))')


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')
    
    fish = ["angel", "gold", "cat", "puffer", "damsel"]
    print(count_contains_x(fish))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '0'.strip(), "Test: " + 'fish = ["angel", "gold", "cat", "puffer", "damsel"]\nprint(count_contains_x(fish))')


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')
    
    wordList = ["X", "x"]
    print(count_contains_x(wordList))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '2'.strip(), "Test: " + 'wordList = ["X", "x"]\nprint(count_contains_x(wordList))')


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')
    
    empty = []
    print(count_contains_x(empty))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '0'.strip(), "Test: " + 'empty = []\nprint(count_contains_x(empty))')


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = ["OXYGEN"]
    print(count_contains_x(L))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '1'.strip(), "Test: " + 'L = ["OXYGEN"]\nprint(count_contains_x(L))')


  def test6(self):
    resetMyStdOut()
    setMyStdIn('')
    
    list_of_one_x = ["x"]
    print(count_contains_x(list_of_one_x))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '1'.strip(), "Test: " + 'list_of_one_x = ["x"]\nprint(count_contains_x(list_of_one_x))')


  def test7(self):
    resetMyStdOut()
    setMyStdIn('')
    
    instruments = ["Box drum", "Paixiao", "Saxophone", "Txistu", "Xalam", "Xaphoon", "Xun", "Xylophone", "Bari Sax"]
    print(count_contains_x(instruments))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '9\n'.strip(), "Test: " + 'instruments = ["Box drum", "Paixiao", "Saxophone", "Txistu", "Xalam", "Xaphoon", "Xun", "Xylophone", "Bari Sax"]\nprint(count_contains_x(instruments))')


  def test8(self):
    resetMyStdOut()
    setMyStdIn('')
    
    wordList = ["atari", "x-box", "nintendo"]
    print(count_contains_x(wordList))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '1\n'.strip(), "Test: " + 'wordList = ["atari", "x-box", "nintendo"]\nprint(count_contains_x(wordList))')


  def test9(self):
    resetMyStdOut()
    setMyStdIn('')
    
    wordList = ['pixxxel', 'Xanadu', 'pEnGuInZ', 'piXXa', 'tomatox', 'alpaca', 'Matrix']
    print(count_contains_x(wordList))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '5\n'.strip(), "Test: " + "wordList = ['pixxxel', 'Xanadu', 'pEnGuInZ', 'piXXa', 'tomatox', 'alpaca', 'Matrix']\nprint(count_contains_x(wordList))")



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-accum_remove_vowels-2" label="exe-sec-HW5-PRACTICE-1-31997">
      <title>Remove Vowels</title>
      <statement>
        <p>The function <c>remove_vowels</c> takes one parameter, <c>s</c>,<alert></alert>a string of any length. The function then returns<alert></alert>a new string that contains all the letters in <c>s</c> except for the vowels: 'a', 'e', 'i', 'o', 'u'.</p>
        <p>You may assume the string contains no upper-case letters.</p>
        <p><alert>Hint</alert>: Accumulate the new string.</p>
        <p>- Use a for loop to iterate over the characters in s</p>
        <p>- Inside the loop, update the accumulator if the current character is not a lowercase vowel ( <c>if ch</c><c>not in 'aeiou'</c> )</p>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="40%" />
          <col top="minor" width="60%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Test</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>print(remove_vowels("giraffe"))</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>grff</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>print(remove_vowels("love bug"))</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>lv bg</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>print(remove_vowels("racecar"))</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>rccr</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>print(remove_vowels("uoiea"))</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd />
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">_my_out = ""
_my_in = []
_datafiles = {}

# Start of FileLike
class FileLike:
  def __init__(self, contents):
    self.contents = contents
    self.cursor = 0

  def __enter__(self):
    return self

  def __exit__(self, exc_type, exc_value, traceback):
    self.close()

  def tell(self):
    return self.cursor

  def seek(self, n):
    self.cursor = n

  def read(self):
    n = self.cursor
    self.cursor = max(n, len(self.contents))
    return self.contents[n:]

  def readline(self):
    n = self.cursor
    rest = self.contents[n:]
    index = rest.find("\n")
    if index == -1:
      self.cursor = len(self.contents)
      return rest
    index += 1
    self.cursor = n + index
    return rest[:index]

  def readlines(self):
    results = []
    while True:
      line = self.readline()
      if line == '':
        return results
      results.append(line)

  def close(self):
    pass

# End of FileLike

def open(fname, mode = "r"):
  """our own open"""
  if fname in _datafiles:
    return FileLike(_datafiles[fname])
  raise BaseException(f"File not found: {fname}")


def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise EOFError()
  return _my_in.pop()

None

        </preamble>
        <code>

        </code>
        <postamble visible="no">
        </postamble>
        <tests>import re

RIGHT_WHITESPACE_TRIMMER = re.compile("\\s+(?=\\n|$)")


from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(remove_vowels("giraffe"))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'grff'.strip(), "Test: " + 'print(remove_vowels("giraffe"))')


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(remove_vowels("love bug"))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'lv bg'.strip(), "Test: " + 'print(remove_vowels("love bug"))')


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(remove_vowels("racecar"))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'rccr'.strip(), "Test: " + 'print(remove_vowels("racecar"))')


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(remove_vowels("iota"))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 't'.strip(), "Test: " + 'print(remove_vowels("iota"))')


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(remove_vowels("queue"))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'q'.strip(), "Test: " + 'print(remove_vowels("queue"))')


  def test6(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(remove_vowels("uoiea"))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), ''.strip(), "Test: " + 'print(remove_vowels("uoiea"))')


  def test7(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(remove_vowels("alpacas are cute"))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'lpcs r ct\n'.strip(), "Test: " + 'print(remove_vowels("alpacas are cute"))')


  def test8(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(remove_vowels("gypsy moth"))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'gypsy mth'.strip(), "Test: " + 'print(remove_vowels("gypsy moth"))')


  def test9(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(remove_vowels("cheetah"))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'chth\n'.strip(), "Test: " + 'print(remove_vowels("cheetah"))')


  def test10(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(remove_vowels("aieeioouuaiieeaiaoox"))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'x\n'.strip(), "Test: " + 'print(remove_vowels("aieeioouuaiieeaiaoox"))')



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-decode_ascii_ACCUM-2" label="exe-sec-HW5-PRACTICE-1-30808">
      <title>Decode from ASCII</title>
      <statement>
        <p>The function <c>decodeFromAscii</c><c></c>takes a list <c>L</c> of integers in the range 32 through 126. Each item in L is an ASCII code representing a single printable character. The function accumulates the string of characters represented by the list of ASCII codes and returns that string.</p>
        <p>For example, <c>decodeFromAscii([78, 105, 99, 101, 33])</c> returns <c>"Nice!"</c> because N is chr(78), i is chr(105), c is chr(99), etc.</p>
        <p>Note: ASCII was created in the 1960's so programmers could have a standard encoding for common keyboard characters as numbers. It was later expanded to create Unicode so that characters from languages  other than English, mathematical symbols, and many other symbols could also be represented by numerical codes.</p>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="40%" />
          <col top="minor" width="60%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Test</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>print(decodeFromAscii([36, 49, 44, 48, 48, 48]))</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>$1,000</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>print(decodeFromAscii([115, 110, 111, 119]))</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>snow</cd>
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">_my_out = ""
_my_in = []
_datafiles = {}

# Start of FileLike
class FileLike:
  def __init__(self, contents):
    self.contents = contents
    self.cursor = 0

  def __enter__(self):
    return self

  def __exit__(self, exc_type, exc_value, traceback):
    self.close()

  def tell(self):
    return self.cursor

  def seek(self, n):
    self.cursor = n

  def read(self):
    n = self.cursor
    self.cursor = max(n, len(self.contents))
    return self.contents[n:]

  def readline(self):
    n = self.cursor
    rest = self.contents[n:]
    index = rest.find("\n")
    if index == -1:
      self.cursor = len(self.contents)
      return rest
    index += 1
    self.cursor = n + index
    return rest[:index]

  def readlines(self):
    results = []
    while True:
      line = self.readline()
      if line == '':
        return results
      results.append(line)

  def close(self):
    pass

# End of FileLike

def open(fname, mode = "r"):
  """our own open"""
  if fname in _datafiles:
    return FileLike(_datafiles[fname])
  raise BaseException(f"File not found: {fname}")


def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise EOFError()
  return _my_in.pop()

None

        </preamble>
        <code>

        </code>
        <postamble visible="no">
        </postamble>
        <tests>import re

RIGHT_WHITESPACE_TRIMMER = re.compile("\\s+(?=\\n|$)")


from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(decodeFromAscii([36, 49, 44, 48, 48, 48]))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '$1,000\n'.strip(), "Test: " + 'print(decodeFromAscii([36, 49, 44, 48, 48, 48]))')


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(decodeFromAscii([115, 110, 111, 119]))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'snow\n'.strip(), "Test: " + 'print(decodeFromAscii([115, 110, 111, 119]))')


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(decodeFromAscii([68, 79, 71, 83]))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'DOGS\n'.strip(), "Test: " + 'print(decodeFromAscii([68, 79, 71, 83]))')


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(decodeFromAscii([80, 121, 116, 104, 111, 110]))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'Python\n'.strip(), "Test: " + 'print(decodeFromAscii([80, 121, 116, 104, 111, 110]))')


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(decodeFromAscii([65, 115, 107, 32, 113, 117, 101, 115, 116, 105, 111, 110, 115, 46]))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'Ask questions.\n'.strip(), "Test: " + 'print(decodeFromAscii([65, 115, 107, 32, 113, 117, 101, 115, 116, 105, 111, 110, 115, 46]))')


  def test6(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(decodeFromAscii([84, 104, 105, 115, 32, 111, 110, 101, 32, 105, 115, 32, 115, 101, 99, 114, 101, 116, 33, 33, 33]))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'This one is secret!!!\n'.strip(), "Test: " + 'print(decodeFromAscii([84, 104, 105, 115, 32, 111, 110, 101, 32, 105, 115, 32, 115, 101, 99, 114, 101, 116, 33, 33, 33]))')



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-concat_alternate_characters_ACCUM-2" label="exe-sec-HW5-PRACTICE-1-30810">
      <title>Concatenate Alternating Characters</title>
      <statement>
        <p>The function <c>concatAltChars</c> takes a string parameter <c>s</c> and a boolean parameter <c>even</c>; the function concatenates together either the even-position characters of s or the odd-position characters of s, depending on whether even is True, or False, respectively. The accumulated string is returned.</p>
        <p>For example, the even-indexed characters of "HANOVER" are at indexes 0, 2, 4, and 6:  H N V R. So, <c>concatAltChars("HANOVER", True)</c>returns the string result <c>"HNVR"</c>.</p>
        <p>But <c>concatAltChars("HANOVER", False)</c> returns the string result <c>"AOE"</c>.</p>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="40%" />
          <col top="minor" width="60%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Test</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>s = "goldfinches"
print(concatAltChars(s, True))                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>glfnhs</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>s = "A"
print(concatAltChars(s, True))                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>A</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>s = "A"
print(concatAltChars(s, False))                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd />
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">_my_out = ""
_my_in = []
_datafiles = {}

# Start of FileLike
class FileLike:
  def __init__(self, contents):
    self.contents = contents
    self.cursor = 0

  def __enter__(self):
    return self

  def __exit__(self, exc_type, exc_value, traceback):
    self.close()

  def tell(self):
    return self.cursor

  def seek(self, n):
    self.cursor = n

  def read(self):
    n = self.cursor
    self.cursor = max(n, len(self.contents))
    return self.contents[n:]

  def readline(self):
    n = self.cursor
    rest = self.contents[n:]
    index = rest.find("\n")
    if index == -1:
      self.cursor = len(self.contents)
      return rest
    index += 1
    self.cursor = n + index
    return rest[:index]

  def readlines(self):
    results = []
    while True:
      line = self.readline()
      if line == '':
        return results
      results.append(line)

  def close(self):
    pass

# End of FileLike

def open(fname, mode = "r"):
  """our own open"""
  if fname in _datafiles:
    return FileLike(_datafiles[fname])
  raise BaseException(f"File not found: {fname}")


def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise EOFError()
  return _my_in.pop()

None

        </preamble>
        <code>

        </code>
        <postamble visible="no">
        </postamble>
        <tests>import re

RIGHT_WHITESPACE_TRIMMER = re.compile("\\s+(?=\\n|$)")


from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')
    
    s = "goldfinches"
    print(concatAltChars(s, True))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'glfnhs\n'.strip(), "Test: " + 's = "goldfinches"\nprint(concatAltChars(s, True))')


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')
    
    s = "A"
    print(concatAltChars(s, True))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'A\n'.strip(), "Test: " + 's = "A"\nprint(concatAltChars(s, True))')


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')
    
    s = "A"
    print(concatAltChars(s, False))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), ''.strip(), "Test: " + 's = "A"\nprint(concatAltChars(s, False))')


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')
    
    s = "some popular animals on Google search are shark, bear, and horse"
    print(concatAltChars(s, True))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'sm oua nml nGol erhaesak er n os\n'.strip(), "Test: " + 's = "some popular animals on Google search are shark, bear, and horse"\nprint(concatAltChars(s, True))')


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')
    
    s = "some popular animals on Google search are shark, bear, and horse"
    print(concatAltChars(s, False))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'oepplraiaso ogesac r hr,ba,adhre\n'.strip(), "Test: " + 's = "some popular animals on Google search are shark, bear, and horse"\nprint(concatAltChars(s, False))')


  def test6(self):
    resetMyStdOut()
    setMyStdIn('')
    
    s = "some popular animals on Google search are not bunny, worm, cow, sheep"
    print(concatAltChars(s, True))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'sm oua nml nGol erhaentbny om o,sep\n'.strip(), "Test: " + 's = "some popular animals on Google search are not bunny, worm, cow, sheep"\nprint(concatAltChars(s, True))')


  def test7(self):
    resetMyStdOut()
    setMyStdIn('')
    
    s = "some popular animals on Google search are not bunny, worm, cow, sheep"
    print(concatAltChars(s, False))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'oepplraiaso ogesac r o un,wr,cw he\n'.strip(), "Test: " + 's = "some popular animals on Google search are not bunny, worm, cow, sheep"\nprint(concatAltChars(s, False))')



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-string_has_repeat-2" label="exe-sec-HW5-PRACTICE-1-31054">
      <title>String Has Repeated Character?</title>
      <statement>
        <p>Write the code to define a function <c>has_repeat(mystr)</c>, which takes a string parameter and returns a boolean result.</p>
        <p>- If mystr has a character that is repeated (<c>count</c> is more than 1 for that character), return <alert>True</alert></p>
        <p>- Otherwise, return <alert>False</alert></p>
        <p>Hint: You can solve this problem by iterating over the characters in mystr and comparing each character's <c>count</c> with 1.</p>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="40%" />
          <col top="minor" width="60%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Test</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>print(has_repeat("Happy"))</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>True</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>print(has_repeat("sad"))</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>False</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>print(has_repeat("salmons"))</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>True</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>print(has_repeat("Trouts"))</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>False</cd>
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">_my_out = ""
_my_in = []
_datafiles = {}

# Start of FileLike
class FileLike:
  def __init__(self, contents):
    self.contents = contents
    self.cursor = 0

  def __enter__(self):
    return self

  def __exit__(self, exc_type, exc_value, traceback):
    self.close()

  def tell(self):
    return self.cursor

  def seek(self, n):
    self.cursor = n

  def read(self):
    n = self.cursor
    self.cursor = max(n, len(self.contents))
    return self.contents[n:]

  def readline(self):
    n = self.cursor
    rest = self.contents[n:]
    index = rest.find("\n")
    if index == -1:
      self.cursor = len(self.contents)
      return rest
    index += 1
    self.cursor = n + index
    return rest[:index]

  def readlines(self):
    results = []
    while True:
      line = self.readline()
      if line == '':
        return results
      results.append(line)

  def close(self):
    pass

# End of FileLike

def open(fname, mode = "r"):
  """our own open"""
  if fname in _datafiles:
    return FileLike(_datafiles[fname])
  raise BaseException(f"File not found: {fname}")


def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise EOFError()
  return _my_in.pop()

None

        </preamble>
        <code>

        </code>
        <postamble visible="no">
        </postamble>
        <tests>import re

RIGHT_WHITESPACE_TRIMMER = re.compile("\\s+(?=\\n|$)")


from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(has_repeat("Happy"))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'True\n'.strip(), "Test: " + 'print(has_repeat("Happy"))')


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(has_repeat("sad"))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'False\n'.strip(), "Test: " + 'print(has_repeat("sad"))')


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(has_repeat("salmons"))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'True\n'.strip(), "Test: " + 'print(has_repeat("salmons"))')


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(has_repeat("Trouts"))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'False\n'.strip(), "Test: " + 'print(has_repeat("Trouts"))')


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')
    
    if not (has_repeat("3.14159") is True):
        print("error")
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), ''.strip(), "Test: " + 'if not (has_repeat("3.14159") is True):\n    print("error")')


  def test6(self):
    resetMyStdOut()
    setMyStdIn('')
    
    if not (has_repeat("dolphin") is False):
        print("oops")
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), ''.strip(), "Test: " + 'if not (has_repeat("dolphin") is False):\n    print("oops")')


  def test7(self):
    resetMyStdOut()
    setMyStdIn('')
    
    if not (has_repeat("") is False):
        print("problem here")
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), ''.strip(), "Test: " + 'if not (has_repeat("") is False):\n    print("problem here")')


  def test8(self):
    resetMyStdOut()
    setMyStdIn('')
    
    if not (has_repeat("1word1") is True):
        print("ERROR")
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), ''.strip(), "Test: " + 'if not (has_repeat("1word1") is True):\n    print("ERROR")')


  def test9(self):
    resetMyStdOut()
    setMyStdIn('')
    
    if not (has_repeat("1word2") is False):
        print("ERROR!")
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), ''.strip(), "Test: " + 'if not (has_repeat("1word2") is False):\n    print("ERROR!")')



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-string_has_adjacent_repeats-2" label="exe-sec-HW5-PRACTICE-1-31055">
      <title>String Has Adjacent Repeated Characters?</title>
      <statement>
        <p>Write the code to define the function <c>has_adjacent_repeats(mystr)</c>, which takes a string parameter and returns a boolean result.</p>
        <p>- If mystr has at least one instance of adjacent characters being equal, return True</p>
        <p>- Otherwise, return False</p>
        <p>Hint: You can iterate over the positive indices i for characters in mystr: 1, 2, 3, ...., len(mystr)-1 with a <alert>for</alert> loop. For each i, if the character at index i matches the character at index i - 1, return <alert>True</alert>. Otherwise, if no doubled character is found in the entire string, return <alert>False</alert>.</p>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="40%" />
          <col top="minor" width="60%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Test</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>if not (has_adjacent_repeats("NOODLES") is True):
    print("error")                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd />
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>if not (has_adjacent_repeats("Bananas") is False):
    print("shwoopsie")                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd />
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>if not (has_adjacent_repeats("Hanoverr") is True):
    print("error")                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd />
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">_my_out = ""
_my_in = []
_datafiles = {}

# Start of FileLike
class FileLike:
  def __init__(self, contents):
    self.contents = contents
    self.cursor = 0

  def __enter__(self):
    return self

  def __exit__(self, exc_type, exc_value, traceback):
    self.close()

  def tell(self):
    return self.cursor

  def seek(self, n):
    self.cursor = n

  def read(self):
    n = self.cursor
    self.cursor = max(n, len(self.contents))
    return self.contents[n:]

  def readline(self):
    n = self.cursor
    rest = self.contents[n:]
    index = rest.find("\n")
    if index == -1:
      self.cursor = len(self.contents)
      return rest
    index += 1
    self.cursor = n + index
    return rest[:index]

  def readlines(self):
    results = []
    while True:
      line = self.readline()
      if line == '':
        return results
      results.append(line)

  def close(self):
    pass

# End of FileLike

def open(fname, mode = "r"):
  """our own open"""
  if fname in _datafiles:
    return FileLike(_datafiles[fname])
  raise BaseException(f"File not found: {fname}")


def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise EOFError()
  return _my_in.pop()

None

        </preamble>
        <code>

        </code>
        <postamble visible="no">
        </postamble>
        <tests>import re

RIGHT_WHITESPACE_TRIMMER = re.compile("\\s+(?=\\n|$)")


from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')
    
    if not (has_adjacent_repeats("NOODLES") is True):
        print("error")
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), ''.strip(), "Test: " + 'if not (has_adjacent_repeats("NOODLES") is True):\n    print("error")')


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')
    
    if not (has_adjacent_repeats("Bananas") is False):
        print("shwoopsie")
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), ''.strip(), "Test: " + 'if not (has_adjacent_repeats("Bananas") is False):\n    print("shwoopsie")')


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')
    
    if not (has_adjacent_repeats("Hanoverr") is True):
        print("error")
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), ''.strip(), "Test: " + 'if not (has_adjacent_repeats("Hanoverr") is True):\n    print("error")')


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')
    
    if not (has_adjacent_repeats("LLAMA") is True):
        print("error")
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), ''.strip(), "Test: " + 'if not (has_adjacent_repeats("LLAMA") is True):\n    print("error")')


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')
    
    if not (has_adjacent_repeats("information") is False):
        print("error")
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), ''.strip(), "Test: " + 'if not (has_adjacent_repeats("information") is False):\n    print("error")')


  def test6(self):
    resetMyStdOut()
    setMyStdIn('')
    
    if not (has_adjacent_repeats("Hanover") is False):
        print("error")
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), ''.strip(), "Test: " + 'if not (has_adjacent_repeats("Hanover") is False):\n    print("error")')


  def test7(self):
    resetMyStdOut()
    setMyStdIn('')
    
    if not (has_adjacent_repeats("") is False):
        print("error")
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), ''.strip(), "Test: " + 'if not (has_adjacent_repeats("") is False):\n    print("error")')


  def test8(self):
    resetMyStdOut()
    setMyStdIn('')
    
    if not (has_adjacent_repeats("H") is False):
        print("error")
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), ''.strip(), "Test: " + 'if not (has_adjacent_repeats("H") is False):\n    print("error")')


  def test9(self):
    resetMyStdOut()
    setMyStdIn('')
    
    if not (has_adjacent_repeats("AA") is True):
        print("error")
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), ''.strip(), "Test: " + 'if not (has_adjacent_repeats("AA") is True):\n    print("error")')


  def test10(self):
    resetMyStdOut()
    setMyStdIn('')
    
    if not (has_adjacent_repeats("123456788") is True):
        print("problem!")
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), ''.strip(), "Test: " + 'if not (has_adjacent_repeats("123456788") is True):\n    print("problem!")')


  def test11(self):
    resetMyStdOut()
    setMyStdIn('')
    
    if not (has_adjacent_repeats("1x2x3x4x5x6x7x8") is False):
        print("problem!!")
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), ''.strip(), "Test: " + 'if not (has_adjacent_repeats("1x2x3x4x5x6x7x8") is False):\n    print("problem!!")')



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-string_is_numberlike-2" label="exe-sec-HW5-PRACTICE-1-31056">
      <title>String is Numberlike?</title>
      <statement>
        <p><c>mystr</c> is "numberlike" if:</p>
        <p>- <alert>mystr</alert> is not the empty string</p>
        <p>- the first character in <alert>mystr</alert> is a digit</p>
        <p>- the count of '.' in <alert>mystr</alert> is zero or one (can't have more than one decimal point in a number)</p>
        <p>- every character in <alert>mystr</alert> is a digit ('0', '1', '2', ..., '9') or a decimal point ('.')</p>
        <p>Write the code to define the function <c>is_numberlike(mystr)</c>, which takes a string parameter and returns a boolean result.</p>
        <p>If mystr is numberlike, the function returns <alert>True</alert>; otherwise, the function returns <alert>False</alert>.</p>
        <p>Hint: Check the first three requirements with decision statements, then use a <alert>for</alert>loop to iterate over mystr and check the every character is a digit or a dot</p>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="40%" />
          <col top="minor" width="60%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Test</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>if not (is_numberlike("13.5") is True):
    print("error")                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd />
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>if not (is_numberlike("-5532") is False):
    print("error")                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd />
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>if not (is_numberlike("175") is True):
    print("error")                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd />
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">_my_out = ""
_my_in = []
_datafiles = {}

# Start of FileLike
class FileLike:
  def __init__(self, contents):
    self.contents = contents
    self.cursor = 0

  def __enter__(self):
    return self

  def __exit__(self, exc_type, exc_value, traceback):
    self.close()

  def tell(self):
    return self.cursor

  def seek(self, n):
    self.cursor = n

  def read(self):
    n = self.cursor
    self.cursor = max(n, len(self.contents))
    return self.contents[n:]

  def readline(self):
    n = self.cursor
    rest = self.contents[n:]
    index = rest.find("\n")
    if index == -1:
      self.cursor = len(self.contents)
      return rest
    index += 1
    self.cursor = n + index
    return rest[:index]

  def readlines(self):
    results = []
    while True:
      line = self.readline()
      if line == '':
        return results
      results.append(line)

  def close(self):
    pass

# End of FileLike

def open(fname, mode = "r"):
  """our own open"""
  if fname in _datafiles:
    return FileLike(_datafiles[fname])
  raise BaseException(f"File not found: {fname}")


def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise EOFError()
  return _my_in.pop()

None

        </preamble>
        <code>
from string import digits

def is_numberlike(mystr):
    # Case 1: The empty string is not numberlike
    if mystr == "":
        return False
        
    ## more code here ##
        </code>
        <postamble visible="no">
        </postamble>
        <tests>import re

RIGHT_WHITESPACE_TRIMMER = re.compile("\\s+(?=\\n|$)")


from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')
    
    if not (is_numberlike("13.5") is True):
        print("error")
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), ''.strip(), "Test: " + 'if not (is_numberlike("13.5") is True):\n    print("error")')


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')
    
    if not (is_numberlike("-5532") is False):
        print("error")
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), ''.strip(), "Test: " + 'if not (is_numberlike("-5532") is False):\n    print("error")')


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')
    
    if not (is_numberlike("175") is True):
        print("error")
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), ''.strip(), "Test: " + 'if not (is_numberlike("175") is True):\n    print("error")')


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')
    
    if not (is_numberlike("3") is True):
        print("error")
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), ''.strip(), "Test: " + 'if not (is_numberlike("3") is True):\n    print("error")')


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')
    
    if not (is_numberlike(".") is False):
        print("error")
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), ''.strip(), "Test: " + 'if not (is_numberlike(".") is False):\n    print("error")')


  def test6(self):
    resetMyStdOut()
    setMyStdIn('')
    
    if not (is_numberlike("") is False):
        print("oops!")
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), ''.strip(), "Test: " + 'if not (is_numberlike("") is False):\n    print("oops!")')


  def test7(self):
    resetMyStdOut()
    setMyStdIn('')
    
    if not (is_numberlike("3.141.59") is False):
        print("oops!")
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), ''.strip(), "Test: " + 'if not (is_numberlike("3.141.59") is False):\n    print("oops!")')


  def test8(self):
    resetMyStdOut()
    setMyStdIn('')
    
    if not (is_numberlike("88.59!") is False):
        print("oops!")
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), ''.strip(), "Test: " + 'if not (is_numberlike("88.59!") is False):\n    print("oops!")')


  def test9(self):
    resetMyStdOut()
    setMyStdIn('')
    
    if not (is_numberlike("1234B") is False):
        print("oops!")
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), ''.strip(), "Test: " + 'if not (is_numberlike("1234B") is False):\n    print("oops!")')


  def test10(self):
    resetMyStdOut()
    setMyStdIn('')
    
    if not (is_numberlike("1242498792472.9749247") is True):
        print("oops!")
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), ''.strip(), "Test: " + 'if not (is_numberlike("1242498792472.9749247") is True):\n    print("oops!")')


  def test11(self):
    resetMyStdOut()
    setMyStdIn('')
    
    if not (is_numberlike("3344.") is True):
        print("oops!")
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), ''.strip(), "Test: " + 'if not (is_numberlike("3344.") is True):\n    print("oops!")')


  def test12(self):
    resetMyStdOut()
    setMyStdIn('')
    
    if not (is_numberlike("332.2") is True):
        print("oops!")
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), ''.strip(), "Test: " + 'if not (is_numberlike("332.2") is True):\n    print("oops!")')


  def test13(self):
    resetMyStdOut()
    setMyStdIn('')
    
    if not (is_numberlike("54545") is True):
        print("oops!")
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), ''.strip(), "Test: " + 'if not (is_numberlike("54545") is True):\n    print("oops!")')


  def test14(self):
    resetMyStdOut()
    setMyStdIn('')
    
    if not (is_numberlike("0.") is True):
        print("oops!")
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), ''.strip(), "Test: " + 'if not (is_numberlike("0.") is True):\n    print("oops!")')


  def test15(self):
    resetMyStdOut()
    setMyStdIn('')
    
    if not (is_numberlike("1.2.3") is False):
        print("Oops!!!")
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), ''.strip(), "Test: " + 'if not (is_numberlike("1.2.3") is False):\n    print("Oops!!!")')



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-find_max_char-2" label="exe-sec-HW5-PRACTICE-1-31988">
      <title>Find Max Char</title>
      <statement>
        <p>The function <c>find_</c><c>max_char</c> takes one string parameter, <c>mystr</c>. The function returns the character in <c>mystr</c> with the maximum ordinal value (the character that comes last in the ASCII alphabet, relative to the other characters in <c>mystr</c>). However, if <alert>mystr</alert> is the empty string, the function returns the Python object <alert>None</alert>.</p>
        <p>Notice that we don't need the ord() function to compare ordinal values; we can use comparison operators. For example, "Z" &gt; "C" is true because Z comes after C in the ASCII alphabet.</p>
        <p>We need to "accumulate" the correct answer (max_char) and then return it:</p>
        <p>
          <ul>
            <li>First, if mystr is empty, return None</li>
            <li>Then initialize max_char (accumulator variable) to the first character in mystr</li>
            <li>Use a for loop to iterate ch over the characters in mystr</li>
            <li>Each time a new maximum character is found (<c>if ch &gt; max_char</c>), max_char is updated to "remember" that the new maximum is ch</li>
            <li>Finally, return max_char</li>
          </ul>
        </p>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="40%" />
          <col top="minor" width="60%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Test</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>print(find_max_char("naproxen"))</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>x</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>print(find_max_char("Gorilla Glue"))</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>u</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>print(find_max_char(""))</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>None</cd>
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">_my_out = ""
_my_in = []
_datafiles = {}

# Start of FileLike
class FileLike:
  def __init__(self, contents):
    self.contents = contents
    self.cursor = 0

  def __enter__(self):
    return self

  def __exit__(self, exc_type, exc_value, traceback):
    self.close()

  def tell(self):
    return self.cursor

  def seek(self, n):
    self.cursor = n

  def read(self):
    n = self.cursor
    self.cursor = max(n, len(self.contents))
    return self.contents[n:]

  def readline(self):
    n = self.cursor
    rest = self.contents[n:]
    index = rest.find("\n")
    if index == -1:
      self.cursor = len(self.contents)
      return rest
    index += 1
    self.cursor = n + index
    return rest[:index]

  def readlines(self):
    results = []
    while True:
      line = self.readline()
      if line == '':
        return results
      results.append(line)

  def close(self):
    pass

# End of FileLike

def open(fname, mode = "r"):
  """our own open"""
  if fname in _datafiles:
    return FileLike(_datafiles[fname])
  raise BaseException(f"File not found: {fname}")


def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise EOFError()
  return _my_in.pop()

None

        </preamble>
        <code>

        </code>
        <postamble visible="no">
        </postamble>
        <tests>import re

RIGHT_WHITESPACE_TRIMMER = re.compile("\\s+(?=\\n|$)")


from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(find_max_char("naproxen"))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'x\n'.strip(), "Test: " + 'print(find_max_char("naproxen"))')


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(find_max_char("Gorilla Glue"))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'u\n'.strip(), "Test: " + 'print(find_max_char("Gorilla Glue"))')


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(find_max_char(""))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'None'.strip(), "Test: " + 'print(find_max_char(""))')


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(find_max_char("X"))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'X\n'.strip(), "Test: " + 'print(find_max_char("X"))')


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(find_max_char("!@#$%^&amp;*()"))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '^\n'.strip(), "Test: " + 'print(find_max_char("!@#$%^&amp;*()"))')


  def test6(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(find_max_char("zebras"))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'z\n'.strip(), "Test: " + 'print(find_max_char("zebras"))')


  def test7(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(find_max_char("7905"))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '9\n'.strip(), "Test: " + 'print(find_max_char("7905"))')


  def test8(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(find_max_char("Hanover"))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'v\n'.strip(), "Test: " + 'print(find_max_char("Hanover"))')



myTests().main()        </tests>
      </program>
    </exercise>
  </exercises>
</section>