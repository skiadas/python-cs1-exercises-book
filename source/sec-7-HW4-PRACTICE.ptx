<section xml:id="sec-HW4-PRACTICE-1">
  <title>HW4 PRACTICE</title>
  <introduction>
    <p dir="ltr">Ungraded assignment, allows you to practice the HW3 problems as you study for Quiz 4.</p>
  </introduction>
  <exercises>
    <exercise xml:id="exer-func_between_zero_one-2" label="exe-sec-HW4-PRACTICE-1-225598">
      <title>Between 0 and 1</title>
      <statement>
        <p>Write a function called <alert>between_zero_and_one</alert>that takes a parameter num; num will be a number at run time.  The function should return True if num falls strictly between 0 and 1; otherwise, it should return False.</p>
        <p>NOTE: This function does NOT read anything from standard input.</p>
        <p>NOTE: Your function should not print anything to standard output. Use a return statement, not a print statement, at the end of your function.</p>
        <p>Hint: Do not return the strings "True", "False". Boolean values are not quoted.</p>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="40%" />
          <col top="minor" width="60%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Test</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>print(between_zero_and_one(0.5))</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>True</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>print(between_zero_and_one(1.0))</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>False</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>print(between_zero_and_one(-2.2))</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>False</cd>
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">_my_out = ""
_my_in = []
_datafiles = {}

# Start of FileLike
class FileLike:
  def __init__(self, contents):
    self.contents = contents
    self.cursor = 0

  def __enter__(self):
    return self

  def __exit__(self, exc_type, exc_value, traceback):
    self.close()

  def tell(self):
    return self.cursor

  def seek(self, n):
    self.cursor = n

  def read(self):
    n = self.cursor
    self.cursor = max(n, len(self.contents))
    return self.contents[n:]

  def readline(self):
    n = self.cursor
    rest = self.contents[n:]
    index = rest.find("\n")
    if index == -1:
      self.cursor = len(self.contents)
      return rest
    index += 1
    self.cursor = n + index
    return rest[:index]

  def readlines(self):
    results = []
    while True:
      line = self.readline()
      if line == '':
        return results
      results.append(line)

  def close(self):
    pass

# End of FileLike

def open(fname, mode = "r"):
  """our own open"""
  if fname in _datafiles:
    return FileLike(_datafiles[fname])
  raise BaseException(f"File not found: {fname}")


def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise EOFError()
  return _my_in.pop()

None</preamble>
        <code></code>
        <postamble visible="no"></postamble>
        <tests>import re

RIGHT_WHITESPACE_TRIMMER = re.compile("\\s+(?=\\n|$)")


from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(between_zero_and_one(0.5))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'True'.strip(), "Test: " + 'print(between_zero_and_one(0.5))')


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(between_zero_and_one(1.0))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'False'.strip(), "Test: " + 'print(between_zero_and_one(1.0))')


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(between_zero_and_one(-2.2))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'False'.strip(), "Test: " + 'print(between_zero_and_one(-2.2))')


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(between_zero_and_one(0.1001))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'True'.strip(), "Test: " + 'print(between_zero_and_one(0.1001))')


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(between_zero_and_one(0.98))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'True'.strip(), "Test: " + 'print(between_zero_and_one(0.98))')


  def test6(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(between_zero_and_one(0.0001))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'True'.strip(), "Test: " + 'print(between_zero_and_one(0.0001))')


  def test7(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(between_zero_and_one(0.0))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'False'.strip(), "Test: " + 'print(between_zero_and_one(0.0))')


  def test8(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(between_zero_and_one(1.001))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'False'.strip(), "Test: " + 'print(between_zero_and_one(1.001))')



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-basic_conditional_divides-2" label="exe-sec-HW4-PRACTICE-1-31644">
      <title>Divides</title>
      <statement>
        <p>Define a function <alert>divides</alert>that takes integer parameters <alert>n</alert> and <alert>d</alert>.</p>
        <p><alert>-</alert>If n is a multiple of d, that is, if "d divides n" evenly, the function returns True and prints a message. For example, if n is 12 and d is 2, the message will say, "12 is divisible by 2"</p>
        <p>- Otherwise, the function returns False and prints  a negative message, for example, "12 is not divisible by 11"</p>
        <p>- Your function might  be around 7 lines long.</p>
        <p>Hint 1:  Use the remainder operator and an if-else conditional.</p>
        <p>Hint 2: Do not return the strings "True", "False". Return a Boolean constant, either <alert>True</alert> or <alert>False</alert> (no quotes)</p>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="40%" />
          <col top="minor" width="60%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Test</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>result = divides(12, 2)
print("Return value is", result)                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>12 is divisible by 2
Return value is True                </cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>result = divides(12, 5)
print("Return value is", result)                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>12 is not divisible by 5
Return value is False                </cd>
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">_my_out = ""
_my_in = []
_datafiles = {}

# Start of FileLike
class FileLike:
  def __init__(self, contents):
    self.contents = contents
    self.cursor = 0

  def __enter__(self):
    return self

  def __exit__(self, exc_type, exc_value, traceback):
    self.close()

  def tell(self):
    return self.cursor

  def seek(self, n):
    self.cursor = n

  def read(self):
    n = self.cursor
    self.cursor = max(n, len(self.contents))
    return self.contents[n:]

  def readline(self):
    n = self.cursor
    rest = self.contents[n:]
    index = rest.find("\n")
    if index == -1:
      self.cursor = len(self.contents)
      return rest
    index += 1
    self.cursor = n + index
    return rest[:index]

  def readlines(self):
    results = []
    while True:
      line = self.readline()
      if line == '':
        return results
      results.append(line)

  def close(self):
    pass

# End of FileLike

def open(fname, mode = "r"):
  """our own open"""
  if fname in _datafiles:
    return FileLike(_datafiles[fname])
  raise BaseException(f"File not found: {fname}")


def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise EOFError()
  return _my_in.pop()

None</preamble>
        <code></code>
        <postamble visible="no"></postamble>
        <tests>import re

RIGHT_WHITESPACE_TRIMMER = re.compile("\\s+(?=\\n|$)")


from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')
    
    result = divides(12, 2)
    print("Return value is", result)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '12 is divisible by 2\nReturn value is True\n'.strip(), "Test: " + 'result = divides(12, 2)\nprint("Return value is", result)')


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')
    
    result = divides(12, 5)
    print("Return value is", result)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '12 is not divisible by 5\nReturn value is False\n'.strip(), "Test: " + 'result = divides(12, 5)\nprint("Return value is", result)')


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')
    
    result = divides(8, 3)
    print("Return value is", result)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '8 is not divisible by 3\nReturn value is False\n'.strip(), "Test: " + 'result = divides(8, 3)\nprint("Return value is", result)')


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')
    
    result = divides(8, 4)
    print("Return value is", result)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '8 is divisible by 4\nReturn value is True\n'.strip(), "Test: " + 'result = divides(8, 4)\nprint("Return value is", result)')


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')
    
    result = divides(7, 7)
    print("Return value is", result)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '7 is divisible by 7\nReturn value is True\n'.strip(), "Test: " + 'result = divides(7, 7)\nprint("Return value is", result)')


  def test6(self):
    resetMyStdOut()
    setMyStdIn('')
    
    result = divides(7, -50)
    print("Return value is", result)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '7 is not divisible by -50\nReturn value is False\n'.strip(), "Test: " + 'result = divides(7, -50)\nprint("Return value is", result)')


  def test7(self):
    resetMyStdOut()
    setMyStdIn('')
    
    result = divides(100, 90)
    print("Return value is", result)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '100 is not divisible by 90\nReturn value is False\n'.strip(), "Test: " + 'result = divides(100, 90)\nprint("Return value is", result)')


  def test8(self):
    resetMyStdOut()
    setMyStdIn('')
    
    result = divides(100, -25)
    print("Return value is", result)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '100 is divisible by -25\nReturn value is True\n'.strip(), "Test: " + 'result = divides(100, -25)\nprint("Return value is", result)')



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-num_is_even_basic_conditional-2" label="exe-sec-HW4-PRACTICE-1-31642">
      <title>Num Is Even</title>
      <statement>
        <p>The function <c>isEven</c>takes one parameter, n (an integer). <c>isEven</c> returns a boolean result.</p>
        <p>- isEven returns <alert>True</alert>if n is even,</p>
        <p>- otherwise isEven returns <alert>False</alert>.</p>
        <p>Define the isEven function.</p>
        <p>Remember: Do not return the strings "True", "False". Return a Boolean constant, either <alert>True</alert> or <alert>False</alert> (no quotes)</p>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="40%" />
          <col top="minor" width="60%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Test</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>print(isEven(39))</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>False</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>print(isEven(26))</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>True</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>print(isEven(11))</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>False</cd>
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">_my_out = ""
_my_in = []
_datafiles = {}

# Start of FileLike
class FileLike:
  def __init__(self, contents):
    self.contents = contents
    self.cursor = 0

  def __enter__(self):
    return self

  def __exit__(self, exc_type, exc_value, traceback):
    self.close()

  def tell(self):
    return self.cursor

  def seek(self, n):
    self.cursor = n

  def read(self):
    n = self.cursor
    self.cursor = max(n, len(self.contents))
    return self.contents[n:]

  def readline(self):
    n = self.cursor
    rest = self.contents[n:]
    index = rest.find("\n")
    if index == -1:
      self.cursor = len(self.contents)
      return rest
    index += 1
    self.cursor = n + index
    return rest[:index]

  def readlines(self):
    results = []
    while True:
      line = self.readline()
      if line == '':
        return results
      results.append(line)

  def close(self):
    pass

# End of FileLike

def open(fname, mode = "r"):
  """our own open"""
  if fname in _datafiles:
    return FileLike(_datafiles[fname])
  raise BaseException(f"File not found: {fname}")


def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise EOFError()
  return _my_in.pop()

None</preamble>
        <code></code>
        <postamble visible="no"></postamble>
        <tests>import re

RIGHT_WHITESPACE_TRIMMER = re.compile("\\s+(?=\\n|$)")


from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(isEven(39))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'False\n'.strip(), "Test: " + 'print(isEven(39))')


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(isEven(26))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'True\n'.strip(), "Test: " + 'print(isEven(26))')


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(isEven(11))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'False\n'.strip(), "Test: " + 'print(isEven(11))')


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(isEven(0))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'True\n'.strip(), "Test: " + 'print(isEven(0))')


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(isEven(-33))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'False\n'.strip(), "Test: " + 'print(isEven(-33))')


  def test6(self):
    resetMyStdOut()
    setMyStdIn('')
    
    if isEven(7):
        print("error")
    else:
        print("OK")
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'OK\n'.strip(), "Test: " + 'if isEven(7):\n    print("error")\nelse:\n    print("OK")')



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-num_is_positive_simple_conditional-2" label="exe-sec-HW4-PRACTICE-1-31643">
      <title>isPositive</title>
      <statement>
        <p>The function <c>isPositive</c>takes one parameter, n (a number).</p>
        <p>- If n is positive, the function prints a message stating that n is positive and then returns True</p>
        <p>-  If n is zero, the function prints a message stating that n is zero and then returns False</p>
        <p>- If n is negative, the function prints a message stating that n is negative and then returns False</p>
        <p>Write a definition for isPositive.</p>
        <p>Remember: Do not return "True", "False". Return the Boolean constants: True, False (no quotation marks).</p>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="40%" />
          <col top="minor" width="60%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Test</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>print(isPositive(35))</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>35 is positive
True                </cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>print(isPositive(0))</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>0 is zero
False                </cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>print(isPositive(-0.1))</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>-0.1 is negative
False                </cd>
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">_my_out = ""
_my_in = []
_datafiles = {}

# Start of FileLike
class FileLike:
  def __init__(self, contents):
    self.contents = contents
    self.cursor = 0

  def __enter__(self):
    return self

  def __exit__(self, exc_type, exc_value, traceback):
    self.close()

  def tell(self):
    return self.cursor

  def seek(self, n):
    self.cursor = n

  def read(self):
    n = self.cursor
    self.cursor = max(n, len(self.contents))
    return self.contents[n:]

  def readline(self):
    n = self.cursor
    rest = self.contents[n:]
    index = rest.find("\n")
    if index == -1:
      self.cursor = len(self.contents)
      return rest
    index += 1
    self.cursor = n + index
    return rest[:index]

  def readlines(self):
    results = []
    while True:
      line = self.readline()
      if line == '':
        return results
      results.append(line)

  def close(self):
    pass

# End of FileLike

def open(fname, mode = "r"):
  """our own open"""
  if fname in _datafiles:
    return FileLike(_datafiles[fname])
  raise BaseException(f"File not found: {fname}")


def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise EOFError()
  return _my_in.pop()

None</preamble>
        <code></code>
        <postamble visible="no"></postamble>
        <tests>import re

RIGHT_WHITESPACE_TRIMMER = re.compile("\\s+(?=\\n|$)")


from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(isPositive(35))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '35 is positive\nTrue\n'.strip(), "Test: " + 'print(isPositive(35))')


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(isPositive(.00005))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '5e-05 is positive\nTrue\n'.strip(), "Test: " + 'print(isPositive(.00005))')


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(isPositive(0))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '0 is zero\nFalse\n'.strip(), "Test: " + 'print(isPositive(0))')


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(isPositive(-0.1))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '-0.1 is negative\nFalse\n'.strip(), "Test: " + 'print(isPositive(-0.1))')


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(isPositive(-10) or isPositive(20))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '-10 is negative\n20 is positive\nTrue\n'.strip(), "Test: " + 'print(isPositive(-10) or isPositive(20))')


  def test6(self):
    resetMyStdOut()
    setMyStdIn('')
    
    if isPositive(-20):
        print("error")
    else:
        print("OK")
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '-20 is negative\nOK\n'.strip(), "Test: " + 'if isPositive(-20):\n    print("error")\nelse:\n    print("OK")')



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-divisible_by_3_or_5_nested_decision-2" label="exe-sec-HW4-PRACTICE-1-31701">
      <title>Divisible by 3 or 5</title>
      <statement>
        <p>This problem requires a short program, not a function definition.</p>
        <p>Write the code needed to get an integer from standard input.  Then, write a simple decision statement that will output a message reporting whether the number is evenly divisible by 3, or by 5, or both, or neither.  You might need about 10 lines of code.</p>
        <p><em>See the examples for the expected format of the output.</em></p>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="30%" />
          <col top="minor" width="70%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Input</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>-7</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>-7 is divisible by neither 3 nor 5</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>60
                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>60 is divisible by both 3 and 5</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>54</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>54 is divisible by 3</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>125</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>125 is divisible by 5</cd>
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">_my_out = ""
_my_in = []
_datafiles = {}

# Start of FileLike
class FileLike:
  def __init__(self, contents):
    self.contents = contents
    self.cursor = 0

  def __enter__(self):
    return self

  def __exit__(self, exc_type, exc_value, traceback):
    self.close()

  def tell(self):
    return self.cursor

  def seek(self, n):
    self.cursor = n

  def read(self):
    n = self.cursor
    self.cursor = max(n, len(self.contents))
    return self.contents[n:]

  def readline(self):
    n = self.cursor
    rest = self.contents[n:]
    index = rest.find("\n")
    if index == -1:
      self.cursor = len(self.contents)
      return rest
    index += 1
    self.cursor = n + index
    return rest[:index]

  def readlines(self):
    results = []
    while True:
      line = self.readline()
      if line == '':
        return results
      results.append(line)

  def close(self):
    pass

# End of FileLike

def open(fname, mode = "r"):
  """our own open"""
  if fname in _datafiles:
    return FileLike(_datafiles[fname])
  raise BaseException(f"File not found: {fname}")


def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise EOFError()
  return _my_in.pop()

None


_program = """</preamble>
        <code></code>
        <postamble visible="no">"""</postamble>
        <tests>import re

RIGHT_WHITESPACE_TRIMMER = re.compile("\\s+(?=\\n|$)")


from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('2')
    
    exec(_program)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '2 is divisible by neither 3 nor 5\n'.strip(), "Input: " + '2')


  def test2(self):
    resetMyStdOut()
    setMyStdIn('-7')
    
    exec(_program)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '-7 is divisible by neither 3 nor 5\n'.strip(), "Input: " + '-7')


  def test3(self):
    resetMyStdOut()
    setMyStdIn('60\n')
    
    exec(_program)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '60 is divisible by both 3 and 5\n'.strip(), "Input: " + '60\n')


  def test4(self):
    resetMyStdOut()
    setMyStdIn('-45\n')
    
    exec(_program)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '-45 is divisible by both 3 and 5\n'.strip(), "Input: " + '-45\n')


  def test5(self):
    resetMyStdOut()
    setMyStdIn('27')
    
    exec(_program)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '27 is divisible by 3\n'.strip(), "Input: " + '27')


  def test6(self):
    resetMyStdOut()
    setMyStdIn('54')
    
    exec(_program)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '54 is divisible by 3\n'.strip(), "Input: " + '54')


  def test7(self):
    resetMyStdOut()
    setMyStdIn('125')
    
    exec(_program)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '125 is divisible by 5\n'.strip(), "Input: " + '125')


  def test8(self):
    resetMyStdOut()
    setMyStdIn('-1250')
    
    exec(_program)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '-1250 is divisible by 5\n'.strip(), "Input: " + '-1250')



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-func_inside_unit_circle-2" label="exe-sec-HW4-PRACTICE-1-160469">
      <title>Is In Unit Circle</title>
      <statement>
        <p>Write a function called is_in_unit_circle that takes two parameters, <alert>x</alert> and <alert>y</alert> (floats), the coordinates of a point in the x-y plane.</p>
        <p>- The function returns <alert>True</alert>if (x, y) is less than one unit away from (0,0) [i.e., if the point (x, y) is inside the unit circle];</p>
        <p>- Otherwise, the function returns <alert>False</alert></p>
        <p><alert>Hint:</alert>Use the distance formula to calculate the distance (or the square of the distance) from (x, y) to (0, 0). Then compare that distance with 1.</p>
        <p><alert>D</alert><alert>istance between two points = √((x&amp;lt;sub&amp;rt;2&amp;lt;/sub&amp;rt; – x&amp;lt;sub&amp;rt;1&amp;lt;/sub&amp;rt;)² + (y&amp;lt;sub&amp;rt;2&amp;lt;/sub&amp;rt; – y&amp;lt;sub&amp;rt;1&amp;lt;/sub&amp;rt;)²)</alert></p>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="40%" />
          <col top="minor" width="60%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Test</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>print(is_in_unit_circle(2, .9))</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>False</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>print(is_in_unit_circle(.70, -.61))</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>True</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>print(is_in_unit_circle(.055, .81))</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>True</cd>
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">_my_out = ""
_my_in = []
_datafiles = {}

# Start of FileLike
class FileLike:
  def __init__(self, contents):
    self.contents = contents
    self.cursor = 0

  def __enter__(self):
    return self

  def __exit__(self, exc_type, exc_value, traceback):
    self.close()

  def tell(self):
    return self.cursor

  def seek(self, n):
    self.cursor = n

  def read(self):
    n = self.cursor
    self.cursor = max(n, len(self.contents))
    return self.contents[n:]

  def readline(self):
    n = self.cursor
    rest = self.contents[n:]
    index = rest.find("\n")
    if index == -1:
      self.cursor = len(self.contents)
      return rest
    index += 1
    self.cursor = n + index
    return rest[:index]

  def readlines(self):
    results = []
    while True:
      line = self.readline()
      if line == '':
        return results
      results.append(line)

  def close(self):
    pass

# End of FileLike

def open(fname, mode = "r"):
  """our own open"""
  if fname in _datafiles:
    return FileLike(_datafiles[fname])
  raise BaseException(f"File not found: {fname}")


def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise EOFError()
  return _my_in.pop()

None</preamble>
        <code></code>
        <postamble visible="no"></postamble>
        <tests>import re

RIGHT_WHITESPACE_TRIMMER = re.compile("\\s+(?=\\n|$)")


from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(is_in_unit_circle(2, .9))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'False\n'.strip(), "Test: " + 'print(is_in_unit_circle(2, .9))')


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(is_in_unit_circle(.70, -.61))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'True\n'.strip(), "Test: " + 'print(is_in_unit_circle(.70, -.61))')


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(is_in_unit_circle(.055, .81))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'True\n'.strip(), "Test: " + 'print(is_in_unit_circle(.055, .81))')


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(is_in_unit_circle(0, .506))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'True\n'.strip(), "Test: " + 'print(is_in_unit_circle(0, .506))')


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')
    
    if is_in_unit_circle(.9, .5):
        print("error")
    else:
        print("OK")
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'OK\n'.strip(), "Test: " + 'if is_in_unit_circle(.9, .5):\n    print("error")\nelse:\n    print("OK")')


  def test6(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(is_in_unit_circle(-.88, -.77))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'False\n'.strip(), "Test: " + 'print(is_in_unit_circle(-.88, -.77))')



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-sum_over_a_list_Basic_accumulator-2" label="exe-sec-HW4-PRACTICE-1-31564">
      <title>Sum over a list</title>
      <statement>
        <p>Define the function list_sum(L); it takes one parameter L, a list of numbers, and returns the sum of all the items in L.</p>
        <p>Hint: Use the "accumulate a sum" pattern, and use L as the sequence expression in your for loop.</p>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="40%" />
          <col top="minor" width="60%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Test</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>L = [9, 6, 8, 5, 7]
print(list_sum(L))                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>35</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>L = [15, 7, -1, 11, 19, 3, -5]
print(list_sum(L))                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>49</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>L = []
print(list_sum(L))                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>0</cd>
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">_my_out = ""
_my_in = []
_datafiles = {}

# Start of FileLike
class FileLike:
  def __init__(self, contents):
    self.contents = contents
    self.cursor = 0

  def __enter__(self):
    return self

  def __exit__(self, exc_type, exc_value, traceback):
    self.close()

  def tell(self):
    return self.cursor

  def seek(self, n):
    self.cursor = n

  def read(self):
    n = self.cursor
    self.cursor = max(n, len(self.contents))
    return self.contents[n:]

  def readline(self):
    n = self.cursor
    rest = self.contents[n:]
    index = rest.find("\n")
    if index == -1:
      self.cursor = len(self.contents)
      return rest
    index += 1
    self.cursor = n + index
    return rest[:index]

  def readlines(self):
    results = []
    while True:
      line = self.readline()
      if line == '':
        return results
      results.append(line)

  def close(self):
    pass

# End of FileLike

def open(fname, mode = "r"):
  """our own open"""
  if fname in _datafiles:
    return FileLike(_datafiles[fname])
  raise BaseException(f"File not found: {fname}")


def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise EOFError()
  return _my_in.pop()

None</preamble>
        <code></code>
        <postamble visible="no"></postamble>
        <tests>import re

RIGHT_WHITESPACE_TRIMMER = re.compile("\\s+(?=\\n|$)")


from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = [9, 6, 8, 5, 7]
    print(list_sum(L))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '35\n'.strip(), "Test: " + 'L = [9, 6, 8, 5, 7]\nprint(list_sum(L))')


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = [15, 7, -1, 11, 19, 3, -5]
    print(list_sum(L))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '49\n'.strip(), "Test: " + 'L = [15, 7, -1, 11, 19, 3, -5]\nprint(list_sum(L))')


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = []
    print(list_sum(L))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '0\n'.strip(), "Test: " + 'L = []\nprint(list_sum(L))')


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = [1, 2, 3]
    print(list_sum(L))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '6\n'.strip(), "Test: " + 'L = [1, 2, 3]\nprint(list_sum(L))')


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = [42]
    print(list_sum(L))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '42\n'.strip(), "Test: " + 'L = [42]\nprint(list_sum(L))')


  def test6(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = [15, 7, -1, 11, 19, 3, -5, 1010, 2211, 3321]
    print(list_sum(L))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '6591\n'.strip(), "Test: " + 'L = [15, 7, -1, 11, 19, 3, -5, 1010, 2211, 3321]\nprint(list_sum(L))')



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-accumulate_list_product-2" label="exe-sec-HW4-PRACTICE-1-31638">
      <title>List Product</title>
      <statement>
        <p>Define a function list_product(L) which takes a parameter L, a list of numbers, and returns the product of all the items in L.</p>
        <p>Hint: Use the accumulate-a-product pattern as discussed in class. Remember, you should <alert>not</alert> initialize your accumulator variable to 0 when it represents a product.</p>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="40%" />
          <col top="minor" width="60%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Test</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>L = [3, 2, 7, -1, 4]
print(list_product(L))                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>-168</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>L = [55]
print(list_product(L))                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>55</cd>
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">_my_out = ""
_my_in = []
_datafiles = {}

# Start of FileLike
class FileLike:
  def __init__(self, contents):
    self.contents = contents
    self.cursor = 0

  def __enter__(self):
    return self

  def __exit__(self, exc_type, exc_value, traceback):
    self.close()

  def tell(self):
    return self.cursor

  def seek(self, n):
    self.cursor = n

  def read(self):
    n = self.cursor
    self.cursor = max(n, len(self.contents))
    return self.contents[n:]

  def readline(self):
    n = self.cursor
    rest = self.contents[n:]
    index = rest.find("\n")
    if index == -1:
      self.cursor = len(self.contents)
      return rest
    index += 1
    self.cursor = n + index
    return rest[:index]

  def readlines(self):
    results = []
    while True:
      line = self.readline()
      if line == '':
        return results
      results.append(line)

  def close(self):
    pass

# End of FileLike

def open(fname, mode = "r"):
  """our own open"""
  if fname in _datafiles:
    return FileLike(_datafiles[fname])
  raise BaseException(f"File not found: {fname}")


def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise EOFError()
  return _my_in.pop()

None</preamble>
        <code></code>
        <postamble visible="no"></postamble>
        <tests>import re

RIGHT_WHITESPACE_TRIMMER = re.compile("\\s+(?=\\n|$)")


from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = [3, 2, 7, -1, 4]
    print(list_product(L))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '-168\n'.strip(), "Test: " + 'L = [3, 2, 7, -1, 4]\nprint(list_product(L))')


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = [55]
    print(list_product(L))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '55\n'.strip(), "Test: " + 'L = [55]\nprint(list_product(L))')


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = list(range(2, 12, 2))
    print(list_product(L))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '3840\n'.strip(), "Test: " + 'L = list(range(2, 12, 2))\nprint(list_product(L))')


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = [5, 2, -2, -5]
    print(list_product(L))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '100\n'.strip(), "Test: " + 'L = [5, 2, -2, -5]\nprint(list_product(L))')


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = [2, 3, 5, 7, 11, 13, 17, 19, 23]
    print(list_product(L))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '223092870\n'.strip(), "Test: " + 'L = [2, 3, 5, 7, 11, 13, 17, 19, 23]\nprint(list_product(L))')



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-count_negatives_1-2" label="exe-sec-HW4-PRACTICE-1-31647">
      <title>Count Negatives in a list</title>
      <statement>
        <p>Define a function count_negatives(L), which takes a list of numbers, L, as its parameter. The function returns an integer count telling how many of the items in L are negative (less than zero).</p>
        <p>Hint: Use the accumulator pattern.</p>
        <p>- Initialize the accumulator to 0</p>
        <p>- Use a for loop to iterate over the items in L</p>
        <p>- Use an if statement to update the accumlator every time the current item is negative</p>
        <p>- Return the accumulator</p>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="40%" />
          <col top="minor" width="60%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Test</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>L = [0, -10, 2, -8, -4, -6, -2, 6, 4]
print(count_negatives(L))                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>5</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>L = [0, 6, 4]
print(count_negatives(L))                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>0</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>L = [-10, -4, -6, -2, 6, 4]
print(count_negatives(L))                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>4</cd>
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">_my_out = ""
_my_in = []
_datafiles = {}

# Start of FileLike
class FileLike:
  def __init__(self, contents):
    self.contents = contents
    self.cursor = 0

  def __enter__(self):
    return self

  def __exit__(self, exc_type, exc_value, traceback):
    self.close()

  def tell(self):
    return self.cursor

  def seek(self, n):
    self.cursor = n

  def read(self):
    n = self.cursor
    self.cursor = max(n, len(self.contents))
    return self.contents[n:]

  def readline(self):
    n = self.cursor
    rest = self.contents[n:]
    index = rest.find("\n")
    if index == -1:
      self.cursor = len(self.contents)
      return rest
    index += 1
    self.cursor = n + index
    return rest[:index]

  def readlines(self):
    results = []
    while True:
      line = self.readline()
      if line == '':
        return results
      results.append(line)

  def close(self):
    pass

# End of FileLike

def open(fname, mode = "r"):
  """our own open"""
  if fname in _datafiles:
    return FileLike(_datafiles[fname])
  raise BaseException(f"File not found: {fname}")


def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise EOFError()
  return _my_in.pop()

None</preamble>
        <code></code>
        <postamble visible="no"></postamble>
        <tests>import re

RIGHT_WHITESPACE_TRIMMER = re.compile("\\s+(?=\\n|$)")


from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = [0, -10, 2, -8, -4, -6, -2, 6, 4]
    print(count_negatives(L))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '5\n'.strip(), "Test: " + 'L = [0, -10, 2, -8, -4, -6, -2, 6, 4]\nprint(count_negatives(L))')


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = [0, 6, 4]
    print(count_negatives(L))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '0\n'.strip(), "Test: " + 'L = [0, 6, 4]\nprint(count_negatives(L))')


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = [-10, -4, -6, -2, 6, 4]
    print(count_negatives(L))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '4\n'.strip(), "Test: " + 'L = [-10, -4, -6, -2, 6, 4]\nprint(count_negatives(L))')


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = []
    print(count_negatives(L))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '0\n'.strip(), "Test: " + 'L = []\nprint(count_negatives(L))')


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L  = list(range(-37, 55, 3))
    print(count_negatives(L))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '13\n'.strip(), "Test: " + 'L  = list(range(-37, 55, 3))\nprint(count_negatives(L))')


  def test6(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = [-1, -5, -11, -15, -100]
    print(count_negatives(L))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '5\n'.strip(), "Test: " + 'L = [-1, -5, -11, -15, -100]\nprint(count_negatives(L))')


  def test7(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = list(range(-200, 150, 7))
    print(count_negatives(L))
    print(type(count_negatives(L)))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), "29\n&lt;class 'int'&gt;\n".strip(), "Test: " + 'L = list(range(-200, 150, 7))\nprint(count_negatives(L))\nprint(type(count_negatives(L)))')



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-count_spam-2" label="exe-sec-HW4-PRACTICE-1-31640">
      <title>Count SPAM in list</title>
      <statement>
        <p>Define the function count_SPAM(L), which takes a list of strings, L, as its parameter. The function returns a count of how many times the word "SPAM" occurs as an item in L.</p>
        <p><em>See the examples for the expected format of the output.</em></p>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="40%" />
          <col top="minor" width="60%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Test</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>L  = ["SPAM", "banana", "apple", "SPAM", "tuna"]
print(count_SPAM(L))                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>2</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>L = ["a", "stitch", "in", "time"]
print(count_SPAM(L))                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>0</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>L = ["SPAM", "SPAM", "SPAM", "egg", "and", "SPAM"]
print(count_SPAM(L))                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>4</cd>
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">_my_out = ""
_my_in = []
_datafiles = {}

# Start of FileLike
class FileLike:
  def __init__(self, contents):
    self.contents = contents
    self.cursor = 0

  def __enter__(self):
    return self

  def __exit__(self, exc_type, exc_value, traceback):
    self.close()

  def tell(self):
    return self.cursor

  def seek(self, n):
    self.cursor = n

  def read(self):
    n = self.cursor
    self.cursor = max(n, len(self.contents))
    return self.contents[n:]

  def readline(self):
    n = self.cursor
    rest = self.contents[n:]
    index = rest.find("\n")
    if index == -1:
      self.cursor = len(self.contents)
      return rest
    index += 1
    self.cursor = n + index
    return rest[:index]

  def readlines(self):
    results = []
    while True:
      line = self.readline()
      if line == '':
        return results
      results.append(line)

  def close(self):
    pass

# End of FileLike

def open(fname, mode = "r"):
  """our own open"""
  if fname in _datafiles:
    return FileLike(_datafiles[fname])
  raise BaseException(f"File not found: {fname}")


def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise EOFError()
  return _my_in.pop()

None</preamble>
        <code></code>
        <postamble visible="no"></postamble>
        <tests>import re

RIGHT_WHITESPACE_TRIMMER = re.compile("\\s+(?=\\n|$)")


from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L  = ["SPAM", "banana", "apple", "SPAM", "tuna"]
    print(count_SPAM(L))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '2\n'.strip(), "Test: " + 'L  = ["SPAM", "banana", "apple", "SPAM", "tuna"]\nprint(count_SPAM(L))')


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = ["a", "stitch", "in", "time"]
    print(count_SPAM(L))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '0\n'.strip(), "Test: " + 'L = ["a", "stitch", "in", "time"]\nprint(count_SPAM(L))')


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = ["SPAM", "SPAM", "SPAM", "egg", "and", "SPAM"]
    print(count_SPAM(L))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '4\n'.strip(), "Test: " + 'L = ["SPAM", "SPAM", "SPAM", "egg", "and", "SPAM"]\nprint(count_SPAM(L))')


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L  = ["SPAM", "SPAM", "SPAM", "SPAM", "SPAM", "SPAM", "baked beans and", "SPAM"]
    print(count_SPAM(L))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '7\n'.strip(), "Test: " + 'L  = ["SPAM", "SPAM", "SPAM", "SPAM", "SPAM", "SPAM", "baked beans and", "SPAM"]\nprint(count_SPAM(L))')


  def test5(self):
    resetMyStdOut()
    setMyStdIn('101')
    
    L = ["spam"]
    print(count_SPAM(L))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '0\n'.strip(), "Input: " + '101')


  def test6(self):
    resetMyStdOut()
    setMyStdIn('-12345')
    
    L = []
    print(count_SPAM(L))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '0\n'.strip(), "Input: " + '-12345')


  def test7(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L  = ["SPAM", "SPAM", "SPAM", "SPAM", "SPAM", "SPAM", "baked beans and", "SPAM", "SPAM", "SPAM", "SPAM", "SPAM", "SPAM", "SPAM", "baked beans and", "SPAM"]
    print(count_SPAM(L))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '14\n'.strip(), "Test: " + 'L  = ["SPAM", "SPAM", "SPAM", "SPAM", "SPAM", "SPAM", "baked beans and", "SPAM", "SPAM", "SPAM", "SPAM", "SPAM", "SPAM", "SPAM", "baked beans and", "SPAM"]\nprint(count_SPAM(L))')


  def test8(self):
    resetMyStdOut()
    setMyStdIn('')
    
    L = ["NO SPAM"]
    print(count_SPAM(L))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '0\n'.strip(), "Test: " + 'L = ["NO SPAM"]\nprint(count_SPAM(L))')



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-accumulator_count_divisors-2" label="exe-sec-HW4-PRACTICE-1-31648">
      <title>Count Divisors</title>
      <statement>
        <p>Write a short program, approximately 12 lines of code, to read a positive integer n from the keyboard, count the number of  positive integer divisors of n, and print a message reporting that count. In addition, if n is prime, also print, "That's a prime number!".  HINT: A positive integer n is prime provided n has exactly two positive integer divisors, 1 and n.</p>
        <p>For example, the divisors of 12 are 1, 2, 3, 4, 6, 12. There are 6 of them. If n = 12 is read from the keyboard, the program will print, "12 has 6 divisors."</p>
        <p>Warning: Notice that when n = 1, there is only one divisor. So the message needs to say, "1 has 1 divisor" (not "1 has 1 divisors").</p>
        <p><em>See the examples for the expected format of the output.</em></p>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="30%" />
          <col top="minor" width="70%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Input</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>1</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>1 has 1 divisor</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>3</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>3 has 2 divisors
That number is prime!                </cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>6
                </cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>6 has 4 divisors</cd>
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">_my_out = ""
_my_in = []
_datafiles = {}

# Start of FileLike
class FileLike:
  def __init__(self, contents):
    self.contents = contents
    self.cursor = 0

  def __enter__(self):
    return self

  def __exit__(self, exc_type, exc_value, traceback):
    self.close()

  def tell(self):
    return self.cursor

  def seek(self, n):
    self.cursor = n

  def read(self):
    n = self.cursor
    self.cursor = max(n, len(self.contents))
    return self.contents[n:]

  def readline(self):
    n = self.cursor
    rest = self.contents[n:]
    index = rest.find("\n")
    if index == -1:
      self.cursor = len(self.contents)
      return rest
    index += 1
    self.cursor = n + index
    return rest[:index]

  def readlines(self):
    results = []
    while True:
      line = self.readline()
      if line == '':
        return results
      results.append(line)

  def close(self):
    pass

# End of FileLike

def open(fname, mode = "r"):
  """our own open"""
  if fname in _datafiles:
    return FileLike(_datafiles[fname])
  raise BaseException(f"File not found: {fname}")


def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise EOFError()
  return _my_in.pop()

None


_program = """</preamble>
        <code>n = int(input())  # n will be positive</code>
        <postamble visible="no">"""</postamble>
        <tests>import re

RIGHT_WHITESPACE_TRIMMER = re.compile("\\s+(?=\\n|$)")


from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('1')
    
    exec(_program)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '1 has 1 divisor\n'.strip(), "Input: " + '1')


  def test2(self):
    resetMyStdOut()
    setMyStdIn('3')
    
    exec(_program)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '3 has 2 divisors\nThat number is prime!\n'.strip(), "Input: " + '3')


  def test3(self):
    resetMyStdOut()
    setMyStdIn('6\n')
    
    exec(_program)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '6 has 4 divisors\n'.strip(), "Input: " + '6\n')


  def test4(self):
    resetMyStdOut()
    setMyStdIn('10\n')
    
    exec(_program)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '10 has 4 divisors\n'.strip(), "Input: " + '10\n')


  def test5(self):
    resetMyStdOut()
    setMyStdIn('11')
    
    exec(_program)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '11 has 2 divisors\nThat number is prime!\n'.strip(), "Input: " + '11')


  def test6(self):
    resetMyStdOut()
    setMyStdIn('40320\n')
    
    exec(_program)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '40320 has 96 divisors\n'.strip(), "Input: " + '40320\n')


  def test7(self):
    resetMyStdOut()
    setMyStdIn('40321')
    
    exec(_program)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '40321 has 4 divisors\n'.strip(), "Input: " + '40321')


  def test8(self):
    resetMyStdOut()
    setMyStdIn('513')
    
    exec(_program)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '513 has 8 divisors\n'.strip(), "Input: " + '513')


  def test9(self):
    resetMyStdOut()
    setMyStdIn('577')
    
    exec(_program)
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '577 has 2 divisors\nThat number is prime!'.strip(), "Input: " + '577')



myTests().main()        </tests>
      </program>
    </exercise>
    <exercise xml:id="exer-accum_fib_20-2" label="exe-sec-HW4-PRACTICE-1-160096">
      <title>Accumulate Nth Fibonacci</title>
      <statement>
        <p>Write a function <c>F</c>to compute the Nth Fibonnaci number, where N is an integer parameter.</p>
        <p>By definition, F(1) and F(2) are both 1, while later terms are found  by adding the previous two terms to make the next. Algebraically, we define F(N) as follows:</p>
        <p>
          <ul>
            <li>F(1) = F(2) = 1</li>
            <li>When N &gt; 2, F(N) = F(N - 1) + F(N - 2)</li>
          </ul>
        </p>
        <p>So F(3) = F(2) + F(1) = 1  + 1  = 2, F(4) = F(3) +  F(2) = 2 + 1 = 3, F(5) =  5, F(6) =  8, etc.</p>
        <p>When N is positive, F should return the Nth Fibonacci number, F(N); when N is not positive, F should return the Python object <c>None</c>.</p>
        <p><alert>Big Hint</alert>: Use two accumulator variables, <c>previous</c>and <c>current</c>, since we will always add the last two terms to make the next term.</p>
        <p>
          <ul>
            <li>Initialize <c>previous</c>to have the value of F(1), and initialize <c>current</c>to have the value of F(2).</li>
            <li>Think about how many additional terms the for loop needs to calculate to determine F(N) when N &gt; 2. That number is the argument for the range function call in the first line of the loop.</li>
            <li>In the body of the loop, update both accumulators: let <c>next</c>be the sum of <c>previous</c>and <c>current</c>, update <c>previous</c>to equal <c>current</c>, and update <c>current</c>to equal <c>next</c>.</li>
            <li>When the for loop ends, return <alert>current.</alert></li>
          </ul>
        </p>
        <p>For example:</p>
        <tabular>
          <col top="minor" width="40%" />
          <col top="minor" width="60%" />
          <row header="yes" left="minor">
            <cell bottom="minor" right="minor">Test</cell>
            <cell bottom="minor" right="minor">Result</cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>print(F(10))</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>55</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>print(F(4))</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>3</cd>
              </p>
            </cell>
          </row>
          <row header="no" left="minor">
            <cell bottom="minor" right="minor">
              <p>
                <cd>print(F(3))</cd>
              </p>
            </cell>
            <cell bottom="minor" right="minor">
              <p>
                <cd>2</cd>
              </p>
            </cell>
          </row>
        </tabular>
      </statement>
      <program interactive="activecode" language="python">
        <preamble visible="no">_my_out = ""
_my_in = []
_datafiles = {}

# Start of FileLike
class FileLike:
  def __init__(self, contents):
    self.contents = contents
    self.cursor = 0

  def __enter__(self):
    return self

  def __exit__(self, exc_type, exc_value, traceback):
    self.close()

  def tell(self):
    return self.cursor

  def seek(self, n):
    self.cursor = n

  def read(self):
    n = self.cursor
    self.cursor = max(n, len(self.contents))
    return self.contents[n:]

  def readline(self):
    n = self.cursor
    rest = self.contents[n:]
    index = rest.find("\n")
    if index == -1:
      self.cursor = len(self.contents)
      return rest
    index += 1
    self.cursor = n + index
    return rest[:index]

  def readlines(self):
    results = []
    while True:
      line = self.readline()
      if line == '':
        return results
      results.append(line)

  def close(self):
    pass

# End of FileLike

def open(fname, mode = "r"):
  """our own open"""
  if fname in _datafiles:
    return FileLike(_datafiles[fname])
  raise BaseException(f"File not found: {fname}")


def getMyStdOut():
  global _my_out
  return _my_out

def setMyStdIn(s = None):
  global _my_in
  if s is None:
    _my_in = []
  else:
    _my_in = s.split('\n')
    _my_in.reverse()

def resetMyStdOut():
  global _my_out
  _my_out = ''

def print(*args, sep=' ', end='\n', file=None, flush=False):
  global _my_out
  if file is not None:
    raise RuntimeError("Cannot use this version of print on files")
  _my_out += sep.join(map(str, args)) + end

def input(prompt=None):
  global _my_in
  if prompt is not None:
    print(prompt, end='')
  if _my_in == []:
    raise EOFError()
  return _my_in.pop()

None</preamble>
        <code>def F(N):</code>
        <postamble visible="no"></postamble>
        <tests>import re

RIGHT_WHITESPACE_TRIMMER = re.compile("\\s+(?=\\n|$)")


from unittest.gui import TestCaseGui

class myTests(TestCaseGui):



  def test1(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(F(10))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '55\n'.strip(), "Test: " + 'print(F(10))')


  def test2(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(F(4))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '3\n'.strip(), "Test: " + 'print(F(4))')


  def test3(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(F(3))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '2\n'.strip(), "Test: " + 'print(F(3))')


  def test4(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(F(2))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '1\n'.strip(), "Test: " + 'print(F(2))')


  def test5(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(F(1))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '1\n'.strip(), "Test: " + 'print(F(1))')


  def test6(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(F(0))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'None\n'.strip(), "Test: " + 'print(F(0))')


  def test7(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(F(-3))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), 'None\n'.strip(), "Test: " + 'print(F(-3))')


  def test8(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(F(32))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '2178309\n'.strip(), "Test: " + 'print(F(32))')


  def test9(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(F(20))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '6765\n'.strip(), "Test: " + 'print(F(20))')


  def test10(self):
    resetMyStdOut()
    setMyStdIn('')
    
    print(F(30))
    
    self.assertEqual(RIGHT_WHITESPACE_TRIMMER.sub("", getMyStdOut().strip()), '832040\n'.strip(), "Test: " + 'print(F(30))')



myTests().main()        </tests>
      </program>
    </exercise>
  </exercises>
</section>